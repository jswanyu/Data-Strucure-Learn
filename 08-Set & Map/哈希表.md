# 哈希表

哈希表是又称散列表，一种以 "key-value" 形式存储数据的数据结构。所谓以 "key-value" 形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。

哈希表充分体现了算法的思想：空间换时间

哈希表最理想的情况就是每一个“键”都对应着一个不同的索引，这样就能够用O(1)的时间复杂度解决很多问题。

最坏的情况就是，只有1的空间大小，只能用O(n)的时间复杂度解决问题，这其实也就是线性表

哈希表是时间和空间之间的平衡，我们很难保证每一个“键”都对应着一个不同的索引，这取决于哈希函数怎么去设计。



# 哈希函数

hash是一种函数，一般翻译为散列，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是hashcode（散列值/哈希码）

要让键值对应到内存中的位置，就要为键值计算索引，也就是计算这个数据应该放到哪里。这个根据键值计算索引的函数就叫做哈希函数，也称散列函数。

举个例子，为26个字母构建长度为26的数组，'a'对应第0位，'b'对应第1位，以此类推，那么这个数组其实就是一个哈希表，哈希函数就是 f(ch) = ch - 'a'

很难保证每一个“键”都对应着一个不同的索引，这种现象称为“哈希冲突”，我们需要解决这种冲突。我们希望“键”通过哈希函数得到的“索引”分布越均匀越好，其最理想情况就是每一个“键”都对应着一个不同的索引



# 哈希函数的设计

此处只讨论最一般情况下哈希函数的设计，**重点关注大整型数据的取素数模方法**

最常见的情况应该是键值为整数的情况。

* 当键值为正整数且范围比较小的时候，可以直接把键值作为数组的下标
* 当键值为负整数且范围比较小的时候，可以偏移成正数
* 但当键值的范围比较大，通常选择取模作为哈希函数，此处重点讲这个

取模不是乱取，要能够用到大整数足够多的信息，才能让取模将索引分布的比较均匀

比如假设的一个身份证号：110108198512146661，我们都知道19851214是表示出生日期的，那么显然12对应的两位只能在1-12内，14对应的两位只能在01-30，如果简单的对一个数取模，比如对100000取模，那就是后六位146661，这其实并没有充分利用大整数的信息，当然对于这种复杂的特定应用场景，取模也有复杂的取法。此处只是举个例子说明

数论知识能够证明，一个简单但好用的取模方法：模一个素数。比如下面

10%4=2       10%7=3

20%4=0       20%7=6

30%4=2       30%7=2

40%4=0       40%7=4

50%4=2       50%7=1

**能够发现模一个素数，能够让索引分布的比较均匀**

对于不同范围内的大整数，模什么素数效果最好，见 [网站]([good hash table primes (planetmath.org)](https://planetmath.org/goodhashtableprimes))



其他的数据类型，比如浮点型、字符串型、自定义的对象类型等都可以转为整型来设计哈希函数，当然也不是唯一的方法。

* 浮点型：浮点型在计算机中也是32位或64位的二进制表示，只不过计算机解析成了浮点数，因此直接转为整型处理即可

* 字符串：字符串也是转成整型处理，如何转是一个问题，其实对于各种数据类型，转换都可以使用进制加法

    166 = 1 * 10 ^2 + 6 * 10 ^1 + 6 * 10 ^0

    code = c * 26 ^3 + o * 26 ^2 + d * 26 ^1 + e * 26 ^0   将字符串转为26进制相加（前提都是小写字母）

    code = c * B ^3 + o * B ^2 + d * B ^1 + e * B ^0           将字符串转为B进制相加

    这样就将字符串转为了整数，那么就有：

    hash(code) =  (c * B ^3 + o * B ^2 + d * B ^1 + e * B ^0 ) % M    

    可以进一步写成：

    hash(code) = ( ( ( ( c * B ) + o) * B + d) * B + e ) % M

    hash(code) = ( ( ( (  c % M ) * B  + o ) % M * B + d) % M * B + e ) % M

    这样就可以用代码写出

    ```Java
    int hash = 0;
    for(int i=0; i<s.length(); i++){
        hash = (hash * B + s.charAt(i)) % M;
    }
    ```

* 自定义对象Date：year, month, day

    hash(date) = ( ( (  date.year % M ) * B  + date.month ) % M * B + date.day) % M



总之，哈希函数设计的原则：

* 一致性：如果a==b，则 hash(a) == hash(b)
* 高效性：计算高效简便
* 均匀性：哈希值均匀分布



# 哈希冲突的处理：链地址法

也称拉链法

哈希冲突时，即有多个数据通过哈希算法计算出来的索引相同时，以**链表**的形式，放置在原来元素的后面。不过也可以用其他的数据结构形式，比如放树

java8之前，每一个位置对应一个链表

Java8之后，当哈希冲突达到一定程度时，每一个位置从链表转成红黑树（数据量小的时候，链表更高效，数据量大的时候，红黑树效率高）

































