# 二分查找法

## 一、概念及其介绍

二分查找是一种在**有序数组**中查找某一特定元素的搜索算法。



## 二、算法性能

二分查找法只针对有序数组，查找次数为1+1+1+...+1，最多有logn的长度，所以复杂度为O(logn)

排序是二分查找法的前置条件，不将排序时间算在二分查找的时间复杂度里，但想运行二分查找确实需要考虑排序的时间。虽然排序是前置条件，比较耗时，但当多次查找时，仍然具有较低的复杂度。比如查找n次，排序只用1次，时间为nlogn，每次查找为logn，n次查找就是nlogn，合起来就是2nlogn，均摊复杂度就是2nlogn/n = 2logn，仍然是logn级别。

所以面对无序数组，多次查找仍然具有较低的时间复杂度，否则不排序每次都用线性查找，将是O(n^2)的复杂度



## 三、实例代码

### 0. 二分查找框架

```java
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```



### 1. 寻找一个数（基本的二分搜索）

 在`nums[l,r]`中查找

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1;  // 注意

    //循环不变量是在nums[l,r]中查找target
    while(left <= right) {        // 注意，<=时区间都不为空
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

 在`nums[l,r)`中查找

```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length;  // 注意，由于右边是开区间，所以要让r大一个

    //循环不变量是在nums[l,r)中查找target
    while(left < right) {     // 注意，由于右边是开区间，l=r已经为空，不能取=
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意，右区间是不变的
        else if (nums[mid] > target)
            right = mid;    // 注意，此时是要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid
    }
    return -1;
}
```























