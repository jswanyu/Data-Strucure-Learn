# 二分查找法

## 一、概念及其介绍

二分查找是一种在**有序数组**中查找某一特定元素的搜索算法。



## 二、算法性能

二分查找法只针对有序数组，查找次数为1+1+1+...+1，最多有logn的长度，所以复杂度为O(logn)

排序是二分查找法的前置条件，不将排序时间算在二分查找的时间复杂度里，但想运行二分查找确实需要考虑排序的时间。虽然排序是前置条件，比较耗时，但当多次查找时，仍然具有较低的复杂度。比如查找n次，排序只用1次，时间为nlogn，每次查找为logn，n次查找就是nlogn，合起来就是2nlogn，均摊复杂度就是2nlogn/n = 2logn，仍然是logn级别。

所以面对无序数组，多次查找仍然具有较低的时间复杂度，否则不排序每次都用线性查找，将是O(n^2)的复杂度



## 三、实例代码

### 0. 二分查找框架

```java
int binarySearch(int[] nums, int target) {
    int l = 0, r = ...;

    while(...) {
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            l = ...
        } else if (nums[mid] > target) {
            r = ...
        }
    }
    return ...;
}
```



### 1. 寻找一个数

这是一个能很好理解循环不变量这一概念的例子，循环不变量分别是在`nums[l,r]`中查找和在`nums[l,r)`中查找。前者很好理解，是最基本的二分查找模型。代码如下：

循环不变量： 在`nums[l,r]`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length - 1;  // 注意

    //循环不变量是在nums[l,r]中查找target
    while(l <= r) {        // 注意，<=时区间都不为空
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意
        else if (nums[mid] > target)
            r = mid - 1; // 注意
    }
    return -1;
}
```

而当循环不变量变为在`nums[l,r)`中查找时，右区间的开闭影响了：`r` 的初始值、循环条件、查找边界 `r` 的移动规则。之所以会在这三个地方有差别， 最主要的原因就是因为 `r` 的定义。右区间开的时候， `r` 所代表的位置实际上是要查找的数组的**最后一个元素的后一个元素**，是 **不被** 包括在循环以内的。正因如此，这三个地方应该改为：

* `r` 的初始值改为`nums.length`，因为仍然希望遍历数组中所有元素，但因为右边是开的，所以要让r指向右边界的下一个位置，例如数组{1,2,3,4} 可写为[1,4]，也可写成[1,5)，但如果是[1,4)，则只能代表前三个元素。
* 循环条件应该改为`while(l < r)`，因为当l=r时，区间[l,r)是空区间，已经可以作为循环结束的条件了。
* 边界 `r` 的移动规则应改为`r = mid`，而不是之前的`r = mid-1`，因为当mid位置的元素大于target时，确定区间缩短为左半区，右边界确实应该为mid-1，但mid-1这个位置的值是要被索引到的，[l,mid-1)这样的区间是不能索引到mid-1位置的元素的，所以要和r的初始值一样，向右移动一位，即`r = mid`。

**循环不变量的意义也在此体现**，既然最开始就是左闭右开，那么后面每次循环都得是左闭右开，不能突然变成左闭右闭。每次循环中 l 和 r 共同约束了本次查找的范围， 要让本次循环与上一次循环查找的范围既不重复(重复了会引起死循环)， 也不遗漏， 并且要让 l 和 r 共同约束的查找的范围变得无意义时不再进行查找（即跳出 while）(否则会导致访问越界)

循环不变量：  在`nums[l,r)`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length;  // 注意，由于右边是开区间，所以要让r大一个

    //循环不变量是在nums[l,r)中查找target
    while(l < r) {     // 注意，由于右边是开区间，l=r已经为空，不能取=
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意，左区间是不变的
        else if (nums[mid] > target)
            r = mid;    // 注意，此时是要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid
    }
    return -1;
}
```



### 2. 寻找左侧边界

在`nums[l,r)`中查找target目标值的左侧边界，没有则返回-1

```java
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int l = 0;
    int r = nums.length;     // 注意，右边为开区间，右边界为索引下一位
    
    while (l < r) {          // 注意，右边为开区间，停止条件是l=r，这样[l,r)为空，可以正确中止
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            r = mid;         // 注意，寻找左边界的要点，不断更新右边界，向左收缩，直至左右相等
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid; // 注意
        }
    }
    // target 比所有数都大
	if (left == nums.length) return -1;
    // 类似之前算法的处理方式
	return nums[left] == target ? left : -1;
}
```

在`nums[l,r]`中查找target目标值的左侧边界，没有则返回-1

```java
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```



### 3. 寻找右侧边界

在`nums[l,r)`中查找target目标值的右侧边界，没有则返回-1

```java
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1;     // 注意,增大搜索区间的下界,向右收缩
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;        
        }
    }
    if (left == 0) return -1;
	return nums[right-1] == target ? (right-1) : -1;
}
```

在`nums[l,r]`中查找target目标值的右侧边界，没有则返回-1

```java
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```









