# 二分查找法

## 一、概念及其介绍

二分查找是一种在**有序数组**中查找某一特定元素的搜索算法。



## 二、算法性能

二分查找法只针对有序数组，查找次数为1+1+1+...+1，最多有logn的长度，所以复杂度为O(logn)

排序是二分查找法的前置条件，不将排序时间算在二分查找的时间复杂度里，但想运行二分查找确实需要考虑排序的时间。虽然排序是前置条件，比较耗时，但当多次查找时，仍然具有较低的复杂度。比如查找n次，排序只用1次，时间为nlogn，每次查找为logn，n次查找就是nlogn，合起来就是2nlogn，均摊复杂度就是2nlogn/n = 2logn，仍然是logn级别。

所以面对无序数组，多次查找仍然具有较低的时间复杂度，否则不排序每次都用线性查找，将是O(n^2)的复杂度



## 三、实例代码

### 1. 寻找一个数

寻找一个数需要数组中无重复元素，否则极限情况下数组中都是目标数，那第一次就找到了。这种寻找一个数一般都默认数组中无重复元素，否则就是寻找边界问题。

这是一个能很好理解循环不变量这一概念的例子，循环不变量分别是在`nums[l,r]`中查找和在`nums[l,r)`中查找。前者很好理解，是最基本的二分查找模型。代码如下：

循环不变量： 在`nums[l,r]`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length - 1;  // 注意

    //循环不变量是在nums[l,r]中查找target
    while(l <= r) {        // 注意，<=时区间都不为空
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意
        else if (nums[mid] > target)
            r = mid - 1; // 注意
    }
    return -1;
}
```

而当循环不变量变为在`nums[l,r)`中查找时，右区间的开闭影响了：`r` 的初始值、循环条件、查找边界 `r` 的移动规则。之所以会在这三个地方有差别， 最主要的原因就是因为 `r` 的定义。右区间开的时候， `r` 所代表的位置实际上是要查找的数组的**最后一个元素的后一个元素**，是 **不被** 包括在循环以内的。正因如此，这三个地方应该改为：

* `r` 的初始值改为`nums.length`，因为仍然希望遍历数组中所有元素，但因为右边是开的，所以要让r指向右边界的下一个位置，例如数组{1,2,3,4} 可写为[1,4]，也可写成[1,5)，但如果是[1,4)，则只能代表前三个元素。
* 循环条件应该改为`while(l < r)`，因为当l=r时，区间[l,r)是空区间，已经可以作为循环结束的条件了。
* 边界 `r` 的移动规则应改为`r = mid`，而不是之前的`r = mid-1`，因为当mid位置的元素大于target时，确定区间缩短为左半区，右边界确实应该为mid-1，但mid-1这个位置的值是要被索引到的，[l,mid-1)这样的区间是不能索引到mid-1位置的元素的，所以要和r的初始值一样，向右移动一位，即`r = mid`。

**循环不变量的意义也在此体现**，既然最开始就是左闭右开，那么后面每次循环都得是左闭右开，不能突然变成左闭右闭。每次循环中 l 和 r 共同约束了本次查找的范围， 要让本次循环与上一次循环查找的范围既不重复(重复了会引起死循环)， 也不遗漏， 并且要让 l 和 r 共同约束的查找的范围变得无意义时不再进行查找（即跳出 while）(否则会导致访问越界)

循环不变量：  在`nums[l,r)`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length;  // 注意，由于右边是开区间，所以要让r大一个

    //循环不变量是在nums[l,r)中查找target
    while(l < r) {     // 注意，由于右边是开区间，l=r已经为空，不能取=
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意，左区间是不变的
        else if (nums[mid] > target)
            r = mid;    // 注意，此时是要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid
    }
    return -1;
}
```



### 2. 寻找左侧边界

在`nums[l,r]`中查找target目标值的左侧边界，没有则返回-1。

需要注意的是，找到一个 target，然后向左或向右线性搜索是不行的，因为这样难以保证二分查找对数级的复杂度了，比如最坏情况全是某一元素，这就是O(n)复杂度了

- 还是原来的二分套路

- 当我们遇到目标值target时，向左进行偏移`right = mid - 1`

- 最后结束的时候，我们对left的值进行一下判断`left >= nums.length || nums[left] != target`，防止越界

    - `left >= nums.length`即target比数组中元素都大
    - `nums[left] != target`即target不比数组中元素都大，但并不在数组中

    ![image-20220122172457055](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2-%E8%B6%8A%E7%95%8C.png)

```java
public int LeftBound(int[] nums, int target){
    int l = 0;
    int r = nums.length -1;
    while (l <= r){
        int mid = l + (r-l)/2;
        if (nums[mid] == target)
            r = mid - 1;       // 注意，寻找左边界的要点，不断更新右边界，向左收缩
        else if (nums[mid] < target){
            l = mid + 1;
        }
        else if (nums[mid] > target){
            r = mid - 1;
        }
    }
    // 如果退出循环了，也就是left = right + 1
    // 判断下是否越界，l实际上最多也只会等于nums.length，>的判定是防御式编程
    if (l >= nums.length || nums[l] != target)
        return -1;
    return l;
}
```



### 3. 寻找右侧边界

在`nums[l,r]`中查找target目标值的右侧边界，没有则返回-1

- 还是原来的二分套路

- 当我们遇到目标值target时，向右进行偏移`left = mid + 1`

- 最后结束的时候，我们对right的值进行一下判断`right < 0 || nums[right] != target`，防止越界

    ![image-20220122190719199](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%8F%B3%E4%BE%A7%E8%BE%B9%E7%95%8C-%E8%B6%8A%E7%95%8C.png)

```java
public int RightBound(int[] nums, int target) {
    int l = 0;
    int r = nums.length - 1;
    while (l <= r) {    // 终止条件： l = r +1
        int mid = (r - l) / 2 + l;
        if (nums[mid] == target) {
            l = mid + 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid - 1;
        }
    }
    // 如果退出循环了，也就是left = right + 1
    // 判断下越界了不
    if (r < 0 || nums[r] != target) {
        return -1;
    }
    return r;
    /* 如果是用l来表示则为：
    * left <= 0 等价于 l-1 < 0 即 l < 1 
    if (left <= 0 || nums[left-1] != target)
    	return -1;
    return left - 1;
    */
}
```





### 4. 左闭右开区间

根据前面的分析，区间左闭右开只需改动三个地方

* 右边界定义`r = nums.length`
* 循环条件`while (l < r)`
* 左边界不动，右边界处理时`r = mid`

越界条件变不变暂时不清楚，下面这两段代码先验证完没问题再说，主要就是越界不清楚对不对，网上代码众说纷纭，最好能找个代码测一下



在`nums[l,r)`中查找target目标值的左侧边界，没有则返回-1

```java
int left_bound(int[] nums, int target) {
    int l = 0;
    int r = nums.length;     // 注意，右边为开区间，右边界为索引下一位
    
    while (l < r) {          // 注意，右边为开区间，停止条件是l=r，这样[l,r)为空，可以正确中止
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            r = mid;         
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid;         // 注意
        }
    }
	if (l >= nums.length || nums[l] != target) 
        return -1;
	return l;
}
```



在`nums[l,r)`中查找target目标值的右侧边界，没有则返回-1

```java
int right_bound(int[] nums, int target) {
    int left = 0
    int right = nums.length;
    
    while (l < r) {          // 停止条件是l=r
        int mid = (l + r) / 2;
        if (nums[mid] == target) {
            l = mid + 1;     // 注意,增大搜索区间的下界,向右收缩
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid;        
        }
    }
    // 这里不太肯定，等我找个题目验证下
    if (l == 0) return -1;
	return nums[r-1] == target ? (r-1) : -1;
}
```









