# 二分查找法

## 一、概念及其介绍

二分查找是一种在**有序数组**中查找某一特定元素的搜索算法。



## 二、算法性能

二分查找法只针对有序数组，查找次数为1+1+1+...+1，最多有logn的长度，所以复杂度为O(logn)

排序是二分查找法的前置条件，不将排序时间算在二分查找的时间复杂度里，但想运行二分查找确实需要考虑排序的时间。虽然排序是前置条件，比较耗时，但当多次查找时，仍然具有较低的复杂度。比如查找n次，排序只用1次，时间为nlogn，每次查找为logn，n次查找就是nlogn，合起来就是2nlogn，均摊复杂度就是2nlogn/n = 2logn，仍然是logn级别。

所以面对无序数组，多次查找仍然具有较低的时间复杂度，否则不排序每次都用线性查找，将是O(n^2)的复杂度



## 三、实例代码

### 0. 二分查找框架

```java
int binarySearch(int[] nums, int target) {
    int l = 0, r = ...;

    while(...) {
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            l = ...
        } else if (nums[mid] > target) {
            r = ...
        }
    }
    return ...;
}
```



### 1. 寻找一个数（基本的二分搜索）

这是一个能很好理解循环不变量这一概念的例子，分别是在`nums[l,r]`中查找和在`nums[l,r)`中查找。

右区间的开闭影响了**`r` 的初始值** ， **循环条件**， **以及查找边界 `r` 的移动规则**，之所以会在这三个地方有差别， 最主要的原因就是因为 `r` 的定义



 在`nums[l,r]`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length - 1;  // 注意

    //循环不变量是在nums[l,r]中查找target
    while(l <= r) {        // 注意，<=时区间都不为空
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意
        else if (nums[mid] > target)
            r = mid - 1; // 注意
    }
    return -1;
}
```

 在`nums[l,r)`中查找

```java
int binarySearch(int[] nums, int target) {
    int l = 0; 
    int r = nums.length;  // 注意，由于右边是开区间，所以要让r大一个

    //循环不变量是在nums[l,r)中查找target
    while(l < r) {     // 注意，由于右边是开区间，l=r已经为空，不能取=
        int mid = l + (r - l) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            l = mid + 1; // 注意，左区间是不变的
        else if (nums[mid] > target)
            r = mid;    // 注意，此时是要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid
    }
    return -1;
}
```



### 2. 寻找左侧边界

在`nums[l,r)`中查找>target的最小值索引

```java
int l_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int l = 0;
    int r = nums.length;     // 注意，右边为开区间，右边界为索引下一位
    
    while (l < r) {          // 注意，右边为开区间，停止条件是l=r，这样[l,r)为空，可以正确中止
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            r = mid;         // 注意，
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid; // 注意
        }
    }
    return l;
}
```



















