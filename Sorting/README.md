# 排序

排序方法进行比较时，如果可能，应该比较三种情况下的两种属性

情况：

* 最好情况（通常数据已排序）
* 最坏情况（数据按相反顺序排列）
* 平均情况（数据顺序是随机的）

属性：

* 比较次数
* 数据移动次数

有些排序方法无视数据的原始顺序，都执行相同的操作。这类算法的性能测量很简单，但其效果通常不是很好。有很多其他方法更灵活，它们在上述3种情况下的执行效果也不同。

数据的比较次数和移动次数并不是一定相同的。算法可能在数据比较上的效率比较高，而在数据移动上的效率很差，反之亦然。因此，在选择何种算法时一定要考虑实际情况。例如：

如果只比较简单的关键字，比如整数或字符，那么比较起来就相对快一些，比较的代价也不大。如果比较的是字符串或者数字数组，那么比较的代价就会显著提高，这时对比较效率的考量就很重要。另一方面，如果移动的数据项很大，例如结构，那么在考虑效率时，移动次数这一因素就会非常突出。所有理论上建立的度量方法都应当谨慎使用，而所有理论上的考虑都应根据实际应用再三权衡。毕竟,实际应用是理论决策的样板。

各种排序算法的复杂度是不同的。有时，简单的方法比复杂的方法只有20%的效率损失。如果在程序中只是偶尔用到排序，并且只是对很小的数据集进行排序，那么就没有太多必要使用复杂且效率较高的算法，同样的操作可以利用更简单的方法和代码来执行。但是如果有成千上万的数据项需要进行排序，那么20%的效率是不能忽视的。对于一些数量较少的数据来说，简单的算法通常比复杂的算法执行得更好，只有在数据集合很大时，复杂算法的效率优势才能明显体现出来。



## 时间复杂度为O(n^2)的算法

时间复杂度为O(n^2)的算法一般也是基本的排序算法，具有有以下特点：

* 编码简单，易于实现，是一些简单情景的首选

* 在一些特殊情况下，简单的排序算法更有效

* 简单的排序算法思想衍生出复杂的排序算法

* 作为子过程，改进更复杂的算法

常见的有：

* 插入排序
* 选择排序
* 冒泡排序
* 梳排序



## 时间复杂度为O(n)的算法

