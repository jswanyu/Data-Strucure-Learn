# 平衡二叉树

平衡二叉树，全称平衡二叉搜索树，又被称为AVL（Adelson-Velsky and Landis，发明人的姓名相关）树，即他依然是一棵二叉搜索树，只不过多了平衡的性质。

学习本小节之前，请务必复习掌握二叉搜索树的知识，否则代码看起来会很吃力

为什么要多平衡的性质，因为有序数据在二叉搜索树上可以退化为O(n)的链表。

![image-20220427123633151](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5.png)



## AVL树的性质

平衡二叉树具有以下性质：

1. 可以是空树。
2. 假如不是空树，对于任意一个节点，左子树和右子树的高度差不能超过1

> 平衡二叉树的要求其实比完全二叉树要宽松一些，因为完全二叉树只能叶子节点没填满，其它必须满，那自然也符合平衡二叉树的定义，平衡二叉树只要左右子树高度差绝对值不超过1即可
>
> 另外从平衡二叉树的定义也能得出：平衡二叉树的高度和节点数量之间的关系也是O(logn)的

例如下图不是平衡二叉树，因为结点 60 的左子树不是平衡二叉树。

![img](https://pic1.zhimg.com/80/v2-e090a8e3171c8db07e1cda720039e700_720w.jpg)

下图因为虽然任何一个结点的左子树与右子树都是平衡二叉树，但66这个根节点来说，左子树高度为3，右子树高度为1，高度之差已经超过 1 。

<img src="https://pic3.zhimg.com/80/v2-7b3cbb7cf1d996c072516b7146144e52_720w.jpg" alt="img" style="zoom: 33%;" />

下图看起来树有点歪歪扭扭的，但它符合平衡二叉树的定义

![image-20220816213921147](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E6%AD%A3%E7%A1%AEAVL%E6%A0%91%E4%B8%BE%E4%BE%8B.png)



## 平衡因子

**定义：**某节点的左子树与右子树的高度（深度）差即为该节点的平衡因子（BF，Balance Factor）

平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。

下图中黑色数字为每个节点的高度，蓝色数字为平衡因子，显然，节点12和8都不满足平衡因子为0，1，-1，所以它不是一棵平衡二叉树

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90.png" alt="image-20220523143045947" style="zoom:80%;" />



如何实现一棵AVL树，可以基于前一节二分搜索树的代码，AVL树只是特殊的二分搜索树

与二分搜索树的不同主要在于

1. Node节点添加了一个 public int height; 属性，用于计算左右子树的高度差。
2. 用key-value结构代替了原来只有value，其实只用一个value也行，用上键值对之后能做的事情更多，比如作为map的底层
3. 添加了一个计算平衡因子的方法

其他的方法暂时和二分搜索树的代码相同

```Java
public class AVLTree<K extends Comparable<K>, V> {
    private class Node{
        public K key;
        public V value;
        public Node left, right;
        public int height;  // 使用height表示节点的高度
        public Node(K key, V value){
            this.key = key;
            this.value = value;
            left = null;
            right = null;
            height = 1;
        }
    }
    
    private Node root;
    private int size;

    public AVLTree(){
        root = null;
        size = 0;
    }

    public int getSize(){
        return size;
    }

    public boolean isEmpty(){
        return size == 0;
    }
    
    // 获取节点高度
    private int getHeight(Node node){
        if(node == null)
            return 0;
        return node.height;
    }
    
    // 获取节点node的平衡因子
    private int getBalanceFactor(Node node){
        if(node == null)
            return 0;
        // 左子树高度减去右子树高度
        return getHeight(node.left) - getHeight(node.right);
    }
    
    // 添加元素
    private Node add(Node node, K key, V value){
        if(node == null){
            size ++;
            return new Node(key, value);
        }

        if(key.compareTo(node.key) < 0)
            node.left = add(node.left, key, value);
        else if(key.compareTo(node.key) > 0)
            node.right = add(node.right, key, value);
        else
            node.value = value;

        // 节点的高度是左右子树最大高度加1
        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));

        // 计算平衡因子
        int balanceFactor = getBalanceFactor(node);

        // 不平衡，暂时是不做处理
        if (Math.abs(balanceFactor) > 1){
            ...
        }
}
```



## 添加节点：右旋和左旋

上述代码添加节点时，仍然是二分搜索树的内容，多了一步计算平衡因子，当插入新节点时，部分节点的高度会发生改变，会出现树的平衡性被破坏的情况，即getBalanceFactor(node)的绝对值有可能大于1。这时候就应该对树进行调整，保证getBalanceFactor(node)的绝对值小于等于1

根据插入元素的位置不同，可以分为四种情况：LL RR LR RL

### LL

如下图所示，左图是一棵AVL树，右图显示新插入的元素2是在不平衡节点8左侧的左侧

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE2.png"  height=400>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE3.png" height=400>
</div>

举一个更简单的例子就是下面的情况，新插入的5在12左侧的左侧

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE4.png"  height=300>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE5.png" height=300>
</div>

上面的例子可以抽象为下面的结构（可以不管叶子节点，即图中的T1、T2、T3、T4），按照二分搜索树的定义，T1 < z < T2 < x < T3 < y < T4，但按照AVL树的定义，它显然不平衡，怎么样能让他维护平衡呢？ 

回答是进行**右旋**操作，让x作为根，把y作为x的右节点，同时把T3作为y的左节点。这样操作完之后，他仍然是二分搜索树，并且满足了AVL树的规定

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E6%A0%91%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  height=350>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%8F%B3%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" height=350>
</div>

代码实现上，我们定义方法 rightRotate，右旋 y节点为根的树，操作步骤和上述一样，但要添加一步更新高度

```Java
private Node rightRotate(Node y){
    Node x = y.left;
    Node T3 = x.right;

    x.right = y;
    y.left = T3;

    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;

    return x;
}
```



### RR

**左旋**的逻辑和代码和右旋完全对称

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%B7%A6%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  height=330>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-%E5%B7%A6%E6%97%8B%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" height=330>
</div>

代码：

```Java
// 左旋
private Node leftRotate(Node y){
    Node x = y.right;
    Node T3 = x.left;

    x.left = y;
    y.right = T3;

    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;

    return x;
}
```

相对应的，我们把添加元素的方法 add 补充完整，之前对于平衡因子>1的情况我们是空着的

```Java
// 添加元素
private Node add(Node node, K key, V value){
    // ...
    
    // 不平衡，暂时是不做处理
    if (Math.abs(balanceFactor) > 1){
        ...
    }
}
```

更改为左旋和右旋的两种情况判断，注意 getBalanceFactor 方法中是用左子树高度-右子树高度，所以右旋转时是平衡因子>1，左旋转时是平衡因子<-1

```Java
// 添加元素
private Node add(Node node, K key, V value){
    // ...
    
    // 计算平衡因子
    int balanceFactor = getBalanceFactor(node);

    // LL，右旋转
    if (balanceFactor > 1 && getBalanceFactor(node.left) >= 0)
        return rightRotate(node);

    // RR，左旋转
    if (balanceFactor < -1 && getBalanceFactor(node.right) <= 0)
        return leftRotate(node);
}
```



### LR

当插入的元素在不平衡节点左侧的右侧时，就不和上面完全一样了，但处理逻辑类似。首先如下图举例

![image-20220822001523435](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-LR%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

对于上面这种情况，该如何维护AVL树的平衡？回答是可以先将不平衡节点左子树左旋，就转成了LL的情况，随后再右旋。如下图用抽象结构来描述，注意T1 < x < T2 < z <T3

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-LR%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"  height=400>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-LR%E7%A4%BA%E6%84%8F%E5%9B%BE2.png" height=400>
</div>

代码

```Java
// LR
// 左子树高于右子树，并且左子树的平衡因子<0，表明左子树的左子树高度小于左子树的右子树高度
if (balanceFactor > 1 && getBalanceFactor(node.left) < 0){  
    node.left = leftRotate(node.left); // 对左节点左旋完再赋给左节点
    return rightRotate(node);          // 右旋根节点
}
```



### RL

RL也是同理，先右旋右子树，再左旋

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-RL%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  height=400>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/DataStructure%20and%20Algorithm/AVL%E6%A0%91-RL%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" height=400>
</div>

```Java
// RL
if (balanceFactor < -1 && getBalanceFactor(node.right) > 0) {
    node.right = rightRotate(node.right);
    return leftRotate(node);
}
```



综上所述，添加节点的方法为：

```Java
private Node add(Node node, K key, V value){
    if(node == null){
        size ++;
        return new Node(key, value);
    }

    if(key.compareTo(node.key) < 0)
        node.left = add(node.left, key, value);
    else if(key.compareTo(node.key) > 0)
        node.right = add(node.right, key, value);
    else
        node.value = value;

    // 节点的高度是左右子树最大高度加1
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));

    // 计算平衡因子
    int balanceFactor = getBalanceFactor(node);

    // LL，右旋转
    if (balanceFactor > 1 && getBalanceFactor(node.left) >= 0)
        return rightRotate(node);

    // RR，左旋转
    if (balanceFactor < -1 && getBalanceFactor(node.right) <= 0)
        return leftRotate(node);

    // LR，先左旋左子树，再右旋
    if (balanceFactor > 1 && getBalanceFactor(node.left) < 0){
        node.left = leftRotate(node.left);
        return rightRotate(node);
    }

    // RL，先右旋右子树，再左旋
    if (balanceFactor < -1 && getBalanceFactor(node.right) > 0) {
        node.right = rightRotate(node.right);
        return leftRotate(node);
    }

    return node;
}
```



## 删除节点

删除节点时，同样可能破坏AVL树的平衡性。但是维护起来其实和添加节点时一致，还是那四种情况，所以可以直接复用过来。看下面的代码之前先复习二分搜索树删除是怎么删除的，注释里写了很多细节

```Java
    private Node remove(Node node, K key){
        if( node == null )
            return null;

        Node retNode;
        if( key.compareTo(node.key) < 0 ){
            node.left = remove(node.left , key);
            // 相比于二分搜索树的代码，那里是直接返回node，此处就不行了，因为删除节点后，平衡性被破坏，不能这么早的把node就返回了
            // 这里需要对node进行维护，后面还要修改node的高度值，所以这里新建了一个 retNode，把node赋给它，后续对retNode进行维护
            retNode = node;
        }
        else if(key.compareTo(node.key) > 0 ){
            node.right = remove(node.right, key);
            retNode = node;
        } else{   // key.compareTo(node.key) == 0
            // 注意这里对比二分搜索树，二分搜索树是进一个if直接return了，这里没有return，因为要把node给 retNode，所以if-if要改成if-else if-else
            if(node.left == null){  // 待删除节点左子树为空
                Node rightNode = node.right;
                node.right = null;
                size --;
                retNode = rightNode;
            } else if(node.right == null){ // 待删除节点右子树为空
                Node leftNode = node.left;
                node.left = null;
                size --;
                retNode = leftNode;
            } else{ // 待删除节点左右子树都不为空
                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点，用这个节点顶替待删除节点的位置
                Node successor = minimum(node.right);
                // 二分搜索树中，这里是去找右子树的最小值，用的是removeMin方法，但在这里就不行了，因为removeMin里没有维护平衡性的代码
                // 毕竟只要删除就可能破坏平衡型，所以这里直接递归调用 remove，毕竟右子树的最小节点已经找到了，就是successor
                successor.right = remove(node.right, successor.key);
                successor.left = node.left;
                node.left = node.right = null;
                retNode = successor;
            }
        }

        if(retNode == null)
            return null;

        // 更新height
        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));

        // 计算平衡因子
        int balanceFactor = getBalanceFactor(retNode);

        // 维护树的平衡性
        // LL
        if (balanceFactor > 1 && getBalanceFactor(retNode.left) >= 0)
            return rightRotate(retNode);

        // RR
        if (balanceFactor < -1 && getBalanceFactor(retNode.right) <= 0)
            return leftRotate(retNode);

        // LR
        if (balanceFactor > 1 && getBalanceFactor(retNode.left) < 0) {
            retNode.left = leftRotate(retNode.left);
            return rightRotate(retNode);
        }

        // RL
        if (balanceFactor < -1 && getBalanceFactor(retNode.right) > 0) {
            retNode.right = rightRotate(retNode.right);
            return leftRotate(retNode);
        }

        return retNode;
    }
```



## AVL树的时间复杂度

不同于二分搜索树可能退化为O(n)的链表，AVL树肯定能保持平衡，其添加、查找、删除操作平均时间复杂度均为 O(logn)



## AVL树的优化

在维护平衡之前，每次都对当前节点的高度进行计算，其实如果计算后和原来的高度一样，它的父节点就不用维护平衡了，很简单的道理，子树的高度没变，对于父节点为根的这棵树来说，就不会打破平衡



## AVL树的局限性

平均性能下，还有一种平衡二叉树比AVL树性能更好，就是大名鼎鼎的红黑树，相对普通的AVL树来说，它的旋转操作更少，性能更优，后续继续学习

