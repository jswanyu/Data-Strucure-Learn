# 二叉树

二叉树是最常用的树结构，它和链表相同，是动态的数据结构

```java
class Node{
	E e;
    Node left;
    Node right;
}
```

二叉树具有唯一根节点，左节点被称为“左孩子”，右节点被称为“右孩子”。

二叉树每个节点最多有两个孩子，最多有一个父亲节点，没有孩子的节点被称为“叶子节点”。二叉树不一定是“满”的，例如：一个节点也可以看为是一个二叉树

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20220208115356506" style="zoom:80%;" />

二叉树具有天然的递归结构（链表也有天然的递归结构，但由于是线性的，可以用循环解决）而二叉树用递归可以更好的解决问题。因为每个节点的左子树也是二叉树，右子树也是二叉树



## 满二叉树

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树

图中这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20220322160521486" style="zoom:67%;" />





## 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。即空的总在右下方

若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20220322160811781" style="zoom:80%;" />





# 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历

## 深度优先遍历

深度优先遍历根据遍历的方式不同，又分为前序遍历、中序遍历、后序遍历

### 递归实现

递归是实现遍历的经典方法，其代码结构模板如下，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，

如果是一棵1  2-3  4-5-6-7 的二叉树，即

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

```Java
public void f(Node head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序



前序遍历： 每个节点都按照“头--左--右”的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做

如果是一棵1  2-3  4-5-6-7 的二叉树，顺序则是 1 2 4 5 3 6 7

```Java
public void preOrder(Node head){
    if (head == null) return;;

    System.out.println(head.e);
    preOrder(head.left);
    preOrder(head.right);
}
```



中序遍历：每个节点都按照“左--头--右”的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做

如果是一棵1  2-3  4-5-6-7 的二叉树，顺序则是 4 2 5 1 6 3 7 

```Java
public void preOrder(Node head){
    if (head == null) return;;

    preOrder(head.left);
    System.out.println(head.e);
    preOrder(head.right);
}
```



后序遍历：每个节点都按照“左--右--头”的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做

如果是一棵1  2-3  4-5-6-7 的二叉树，顺序则是 4 5 2  6 7 3 1

```Java
public void preOrder(Node head){
    if (head == null) return;;

    preOrder(head.left);
    preOrder(head.right);
    System.out.println(head.e);
}
```



### 非递归实现

非递归实现也很简单，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。



前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

```Java
public void preOrderUnRecur(Node head){
    System.out.println("pre-order:");
    if (head != null){
        Stack<Node> stack = new Stack<>();
        stack.push(head);
        while (!stack.isEmpty()){
            head = stack.pop();
            System.out.println(head.e + " ");
            if (head.right != null)
                stack.push(head.right);
            if (head.left != null)
                stack.push(head.left);
        }
    }
}
```



后序遍历

后序遍历实现起来需要 前序遍历 + 一个收集栈

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素放到收集栈中
* 如果弹出的这个元素有子节点，**先放左节点，再放右节点**（注意这里与真正的前序不同，那是左右，所以是先放右节点，再放左节点，所以这里实际上顺序是 头右左）
* 把收集栈依次弹出，就是后序遍历（相当于就是把上一步伪前序的头右左 反过来变成 左右头，达成后序遍历）

```Java
public static void posOrderUnRecur1(Node head) {
    System.out.print("pos-order: ");
    if (head != null) {
        Stack<Node> s1 = new Stack<Node>();
        Stack<Node> s2 = new Stack<Node>();
        s1.push(head);
        while (!s1.isEmpty()) {
            head = s1.pop();
            s2.push(head);
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s1.push(head.right);
            }
        }
        while (!s2.isEmpty()) {
            System.out.print(s2.pop().value + " ");
        }
    }
    System.out.println();
}
```

不用收集栈也可以实现



中序遍历

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

```Java
public static void inOrderUnRecur(Node head) {
    System.out.print("in-order: ");
    if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        while (!stack.isEmpty() || head != null) {
            // 不断地将左边界进栈
            if (head != null) {
                stack.push(head);
                head = head.left;
            } else {
                head = stack.pop();  // 弹出栈顶元素
                System.out.print(head.value + " ");
                head = head.right;   // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
    }
    System.out.println();
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />

## 广度优先遍历











