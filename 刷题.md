

部分参考资料：

* labuladong算法小抄
* liweiwei 算法吧
* 代码随想录
* 鲂的力扣秋招算法总结：[分享｜2021秋招算法总结1-DFS篇 - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/VFVW01/)
* 李rumor@数据结构与算法笔记





tips

* 明确变量的含义、抓住循环不变量、小数据量调试、大数据量调试

* length——数组的属性；length()——String的方法；size()——集合的方法；第二和第三底层都是数组的length属性。注意集合一般只有size()

* 字符转为整型，只需要减去'0'。'2' 转为 整型2 只需要 '2'-'0' 即可

* Integer.parseInt() 查一下具体用法，常用于字符整数转为整型

* String.join() 查一下具体用法  字符串拼接很好用

* 回溯问题中各个集合类型的addLast和removeLast要熟练掌握

* 字符串比较不用==，而是用equals

* 唯一可以直接在类内部的代码是声明和静态初始值设定项。常用的数组填充方法`Arrays.fill()`必须用在代码块中。类定义完初始化数组可以，但不能理解调用`Arrays.fill()`

    ```Java
    class Solution {
        int[] memo = new int[n+1];
        Arrays.fill(memo,-1); //no!!!
    }
    ```

* 交换a和b，有两种方法：

    但注意`用异或来交换两个变量能提高速度`这个结论是错的，https://blog.csdn.net/solstice/article/details/5166912
    
    ```Java
    // 法一：
    int temp = a;
    a = b
    b = temp;
    
    // 法二：
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    ```
    
    



# ACM模式

## 常用方法

Java 输入输出的几个常用方法

| 创建 Scanner 对象  | Scanner in = new Scanner(System.in);                         |                                                              |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| next()             | 读取空格之前的字符串，读取完后光标放在数据后空格前。下次读取时会自动跳过空格 | 比如，"hello world"，第一次只能读取到hello，第二次才能读取到world |
| nextInt()          | 读取空格之前的整型，读取完后光标放在数据后空格前。下次读取时会自动跳过空格 |                                                              |
| nextLine()         | 读取整行的数据包括单词间的空格，读取完后光标放在下一行开头   |                                                              |
| hasNext()          | 判断输入里是否有字符串                                       |                                                              |
| hasNextInt()       | 判断输入里是否有整型                                         |                                                              |
| hasNextLine()      | 判断输入里是否有下一行                                       |                                                              |
| print              | 打印内容，输出光标定位在所显示的最后一个字符之后             | 小数点控制只有这个函数才可以，println 不行，比如print("%.2f",m) |
| println            | 打印内容，并在结尾加上换行符，将输出光标定位在下一行的开始   | println("%.2f",m)，这种写法是错的                            |
| Integer.parseInt() | 返回的是基本类型int                                          |                                                              |
| Integer.valueOf    | 返回的是包装类Integer                                        |                                                              |

其他数据类型也是类似的，如Short、Long、Float、Double等



## （1）空格分隔的两个正整数

输入包括两个正整数a，b(1 <= a, b <= 10^9)，输入数据包括多组。输出a+b的结果

```
输入
1 5
10 20

输出
6
30
```

Java

```Java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNextInt()){ //hasNextInt()判断输入的是否是整数，有就读取，没有就不读 
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(a+b);
        }
    }
}
```

注意 hasNextInt() 只能保证输入数字之间用空格或者回车分隔，如果是其他符号就退出循环了。另外如果ab的范围是0<*a*,*b*<2×10^10，就得定义成长整型Long

```Java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in = new  Scanner(System.in);
        while(in.hasNextLong()){
            Long a = in.nextLong();
            Long b = in.nextLong();
            System.out.println(a+b);
        }
    }
}
```

Python

```python
import sys
for i in sys.stdin:
    l = list(map(int,i.strip().split()))
    print(sum(l))
    
# int使其转换为整型，是map函数的第一个参数，
# .strip()用于移除字符串头尾指定的字符（默认为移除字符串头尾的空格或换行符）
# .split()默认以空格拆分，对字符串进行切片，经过这一步后变为一个列表
```

Cpp

```cpp
#include<iostream>
using namespace std;

int main(){
    int a,b;
    while(cin >> a >> b){
        cout << a+b << endl;
    }
    return 0;
}
```



## （2）第一行为组数 接空格分隔的两个正整数

输入第一行包括一个数据组数t(1 <= t <= 100)，接下来每行包括两个正整数a,b(1 <= a, b <= 1000)，输出a+b的结果。即除了第一行，一共有t行的数据，每行2个正整数

```
输入
2
1 5
10 20

输出
6
30
```

Java

```Java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int t = in.nextInt();
        for(int i=0; i<t; i++){
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(a + b);
        }
    }
}
```

Python

```python
# 可以根据第一个组数知道一共有多少输入，不像上一题不知道到底有多少输入，只能用stdin
n = int(input())
for i in range(n):
    line = list(map(int, input().strip().split()))
    print(sum(line)) 
```

Cpp

```cpp
#include<iostream>
using namespace std;

int main(){
    int n, a, b;
    cin >> n;
    for(int i=0; i<n; i++){
        cin >> a >> b;
        cout << a+b << endl;
    }
    return 0;
}
```



## （3）每行第一个为个数 按空格分割整数 为0结束

输入数据包括多组。每组数据一行，每行的第一个整数为整数的个数n(1 <= n <= 100), n为0的时候结束输入。接下来n个正整数,即需要求和的每个正整数。输出每组数据输出求和的结果

```
输入
4 1 2 3 4
5 1 2 3 4 5
0

输出
10
15
```

Java

```Java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNextInt()){
            int n = in.nextInt();      // 每一行先读第一个数确定n
            if(n==0) break;
            int sum = 0;
            for(int i=0; i<n; i++){    // 再for循环
                sum += in.nextInt();
            }
            System.out.println(sum);
        }
    }
}
```

Cpp

```cpp
#include<iostream>
using namespace std;

int main(){
    int n, a;
    while(cin >> n){
        if(n == 0) break;
        int sum = 0;
        for(int i=0; i<n; i++){
            cin >> a;
            sum += a;       
        }
        cout << sum << endl;
    }
    return 0;
}
```



## （4）多组空格分隔的正整数

输入数据有多组, 每行表示一组输入数据。每行不定有n个整数，空格隔开。(1 <= n <= 100)。输出每组数据输出求和的结果

```
输入
1 2 3
4 5
0 0 0 0 0

输出
6
9
0
```

Java

```Java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String[] s = in.nextLine().split(" ");
            int sum = 0;
            for (int i = 0; i < s.length; i++) {
                sum += Integer.parseInt(s[i]);
            }
            System.out.println(sum);
        }
    }
}
```

Cpp

```cpp
#include<iostream>
using namespace std;
int main(){
    int a,sum = 0;
    while(cin >> a){
        sum += a;
        if(cin.get() == '\n'){
            cout << sum << endl;
            sum = 0;
        }
    }
    return 0;
}
```



## （5）第一行为个数 第二行字符串

输入有两行，第一行n，第二行是n个字符串，字符串之间用空格隔开，输出一行排序后的字符串，空格隔开，无结尾空格

```
输入
5
c d a bb e

输出
a bb c d e
```

Java

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // int n = in.nextInt();  // 此行加不加都行，后续用不到n
        in.nextLine();  // 让光标到下一行
        while (in.hasNext()) { 
            String[] s = in.nextLine().split(" ");
            Arrays.sort(s);
            for (int i = 0; i < s.length; i++) {
                System.out.print(s[i] + " ");
            }
            
        }
    }
}
```

Cpp

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin >> n;
    string word;
    vector<string> res;
    for(int i=0; i<n; i++){
        cin >> word;
        res.push_back(word);
    }
    sort(res.begin(), res.end());
    for(string word : res){
        cout << word << " ";
    }
    return 0;
}
```

#include <bits/stdc++.h>是万能头文件，包含了大多数要用到的东西，能在竞赛中节约时间



## （6）多行空格分开的字符串

多个测试用例，每个测试用例一行。每行通过空格隔开，有n个字符，n＜100。对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开

```
输入
a c bb
f dddd
nowcoder

输出
a bb c
dddd f
nowcoder
```

Java

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) { 
            String[] s = in.nextLine().split(" ");
            Arrays.sort(s);
            for (int i = 0; i < s.length; i++) {
                System.out.print(s[i] + " ");
            }
            System.out.println();
        }
    }
}
```

Cpp

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    vector<string> res;
    while(cin >> s){
        res.push_back(s);
        if(cin.get() == '\n'){
            sort(res.begin(), res.end());
            for(string i : res){
                cout << i << ' ';
            }
            cout << endl;
            res.clear();
        }
    }
    return 0;
}
```





## （7）多行逗号分开的字符串

多个测试用例，每个测试用例一行。每行通过,隔开，有n个字符，n＜100。输出：对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格

输入

```
a,c,bb
f,dddd
nowcoder
```

输出

```
a,bb,c
dddd,f
nowcoder
```

代码

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) { 
            String[] s = in.nextLine().split(",");
            Arrays.sort(s);
            for (int i = 0; i < s.length-1; i++) {
                System.out.print(s[i] + ",");
            }
            System.out.print(s[s.length-1]);
            System.out.println();
            // 或者合并写为：System.out.println(s[s.length-1]);
        }
    }
}
```

Cpp

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    while(getline(cin, s)){
        stringstream res(s);
        string word;
        vector<string> words;
        while(getline(res, word, ',')){
            words.push_back(word);
        }
        sort(words.begin(), words.end());
        for(int i=0; i<words.size()-1; i++){
            cout << words[i] << ',';
        }
        cout << words.back() << endl;
    }
}
```

istream& getline(istream& is, string& str, char delim);  读取的istream是作为参数 is 传进函数的，将读取的字符串保存在string类型的str中。is : 表示一个输入流，例如cin。其中 str : 为string类型的引用，用来存储输入流中的流信息。delim ：为char类型的变量，截断字符。不定义的情况下，默认遇到 ‘\n'代表一行的输入结束。



# 数据结构

## 数组

数组很少单独考察，一般是作为其他知识点考察的载体

### 1. 数组常用方法

Java自带了一些数组的方法，需要记住以便有时候用到<font color=red>后续记录一下，在这写点代码</font>

| 方法                                                        | 功能                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| Arrays.sort(int[ ] a)                                       | 对一个数组的所有元素进行排序，并且是按从小到大的顺序。无返回值，直接对a进行排序。降序需要传入自定义的Comparator |
| Arrays.asList()                                             | 将一个数组转换为一个List集合。**传递的数组必须是对象数组，而不是基本类型。** |
| Arrays.toString(int[ ] a)                                   | 将数组a转换成String类型输出                                  |
| Arrays.copyOfRange(T[ ] a, int from, int to)                | 复制数组，左闭右开，生成一个新的数组                         |
| System.arraycopy(int[] a, int index1, int[] b, index2, len) | 把a数组从index1开始，长度为len的内容，复制到b数组的index2开始 |

所有数组做题为了规范化，首先要注意排除数组为空和长度为0的情况

```Java
if(nums == null || nums.length == 0)
```



### 2. List常用方法

add(Object element) 向列表的尾部添加指定的元素
size() 返回列表中的元素个数
get(int index) 返回列表中指定位置的元素，index从0开始
add(int index, Object element) 在列表的指定位置插入指定元素
set(int i, Object element) 将索引i位置元素替换为元素element并返回被替换的元素
clear() 从列表中移除所有元素
isEmpty() 判断列表是否包含元素，不包含元素则返回 true，否则返回false
iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器
contains(Object o) 如果列表包含指定的元素，则返回 true
remove(int index) 移除列表中指定位置的元素，并返回被删元素
remove(Object o) 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false



### 3. 数组和List的转换

（1）for循环：最朴素的做法，使用for循环遍历，所以记不得怎么转换了就用for循环



（2）数组转List：

方式一：使用Arrays.asList( )，但该方法的返回值是`java.util.Arrays`类中一个私有静态内部类`java.util. Arrays.ArrayList`，即它并不是java.util.ArrayList类。java.util.Arrays.ArrayList类具有set()，get()，contains()等方法，但是不支持添加add()或删除remove()方法,调用这些方法会报错。也就是说，此种方法残缺：重新得到的 list  不能 add( ) 或者 remove( );

```Java
// 因为list中是包装类。所以数组创建时也需要使用包装类
Integer[] num = new Integer[]{1,2,3,4,5,6,7,8,9};
List<Integer> res = Arrays.asList(num);
// 此时得到的list 不能 使用 add() 与 remove()方法；
// 解决办法：创建一个新的list 对象，将残缺的list加入进去
List<Integer> list = new ArrayList<>(res);
```

方式二：**Collections.addAll( );（此种方法最实用）**

直接创建一个新的 list 对象，然后使用**Collections.addAll( )** 方法。将数组添加进List中

```Java
Integer[] num = new Integer[]{1,2,3,4,5,6,7,8,9};
List<Integer> ans2 = new ArrayList<>();
Collections.addAll(ans2,num);
```

（3）List转数组：

对于下面的List

```java
List<Integer> list = new LinkedList<>();
list.add(1);
list.add(2);
list.add(3);
```

方式一：用list的`toArray()`方法，但只能转成Object[]

```Java
Object[] a = list.toArray();
```

方式二：toArray()方法中要传入指定类型的数组，并且只能是包装类型

```Java
Integer[] a = list.toArray(new Integer[list.size()]);
```



### 4. 二维数组

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  height=400>
</div>

```java
int[][] a = new int[3][2];
System.out.println(a.length);     // 3
System.out.println(a[0].length);  // 2
```

数组int[3] [2] 表示3行2列的二维数组，a.length表示有多少行，a[0].length表示有多少列









## 字符串

字符串与数组有很多相似之处，但字符串的基本操作对象通常是**字符串整体或者其子串**

刷题时需要记住字符串String常用的方法。切忌丢掉方法的括号！！！

String类的常用方法

| 方法                                            | 功能                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| int length()                                    | 返回字符串长度                                               |
| boolean **isEmpty**()                           | 判断是否是空字符串                                           |
| String substring(int begin, int end)            | 返回一个新字符串，它是此字符串从begin开始截取到end(不包含)的一个子字符串，还有一种重载是只有begin，那就从begin开始截取到最后。<font color=red>注意都是小写</font> |
| String **replace** (char oldChar, char newChar) | 将所有 oldChar 替换为 newChar ，将新的字符串返回             |
| String trim()                                   | 去除字符串两端空白                                           |
| toLowerCase()                                   | 将字符串转成小写字母                                         |
| toUpperCase()                                   | 将字符串转成大写字符                                         |
| indexOf()                                       | 返回指定字符的索引                                           |
| Character.isDigit(Char c)                       | 判断字符c是不是数字                                          |
| split(String regex, int limit)                  | 分割正则表达式，返回一个分割后的字符串数组。limit > 0 : 最多匹配limit-1次,得到一个长度为limit的数组；limit = 0 : 尽可能的多匹配, 且长度无限制, 但结尾空字符串将被丢弃；limit < 0 : 尽可能的多匹配, 且长度无限制。 `.` `$` `|` `*`等转义字符，必须得加 `\\` |
| char charAt()                                   | 返回指定索引处的字符                                         |
| char[] **toCharArray**()                        | 将字符串转换为字符数组                                       |

后两个方法经常用，毕竟 java中字符串的字符不能用索引直接访问，需要先转成数组再访问，或者使用 charAt



由于String的增加删除操作不方便，所以也要记忆StringBuffer/StringBuilder的常用方法：

| 方法                     | 功能                                   |
| ------------------------ | -------------------------------------- |
| toString()               | 将StringBuffer/StringBuilder转为String |
| StringBuffer append(xxx) | 字符串拼接                             |
|                          |                                        |







### 415. 字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

```
输入：num1 = "11", num2 = "123"
输出："134"

输入：num1 = "0", num2 = "0"
输出："0"
```



方法一：字符串遍历

下面这段代码值得学习，关于字符串加法、链表加法以及二进制加法之类的都可以这么写。

核心点：都是倒着读字符串，就像做加法一样，先从个位数开始读并相加，最后再反转字符串

精彩之处：

1. 只用了一个变量carry，利用+= /=等操作符保存临时结果，最终每一位上的结果就是carry%10
2. i--和 j-- 放到charAt的逻辑中，不用先charAt(i)，再i--，这个就还好，是++操作符的熟练使用
3. 最后剩余的进位，也放到while里去判断，而不是单独判断，用 if(i>=0)判断条件来区分到底是正常进位还是最后剩余的进位

```Java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder();
        int carry = 0, i = num1.length()-1, j = num2.length()-1;
        while(i>=0 || j>=0 || carry != 0){ // 注意是或的逻辑
            if(i>=0) carry += num1.charAt(i--)-'0';
            if(j>=0) carry += num2.charAt(j--)-'0';
            res.append(carry%10);
            carry /= 10;  
        }
        return res.reverse().toString();
    }
}
```

再贴一段未优化的代码，体会上面这段代码的精彩之处

```Java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder("");
        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;
        while(i >= 0 || j >= 0){
            int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;
            int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;
            int tmp = n1 + n2 + carry;
            carry = tmp / 10;
            res.append(tmp % 10);
            i--; j--;
        }
        if(carry == 1) res.append(1);
        return res.reverse().toString();
    }
}
```



### 8. 字符串转换整数 (atoi)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。函数 myAtoi(string s) 的算法如下：

* 读入字符串并丢弃无用的前导空格。
* 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
* 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
* 如果整数超过 32 位有符号整数范围 [−2^31^,  2^31^ − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31^ 的整数应该被固定为 −2^31^ ，大于 2^31^ − 1 的整数应该被固定为 2^31^ − 1 。返回整数作为最终结果。

注意：本题中的空白字符只包括空格字符 ' ' 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。（对于这个注意点，我觉得意思应该是如果数字前有字符，是不能忽略的，不能忽略的结果也就是直接输出0）

```
输入：s = "42"                输出：42
输入：s = "   -42"            输出：-42
输入：s = "4193 with words"   输出：4193
输入：s = "words 4193"        输出：0 (个人的理解)
```



**方法一：字符串**

本题是很常规的字符串题，难点在于整型溢出判断。根据题意，前导空格要舍弃，用while循环即可，字符的正负号可以用一个sign来记录，正号就赋为1，负号赋为-1，字符串转成数字 res = res * 10 + digit。溢出判断：在某一步 res * 10 + digit > Integer.MAX_VALUE，至于是 res *10 越界还是乘完了 + digit 后越界就不清楚了。

int范围是 [−2^31^,  2^31^ − 1]，不能等溢出了再判断，语法上不通过编译，所以可以逆序写成下面的格式防止溢出：

`res > (Integer.MAX_VALUE - digit) / 10`

注意：

整体代码为：

```java
class Solution {
    public int myAtoi(String s) {
        char[] array = s.toCharArray();
        int sign = 1, res = 0, index = 0, len = array.length;
        while(index < len && array[index] == ' '){
            index++;
        }
        if(index < len && (array[index]=='-' || array[index]=='+')){
            sign = array[index++] == '-' ? -1 : 1;
        }
        while(index < len && array[index]>='0' && array[index]<='9'){
            int digit = array[index++] - '0';
            if(res > (Integer.MAX_VALUE -digit)/10){
                // Integer.MAX_VALUE = 2^31 − 1，Integer.MIN_VALUE = −2^31
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }
            res = res*10 + digit;
        }
        return res*sign;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



### 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。`strs[i]` 仅由小写英文字母组成

```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
```



**方法一：字符串**

纵向扫描：令最长公共前缀 res 的值为第一个字符串，进行初始化。遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀。如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回

```Java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0) return "";
        String res = strs[0];  // 初始值为首位元素
        for(int i=1; i<strs.length; i++){
            int j=0;
            while(j<res.length() && j<strs[i].length() && res.charAt(j)==strs[i].charAt(j)){ // 挨着对比，注意要保证两个字符串都不越界
                j++;
            }
            // 更新res, substring 是左闭右开的，如果没有公共前缀，j=0，substring会返回空
            res = res.substring(0,j);  
        }
        return res;
    }
}
```



### 468. 验证IP地址

给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 "IPv4" ；如果是有效的 IPv6 地址，返回 "IPv6" ；如果不是上述类型的 IP 地址，返回 "Neither" 。

有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 <= x~i~ <= 255 且 x~i~ 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。

一个有效的IPv6地址 是一个格式为“x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中：

* 1 <= x~i~.length <= 4
* x~i~ 是一个十六进制字符串，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。
* 在 xi 中允许前导零。

例如 "2001:0db8:85a3:0000:0000:8a2e:0370:7334" 和 "2001:db8:85a3:0:0:8A2E:0370:7334" 是有效的 IPv6 地址，而 "2001:0db8:85a3::8A2E:037j:7334" 和 "02001:0db8:85a3:0000:0000:8a2e:0370:7334" 是无效的 IPv6 地址。

```
输入：queryIP = "172.16.254.1"
输出："IPv4"
解释：有效的 IPv4 地址，返回 "IPv4"

输入：queryIP = "2001:0db8:85a3:0:0:8A2E:0370:7334"
输出："IPv6"
解释：有效的 IPv6 地址，返回 "IPv6"

输入：queryIP = "256.256.256.256"
输出："Neither"
解释：既不是 IPv4 地址，又不是 IPv6 地址
```



**方法一：字符串**

检查IPV4的合法性： （1）字符串数组长度应该等于4； （2）字符串长度应该在1～3之间； （3）字符串如果不是0，不能以0开头； （4）不能含有数字以外的字符； （5）对应的数字不能超过255.

检查IPV6的合法性： （1）数组长度应该等于8； （2）字符串长度应该在1～4之间； （3）字符串只可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。

注意split()方法的使用，第二个参数要传入负数，因为我们希望尽可能多匹配, 且长度无限制，也不能丢弃某个字符。

这种题目也就只有反复写，注意细节

```Java
class Solution {
    public String validIPAddress(String queryIP) {
        if(isIPv4(queryIP)) return "IPv4";
        else if(isIPv6(queryIP)) return "IPv6";
        return "Neither";
    }

    public boolean isIPv4(String s){
        String t[] = s.split("\\.",-1);  // 以'.'分割字符串，转义字符要加上\\ ，且limit要<0
        if(t.length != 4) return false;  // 1.字符串数组长度应该等于4
        for(int i=0; i<4; i++){
            // 2.每个字符串长度只能为1、2、3
            // 3.如果字符串长度大于1，第一位不能是0
            if(t[i].length()==0 || t[i].length()>3 || (t[i].length()>1 && t[i].charAt(0)=='0')) return false;
            int sum=0;
            for(char c : t[i].toCharArray()){
                if(!(c>='0' && c<='9')) return false; // 4. 不能含有数字以外的字符
                sum = sum*10 + (c-'0');
            }
            if(sum > 255) return false;  // 5. 对应的数字不能超过255
        }
        return true;
    }

    public boolean isIPv6(String s){
        s = s.toLowerCase();
        String t[] = s.split(":",-1); // 先转为小写，并以':'分隔 ，且limit要<0
        if(t.length != 8) return false; // 1.数组长度应该等于8
        for(int i=0; i<8; i++){
            if(t[i].length() ==0 || t[i].length()>4) return false; // 2.字符串长度为1～4
            for(char c : t[i].toCharArray()){
                //3.字符只能是数字或者a~f
                if(!(c>='0' && c<='9') && !(c>='a' && c<='f')) return false; 
            }
        }
        return true;
    }
}
```





## 链表

### 链表题总结

**(1) 链表节点的定义与调试**

定义链表结点时，加上由数组构造方式，与打印内容，下面这段代码要背熟

```Java
class ListNode {
    public int val;
    public ListNode next;
    public ListNode() {}
    public ListNode(int val) { this.val = val; }
    public ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    //使用数组nums为参数，创建一个链表，当前的ListNode为链表头节点
    public ListNode(int[] nums) {
        this.val = nums[0];
        ListNode cur = this;
        for (int i = 1; i < nums.length; i++) {
            cur.next = new ListNode(nums[i]);
            cur = cur.next;
        }
    }
	// 以当前节点为头节点的链表的信息字符串
    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        ListNode cur = this;
        while (cur != null) {
            s.append(cur.val);
            s.append(" -> ");
            cur = cur.next;
        }
        s.append("NULL");
        return s.toString();
    }
}
```

测试主函数

```Java
public static void main(String[] args) {
    int[] arr = new int[]{1,2,3,4,5};
    ListNode head = new ListNode(arr);
    System.out.println(head);
}
```

```
输出：
1 -> 2 -> 3 -> 4 -> 5 -> NULL
```



**(2) 链表题技巧**

1. 链表操作的复杂度：普通单向链表增删改查各个操作的时间复杂度均为O(n)，只有对链表头节点操作才为O(1)

1. 舍得用指针变量，千万别想着节省变量，否则容易被逻辑绕晕

3. 虚拟头节点的使用

    * 如果要用到待操作节点的前一个节点，可以添加虚拟头节点，不用单独考虑头节点的特殊情况。切记虚拟头节点不是必须的，只是为了减少单独考虑头节点的代码，让所有逻辑统一起来。比如删除结点，如果是删除头节点，也很简单，让head = head.next，再返回head即可。不过这是单独的if判断

        一般题目都会传入head，那可以用下面这行代码创建虚拟头节点。也要注意有没有这样的构造函数

        ```Java
        ListNode dummyHead = new ListNode(-1,head);
        ```

    * 如果不用到待操作节点的前一个节点，就没有必要用虚拟头节点。比如同样是快慢指针， 876.链表中点就用不到前一个节点，没必要使用虚拟头节点，19题删除倒数第N个就用到，需要使用虚拟头节点

3. 一定要多画图，搞清楚链表指向，有多个指针的时候也要搞清楚哪个指针先保留，因为链表中经常出现你不保留，后面的操作就让next指向别的地方了，再想用next就不是指向原本我们希望的位置了。多画图，代码写完了自己画图逻辑上理一遍。画图时将旧的next指针擦掉，影响观感。

4. 和上一点类似，想强调的是我们经常需要迭代遍历链表中的节点，那么**需要有个节点保存好头节点**，尤其是涉及到拆分、合并链表等操作，一般建议单独定义指针cur去遍历，而不是让head去遍历，除非有虚拟头节点或者其他类似情况能够保存好头节点。比如328奇偶链表里，一定要有个节点保存偶链表的头节点



**(3) 题型总结分类**

| 题型               | 题目                                                         |
| ------------------ | ------------------------------------------------------------ |
| 反转链表           | [206. 反转链表](###206. 反转链表)、 [92. 反转链表Ⅱ](###92. 反转链表Ⅱ)、[24. 两两交换链表中的节点](###24. 两两交换链表中的节点)、[（重点）25. K个一组翻转链表](###25. K个一组翻转链表) |
| 链表中点、快慢指针 | [876. 链表的中间结点](###876. 链表的中间结点)、[19. 删除链表的倒数第N个结点](###19. 删除链表的倒数第N个结点) |
| 合并链表、链表排序 | [21. 合并两个有序链表](###21. 合并两个有序链表)、[23. 合并K个升序链表](###23. 合并K个升序链表)、[148. 排序链表](###148. 排序链表)、[86. 分隔链表](###86. 分隔链表) |
| 奇偶链表           | [328. 奇偶链表](###328. 奇偶链表)                            |
| 综合操作           | [NC207. 排序奇升偶降链表](###NC207. 排序奇升偶降链表)、[143. 重排链表](###143. 重排链表)、[234. 回文链表](###234. 回文链表) |
| 环形链表           | [141. 环形链表](###141. 环形链表)、[142. 环形链表Ⅱ](###142. 环形链表Ⅱ) |
| 迭代删除元素       | [83. 删除排序链表中的重复元素](###83. 删除排序链表中的重复元素)、[82. 删除排序链表中的重复元素Ⅱ](###82. 删除排序链表中的重复元素Ⅱ)、[203. 移除链表元素](### 203. 移除链表元素) |
| 特殊题型           | [146. LRU缓存](### 146. LRU缓存)、[160. 相交链表](###160. 相交链表)、[2. 两数相加](###2. 两数相加)、[138. 复制带随机指针的链表](###138. 复制带随机指针的链表) |



### 0206. 反转链表  492

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)



**方法一：迭代法/双指针法**

设立三个指针pre，cur，temp用来记录当前节点及周围信息。pre准备指向cur的前一个节点，temp准备指向cur的下一个节点。随后遍历链表，先用temp记录cur的下一个元素，以防丢失信息，再让cur的next指向pre，此时完成当前元素的反转，随后遍历下一个节点，让pre指向cur，再让cur指向之前记录的temp

```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        //单链表为空或只有一个节点，直接返回原单链表
        if (head == null || head.next == null) return head; 
        ListNode pre = null;
        ListNode cur = head;
        // 注意！下面这些话是完全多余并且会引发报错的，初始化时没用的节点都是指向null，后续的循环中会将其利用起来，不用在初始化的时候定义指向，而且null的next会报空指针异常
        // pre.next = cur;  
        // cur.next = temp;
        while (cur!=null){          
            ListNode temp = cur.next;
            cur.next = pre;  //反转，null<-1->2->3，这里有一次错写成 pre = cur.next，很离谱
            pre = cur;       
            cur = temp;      
        }
        return pre;  // 这里经常写错，while终止是cur=null时，需要返回cur的前一位pre
    }
}
```

时间复杂度：O(n)，因为是遍历了一遍链表

空间复杂度：O(1)，用了三个指针

tips：本题迭代法不要用虚拟头节点，第一次反转时，我们只要让cur即head指向一个空的节点就行，不能让他指向虚拟头节点，因为虚拟头节点本身是指向head，这会让链表有环、所以用一个指向null的pre就可以。



**方法二：递归**（同样需要掌握，很多面试也会问递归法）

本题也可以使用递归法，递归在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 。

递归解题首先要做的是明确递推函数的含义，如下图所示，在这里对于结点1来说，它只需要知道它之后的所有节点反转之后的结果就可以了，也就是说递推公式reverseList的含义是：把拿到的链表进行反转，然后返回新的头结点。注意这里传入递归函数的是head.next，返回的是新的头节点 newHead。<font color=red>思维不要跳进递归去想递归一层一层是怎么做的（你的脑袋能压几个栈呀？）知道递归的作用和结果就行，用它去实现算法的逻辑</font>

![image-20220428124004906](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png)

> 图源：[一步一步教你如何用递归思想反转链表](https://leetcode-cn.com/problems/reverse-linked-list/solution/yi-bu-yi-bu-jiao-ni-ru-he-yong-di-gui-si-67c3/)

如上图所示，null->1->2->3->4->5 可以拆为null->1  2->3->4->5，此时1的next还是指向2的，现在反转后部分即newHead为头的链表为 2<-3<-4<-5，那么现在只要让2指向1即可完成本轮递归。怎么得到2呢，现在1是head，前面提到1的next还是指向2的，所以2就是head.next，那么让head.next.next = head就能让2指向1，再让1的next不要指向2了，而是指向null，即head.next = null，后续的递归里再准备指向前一个节点

递归反转链表什么时候停止呢？在head为null（**链表为空**）或head下一个结点为null时（**链表只有一个节点**）停止，因为在这两种情况下，反转后的结果就是它自己。

```Java
public ListNode reverseList(ListNode head) {
	//单链表为空或只有一个节点，直接返回原单链表。单个节点必须要写，否则单个节点head.next.next为null
    if (head==null || head.next ==null) return head;
    ListNode newHead = reverseList(head.next);
    head.next.next = head; //反转在这步实现
    head.next = null;      // 必须把head.next指向null，否则会出现环
    return newHead;
}
```

时间复杂度：O(n)  空间复杂度：O(n)，栈空间



### 0092. 反转链表Ⅱ  136

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)



**方法一：双指针头插法**

1、我们定义两个指针，分别称之为 fixed 和 cur。首先根据方法的参数 left 确定 fixed 和 cur 的位置。将 fixed 移动到第一个要反转的节点的前面，将 cur 移动到第一个要反转的节点的位置上。
2、将 cur 后面的元素删除，然后添加到 fixed 的后面。也即头插法。

（写的时候一定要掌握头插法的过程，即先把cur后面的节点保存下来，然后删掉，所谓删掉就是让cur指向待删除节点的下一个节点，然后再头插，即把保存的节点放到fixed后面，这一步有分为两小步，即待删除节点的后继节点是谁，前一个节点应该是谁，一定要理清楚这个逻辑，多背）

3、根据 left 和 right 重复步骤2
4、返回 dummyHead.next

我们以 left =2，right=4为例

![img](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1-%E5%9B%BE%E8%A7%A3-%E5%8F%8C%E6%8C%87%E9%92%88.png)

> 图源：[Java-双指针-头插法 - 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/)

```Java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(head==null || head.next==null) return head;
        ListNode dummyHead = new ListNode(-1,head);
        ListNode fixed = dummyHead;
        ListNode cur = dummyHead.next;
        // 将fixed和cur根据left移到相应的位置，边界条件自己画一画
        for(int i=0; i<left-1; i++){
            fixed = fixed.next;
            cur = cur.next;
        }
        // 头插法插入节点，边界条件自己画一画
        for(int i=left; i<right; i++){
            ListNode delNode = cur.next; // 先删除每次cur后面的节点，先标记再删除
            cur.next = delNode.next;  
            delNode.next = fixed.next;   // 这一步容易弄错，每步都有传递性
            fixed.next = delNode;
        }
        return dummyHead.next; // 返回真正的头节点
    }
}
```

<font color=red>容易弄错的那一步：删除节点的next应该指向fixed.next，头插法里是fixed.next，自己在画的时候，容易写成 delNode.next = cur，因为在第一次模拟删除时，cur和fixed.next相同。那么以后再模拟时，要记住多模拟一轮</font>

时间复杂度：O(n)，因为是遍历了一遍链表

空间复杂度：O(1)

tips：本题的迭代法要使用虚拟头节点，因为反转后head会指向一个后继节点，而不是指向一个空的节点，如果是指向一个空节点，像206题一样，就不能使用虚拟头节点了，会让链表有环



**方法二：递归法（有时间看看，目前没看到面试会问这道题的递归法）**

在解决这道题之前，先用递归翻转前N个节点，比如说对于下图链表，执行 `reverseN(head, 3)`：

![img](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1-%E5%9B%BE%E8%A7%A3-%E9%80%92%E5%BD%92.png)

相比于翻转整个链表，他多了一个后继节点，因为翻转整个链表最后 `head.next=null`，而翻转部分链表需要让`head.next=successor`。如何找到这个successor，只需要在最后一轮递归中，将其赋值为`head.next`

```Java
class Solution {
    // 反转以 head 为起点的 n 个节点，返回新的头结点
    public ListNode reverseN(ListNode head, int n) {
        ListNode successor = null; // 后驱节点，即第N+1个节点，用于反转之后连接
        if(n==1){                  // 递归退出条件
            successor = head.next; // 记录第 n + 1 个节点
            return head;
        }
        // 以 head.next 为起点，需要反转前 n - 1 个节点
        ListNode newHaed = reverseN(head.next, n - 1);
        head.next.next = head;
        // 让反转之后的 head 节点和后面的节点连起来
        head.next = successor;
        return newHaed;
    }
}
```

现在解决我们最开始提出的问题，给一个索引区间 `[left,right]`（索引从 1 开始），仅仅反转区间中的链表元素。

首先，如果 `left == 1`，就相当于反转链表开头的 `n` 个元素嘛，也就是我们刚才实现的功能

如果 `left != 1` 怎么办？如果我们把 head 的索引视为 1，那么我们是想从第 left 个元素开始反转对吧；如果把 head.next 的索引视为 1 呢？那么相对于 head.next，反转的区间应该是从第 left - 1 个元素开始的；那么对于 head.next.next 呢……这是一种错位的思想，我们可以写出以下代码

```Java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == 1) {
            return reverseN(head, right);
        }
        head.next = reverseBetween(head.next, left-1,right-1);
        return head;
    }

	ListNode successor = null;  // 一定得写在外面
    public ListNode reverseN(ListNode head, int n) {
        
        if(n==1){                  
            successor = head.next; 
            return head;
        }
        ListNode newHaed = reverseN(head.next, n - 1);
        head.next.next = head;
        head.next = successor;
        return newHaed;
    }    
}
```

时间复杂度：O(n)  空间复杂度：O(n)，栈空间



### 0024. 两两交换链表中的节点  45

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即只能进行节点交换）。[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```



**方法一：迭代**

画画草稿就知道了，跟反转链表蛮像的，注意使用虚拟头节点。顺序必须是按照下面123来，否则容易丢失信息

![image-20220504230246503](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A3.png)

```Java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode dummyHead = new ListNode(-1,head);
        ListNode cur = head, pre = dummyHead;
        while(cur != null && cur.next != null){
            pre.next = cur.next;
            cur.next = cur.next.next;
            pre.next.next = cur; 
            pre = cur;        // 更新pre与head
            cur = cur.next;
        }
        return dummyHead.next;
    }
}
```

时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。空间复杂度：O(1)



**方法二：递归**

递归的逻辑反而更好理解一些，如下图所示，假设链表是 1->2->3->4->5->6，现在无非就是想让1指向2后面的部分，再让2指向1。2后面的部分可以交给递归

![image-20220504231200855](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A31.png)

```Java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null) return head;
        ListNode temp = head.next;          // 假设链表是 1->2->3->4,这句就先保存节点2
        head.next = swapPairs(temp.next);   // 1指向2后面的部分，递归
        temp.next = head;                   // 将2节点指向1
        return temp;
    }
}
```

时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。

空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。



### 0025. K个一组翻转链表  252

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



方法一：迭代

过程看图示和代码注释很清楚，不难理解，有很多细节需要注意

初始化：让pre和end两个指针放在虚拟头节点，while循环执行以下操作：

1. 让end走k步，将end定位到正确点，这期间为了保证end不指向null，for循环也要加上额外判定条件end != null
2. 循环结束后如果end指向了null，表明剩下的节点不足k个，不用反转，直接break出整个while循环
3. 准备反转pre到end这之间的链表，首先让start指向pre.next
4. 保存end.next，并让end的next指向null，即让前面部分先断开，这样才能让反转后的链表和后面的拼起来
5. 反转链表单独封装为函数，让pre.next指向反转后的链表
6. 反转结束后，start处于反转那一段的最后一个节点，让它的next指向刚才保存的temp
7. 更新pre和end，都指向start，也是下一组待反转链表的前一个节点

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/25K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png" alt="image-20220501171008166"  />

> 图源：[图解k个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/)

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummyHead = new ListNode(-1,head);
        ListNode pre = dummyHead;               
        ListNode end = dummyHead;               
        while(end != null){  // end == null，停止翻转，写成end.next!=null也可以
// 每轮循环都用for循环找到end所在位置，注意要判断end是否等于空，如果为空，end.next会报空指针异常
// 这里自己写的时候写成了&& end.next != null，这里不要想太多逻辑，只是为了防止语法错误，只要end!=null就够了，那样的话end.next就不会报空指针异常
            // 当然其实也可以在for循环里加上if(end == null) break;表示break掉for循环，不过显得有点不优雅          
            for(int i=0; i<k && end != null; i++) end = end.next;  
            if(end == null) break;   // 如果end==null，即待翻转的链表的节点数小于k，不执行翻转。
            ListNode start = pre.next;  // start指向每次待翻转链表的头节点
            // 先记录下end.next，再断开（重要！），这样才能翻转这一部分，同时也方便后面接上链表
            ListNode temp = end.next;
            end.next = null;
            // pre是每次待翻转链表头结点的上一个节点，因此让其的next指向翻转后的头
            pre.next=reverse(start);  
            start.next=temp;          // start此时指向末尾了，把它和之前保存的temp连起来
            pre=start;                // 更新pre，每次都指向待翻转链表头结点的上一个节点
            end=start;                // 更新end，同上，后面再用for循环遍历k个元素
        }   
        return dummyHead.next;        // 返回真正的头节点
    }

    public ListNode reverse(ListNode head) {
        //单链表为空或只有一个节点，直接返回原单链表
        if (head == null || head.next == null) return head; 
        ListNode pre = null;   
        ListNode cur = head;   
        ListNode temp = null;  
        while (cur != null){
            temp = cur.next;   
            cur.next=pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```



方法二：递归

做的时候一定要画图！！！

1、找到待翻转的k个节点（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。
2、对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。
3、对下一轮 k 个节点也进行翻转操作。
4、将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/25K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.png" alt="123" style="zoom:150%;" />

> 图源：[递归java - K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/di-gui-java-by-reedfan-2/)

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if(head == null || head.next == null) return head;
        ListNode dummyHead = new ListNode(-1,head);
        ListNode tail = head; // 注意tail是待翻转节点的下一组起点位置，和上一种方法的end是不同的
        // 先for循环定位到合适的位置，因为没用dummyhead，所以也是循环k次
        for(int i=0; i<k; i++){
            // 这个if判断一定要放在前面
            if(tail == null) return head; 
            tail = tail.next;   
        }
        // 反转前k个元素，返回其新的头节点newHead。reverse左开右闭，tail此时位于下一组的第一个节点处
        ListNode newHead = reverse(head,tail);
        // 上一轮的尾节点就是head，将其指向下一轮的头节点，即每次递归返回的newHead
        head.next = reverseKGroup(tail,k);
        return newHead;
    }

    public ListNode reverse(ListNode head, ListNode tail){
        if(head == null || head.next == null) return head;
            ListNode pre = null;
            ListNode cur = head;
            while(cur != tail){
                ListNode temp = cur.next;
                cur.next = pre;
                pre= cur;
                cur = temp;
            }
            return pre;
    }
}
```

关于for循环里，if判断一定要放前面，以1->2，k=2为例，假如if在后面，tail两次遍历后到了2后面的null处，这时刚好if判断成立，直接返回了head，这显然是不符合的



**本题扩展1：剩下的不足K个也要翻转**

迭代法：

```Java
    public static ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        ListNode dummyHead = new ListNode(-1, head);
        ListNode pre = dummyHead, end = dummyHead;
        while (end != null) {
            for (int i = 0; i < k && end != null; i++) end = end.next;
            ListNode start = pre.next;          
            if (end == null) {
                pre.next = reverse(start); // 改动这里，另外注意start要写在if判断之前
                break;
            }
            ListNode temp = end.next;
            end.next = null;
            pre.next = reverse(start);
            start.next = temp;
            pre = start;
            end = start;
        }
        return dummyHead.next;
    }

	public ListNode reverse(ListNode head) {
        ...
    }
```

递归法：

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            if(tail==null) return reverse(head,tail);  // 改动这里 
            tail = tail.next;
        }
        ListNode newHead = reverse(head, tail);
        head.next = reverseKGroup(tail,k);
        return newHead;
    }

    // 左开右闭
    private ListNode reverse(ListNode head, ListNode tail) {
		...
    }
}
```



**本题扩展2：从后往前K个一组反转链表**

输入：1->2->3->4->5, k = 2   输出：1->3->2->5->4

思路：先遍历一遍得到长度n，然后从n%k个结点开始每k个一组翻转

```Java
public class code25_Solution2 {
    public static ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        ListNode dummyHead = new ListNode(-1, head);
        ListNode end = dummyHead, count = dummyHead;
        int len = 0;
        while (count.next != null) {
            len++;
            count = count.next;
        }
        int res = len % k;
        for (int i = 0; i < res; i++) {
            if (end == null) return dummyHead.next;
            end = end.next;
        }
        ListNode pre = end;
        while (end != null) {
            for (int i = 0; i < k && end != null; i++) end = end.next;
            if (end == null) break;
            ListNode start = pre.next;
            ListNode temp = end.next;
            end.next = null;
            pre.next = reverse(start);
            start.next = temp;
            pre = start;
            end = start;
        }
        return dummyHead.next;
    }

    public static ListNode reverse(ListNode head) {
		...
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6, 7, 8};
        ListNode listNode = new ListNode(nums);
        System.out.println(code25_Solution2.reverseKGroup(listNode, 3));
    }
}
```

```
1->2->5->4->3->8->7->6->NULL
```





### 0876. 链表的中间结点  12

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

**方法一：快慢指针**

使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。

题目要求：「两个中间结点的时候，返回第二个中间结点」。此时可以在草稿纸上写写画画，可以得出：快指针可以前进的条件是：**当前快指针和当前快指针的下一个结点都非空。**

```Java
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null){ // 要注意这里是与，不能是或
            slow = slow.next;
            fast = fast.next.next;  // 自己写的时候老是忘了走两步
        }
        return slow;
    }
}
```

时间复杂度：O(N)  空间复杂度：O(1)



**本题扩展**：如果题目要求「两个中间结点的时候，返回第一个中间结点」。

只需要初始化时让fast指向head.next

```Java
ListNode slow = head;
ListNode fast = head.next;
```

或者是：**当前快指针的下一个结点和当前快指针的**下下一个结点**都非空。**所以就是把上面代码的while条件改一下

```Java
while(fast.next != null && fast.next.next != null)
```





### 0019. 删除链表的倒数第N个结点  101

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```



**方法一：快慢指针+前置指针**

涉及到了待操作结点的前一个结点，设置虚拟头节点，否则头结点没有前一个结点，要单独讨论

初始时slow和fast都指向虚拟头节点，slow指针不动，让fast指针先走n步，然后两个指针同时移动，再定义一个pre指针始终指向slow前一个结点。当fast移到null时，slow就指向了待删除结，使用pre删除它

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null) return head;
        ListNode dummyHead = new ListNode(-1,head);
        ListNode slow = dummyHead, fast = dummyHead;
        for(int i=0; i<n; i++) fast = fast.next;  // 让fast先动n步
        while(fast.next != null){             // fast移动结束后，确保slow指向待删除结点的前一个
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;           // 删除节点
        return dummyHead.next;
    }
}
```



同剑指 Offer 22. 链表中倒数第k个节点  [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

题目要求返回倒数第k个节点开头的链表，思路同上

```Java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null) return head;
        ListNode slow = head;
        ListNode fast = head;
        for(int i=0; i<k; i++) fast = fast.next;
        while(fast != null){
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```



### 0021. 合并两个有序链表  204

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```



**方法一：迭代**

维护一个 `prev` 指针，我们需要做的是调整它的 `next` 指针。当 l1 和 l2 都不是空链表时，如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。动图只展示部分过程

![626f9c0527e5a](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.gif)

> 图源：[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/)

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode preHead = new ListNode(-1);  // 这里不能将preHead设为null，null没有next
        ListNode pre = preHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else {
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next; // 不管哪种情况，pre都要往后移一位
        }
        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        pre.next = list1 ==null ? list2 : list1;
        return preHead.next;
    }
}
```

时间复杂度：O(n+m)  空间复杂度：O(1)



**方法二：递归**

判断 `l1` 和 `l2` 头结点哪个更小，然后较小结点的 `next` 指针指向**其余结点的合并结果。（调用递归）**

终止条件：当两个链表都为空时，表示我们对链表已合并完成。

![626f962568804](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[一看就会，一写就废？详解递归 - 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next,list2); // 1小就合并1后面的和整个2
            return list1;   // 作为头返回
        }
        else {
            list2.next = mergeTwoLists(list1,list2.next); // 2小就合并2后面的和整个1
            return list2;   // 作为头返回
        }
    }
}
```

时间复杂度：O(n+m)  空间复杂度：O(n+m)



**本题扩展1：合并后去重**

迭代法我自己的去重思路是最好有个额外指针再保存一下pre的前一个元素，如果pre和pre的下一个元素重复，就利用pre前一个把pre删除。没用代码验证，感觉比较麻烦

递归的思路也很简单，首先将2个list本身去重，然后只有可能list1和list2中的元素重复，递归时候单独列出来，直接让list1去指向（让list2也行，都可以）两个list.next的递归

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 去重1 两个list本身去重，直接跳到最后一个
        while (list1 != null && list1.next != null && list1.val == list1.next.val)
            list1 = list1.next;
        while (list2 != null && list2.next != null && list2.val == list2.next.val)
            list2 = list2.next;
        // 下面整体逻辑同递归
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next,list2); 
            return list1;
            }
        else if(list1.val > list2.val){
            list2.next = mergeTwoLists(list1,list2.next);
            return list2;
        }
        else { // 去重2 list1.val = list2.val
            list1.next = mergeTwoLists(list1.next, list2.next);
            return list1;
        }
    }
}
```





### 0023. 合并K个升序链表  142

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
```

面试回答思路：一个个合并上去  -> 分治  -> 最小堆



**方法一：顺序合并**

有了21题作为基础，不难想到按照给定的顺序，两两合并链表即可。时间复杂度较高

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode ans = null;
        for (int i = 0; i < lists.length; ++i) {
            ans = mergeTwoLists(ans, lists[i]);
        }
        return ans;
    }

    public ListNode mergeTwoLists(ListNode a, ListNode b) {
        ...
    }
```

渐进时间复杂度为 O(k^2 × n)   ：数组里有k个链表，假设每个链表的最长长度是 n。在第一次合并后，ans 的长度为 n；第二次合并后，ans 的长度为 2×n，第 i 次合并后，ans 的长度为 i×n。第 i 次合并的时间是 O(i×n)，那么总的时间代价为*O*((1+*k*)k/2×n)=*O*(k^2^n)，即对i求和，1+2+...+n

渐进空间复杂度为 O(1)



**方法二：分治合并**

用分治的方法进行合并。将 k 个链表配对并将同一对中的链表合并。原来一个一个加，现在是一组一组加，用递归的栈保留了信息

![6.jpg](E:/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98.assets/88d261465f1f21288dd23cef2f059297f5d053fc19805458a47ae1b05f3c0703-6.jpg)

```Java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;  // 注意对空数组的判断
        return merge(lists, 0, lists.length-1);
    }

    public ListNode merge(ListNode[] lists, int left, int right){
        if(left == right) return lists[left];  // 递归终止条件
        int mid = left + (right-left)/2;
        ListNode list1 = merge(lists, left, mid);
        ListNode list2 = merge(lists, mid+1, right);
        return mergeTwoLists(list1, list2);
    }

    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode preHead = new ListNode(-1);
        ListNode pre = preHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else {
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next; 
        }
        pre.next = list1 ==null ? list2 : list1;
        return preHead.next;
    }
}
```

时间复杂度分析：

如果N是平均每条链表的节点数，有K条链表，合并两条链表的时间复杂度是 O(N)，归并的思想里，每条链表会被合并 logK 次，K 条链表会被合并 K * logK 次，因此总共的时间复杂度是 O*(*KlogK * N)

如果N是K 条链表的总结点数，K 条链表的总结点数是 N，平均每条链表有 N/K 个节点，因此合并两条链表的时间复杂度是 O(N/K)。从 K 条链表开始两两合并成 1 条链表，因此每条链表都会被合并 logK 次，因此 K 条链表会被合并 K * logK 次，因此总共的时间复杂度是 K * logK * N/K 即 O（NlogK）

空间复杂度： O(logK)



**方法三：使用优先队列（也要求掌握）**

用容量为K的最小堆优先队列，先把所有链表的头结点都放进去，然后出队当前优先队列中最小的，挂上一个空链表，最后准备返回这个链表，然后让出队的那个节点的下一个节点入队，后面就是循环出队当前优先队列中最小的，直到优先队列为空。

使用优先队列版本：

```Java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        Queue<ListNode> pq = new PriorityQueue<>((v1, v2) -> v1.val - v2.val);
        for(ListNode node : lists){  // 这里添加的只是所有链表的头节点
            if(node != null) 
                pq.offer(node);
        }
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while(!pq.isEmpty()){
            ListNode minNode = pq.poll();
            cur.next = minNode;
            cur = cur.next;
            if(minNode.next != null) // 消耗了一个最小节点，把这个最小节点的下一个节点入堆
                pq.offer(minNode.next);
        }
        return dummyHead.next;
    }
}
```

手写最小堆版本：

[手动实现小顶堆，具体看代码实现 - 合并K个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/solution/shou-dong-shi-xian-xiao-ding-dui-ju-ti-k-vswy/)



### 0148. 排序链表  93

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。[148. 排序链表](https://leetcode.cn/problems/sort-list/)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```



**方法一：归并排序：链表中点 + 合并链表**

通过递归实现链表归并排序，有以下两个环节：

（1）**分割 cut 环节：** 使用快慢指针找到当前链表`中点`，并从`中点`将链表断开（以便在下次递归 `cut` 时，链表片段拥有正确边界）；

（2）**合并 merge 环节：** 将两个排序链表合并，转化为一个排序链表

```java 
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        // 找中点，偶数个节点时返回第一个中点
        ListNode temp = findMid(head);
        ListNode mid = temp.next;		   // mid一定是后半段的第一个
        temp.next = null;                  // 一定要和后面的断开连接
        ListNode list1 = sortList(head);   // 递归
        ListNode list2 = sortList(mid);
        return merge(list1,list2);
    }

    public ListNode findMid(ListNode head){
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public ListNode merge(ListNode list1, ListNode list2){
        ListNode dummyHead = new ListNode(-1);
        ListNode pre = dummyHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else{
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next;
        }
        pre.next = (list1 == null ? list2 : list1);
        return dummyHead.next;
    }
}
```

时间复杂度：O(nlogn)，空间复杂度：O(log n)

能够通过力扣的所有测试用例



**方法二：快速排序（要掌握，考过的）**

做之前先做86题，部分思想是一致的。

挑选最左边的元素作为标定点，后续元素依次比较，用两个单独的指针，将原链表根据大于或小于标定点分成两个链表，后续递归、合并。比86多的注意点是要分完两个链表后，把head的next也断开，再拼到small后

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null || head.next==null) return head;
        int pivot = head.val;
        ListNode smallHead = new ListNode(-1);
        ListNode largeHead = new ListNode(-1);
        ListNode small = smallHead, large = largeHead;
        ListNode cur = head.next;  // 务必注意cur是从第二个节点开始，自己写成了从头开始链表，那样会有环
        while(cur != null){
            if(cur.val < pivot){  // <=会出错，原因暂时不知道
                small.next = cur;
                small = small.next;
            } else {
                large.next = cur;
                large = large.next;
            }
            cur = cur.next;
        }
        small.next = null;  // 断开small在原链表中的指向，由于后续还有指向，此句可省略
        large.next = null;  // 同上
        head.next = null;   // 同上
        // 将pivot连接到small后，虽然也可以放到large前，但会很麻烦（small和large现在都处于最后节点）
        small.next = head;  
    
        small = sortList(smallHead.next);  // 递归前半段
        large = sortList(largeHead.next);  // 递归后半段
        head.next = large;                 // 两段拼起来，head始终是前半段的最后一个节点
        return small;
    }
}
```

此代码力扣提交有一个测试用例会超时，其他均正确。超时的测试用例是一个近乎有序数组，可能利用随机化快排的思想能够解决，先找到链表中点，然后交换头节点和中点的 val，随后再快排



**方法三：自底向上归并（最好掌握）**





### 0086. 分隔链表  17

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。[86. 分隔链表](https://leetcode.cn/problems/partition-list/)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```



方法一：双指针迭代

构建两个链表，smallHead 和 largeHead，一个链表放小于`x`的节点，另一个链表放大于等于`x`的节点。最后，拼接这两个链表。过程中用两个指针 small 和 large，加上原来的 head 指针去遍历原链表

代码的逻辑不难理解，易错的地方在于遍历完原链表后需要把small和large的next指针指向断开。

如下图所示，设x为5，当head指向空时，退出循环，但 small 和 large 的 next 都没有改变，large所指的 5 在原链表还是指向3的，这显然是不可以的（如果下图最后一个不是3，是大于5的元素，那么small指针也是同理），所以循环结束需要让两个指针都指向null

![QQ图片20220616132111](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/86%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.png)

```Java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode smallHead = new ListNode(-1);
        ListNode largeHead = new ListNode(-1);
        ListNode small = smallHead, large = largeHead;
        while(head != null){
            if(head.val < x){
                small.next = head;
                small = small.next;
            } else {
                large.next = head;
                large = large.next;
            }
            head = head.next;
        }
        small.next = null;  // 断开small在原链表中的指向，由于后续还有指向，此句可省略
        large.next = null;  // 同上
        small.next = largeHead.next; 
        return smallHead.next;
    }
}
```





### 0328. 奇偶链表

给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。[328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```



**方法一：迭代**

定义两个指针odd和even去遍历整个链表，注意偶链表头需要额外定义节点保存，用于拼接在奇链表后面

逻辑上不难，画画图就行，就是简单的改变next指针。此题也可以只维护一个指针，但节省一个指针意义不大，反而降低代码可读性。

关于while的终止条件，如果是奇数个节点，odd.next为null，如果是偶数个节点，even.next为null，所以while循环条件应该是二者都不为null，即`odd.next != null && even.next != null`

```Java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head == null) return head;
        ListNode evenHead = head.next;   // 记录初始的偶链表头节点
        ListNode odd = head;             // 奇偶两个指针用于遍历
        ListNode even = evenHead;
        while(odd.next != null && even.next != null){
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        // 由于while循环条件有even.next != null，当链表长度为奇数时没影响
        // 当链表长度为偶数时，最后一个odd还会指向最后一个even，需要断开
        odd.next = null;                 
        odd.next = evenHead;             // 奇链表后加上偶链表，所以上一句其实可以省略
        return head;    
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



### NC207. 排序奇升偶降链表

给定一个奇数位升序，偶数位降序的链表，返回对其排序后的链表。[排序奇升偶降链表_牛客网](https://www.nowcoder.com/practice/3a188e9c06ce4844b031713b82784a2a?tpId=117&tqId=39396&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D207%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D117&difficulty=undefined&judgeStatus=undefined&tags=&title=207)

```
输入：{1,3,2,2,3,1}
输出：{1,1,2,2,3,3}
```



**方法一：迭代**

不难分析，此题就是 **奇偶链表+链表反转+合并链表**

具体来说，先将原链表拆成奇链表和偶链表，偶链表是降序，所以把偶链表翻转，再把两个链表拼起来

```Java
public class Solution {
    public ListNode sortLinkedList (ListNode head) {
        if(head == null || head.next == null) return head;
        // 拆分奇偶链表
        ListNode oddHead = head;
        ListNode evenHead = head.next;
        ListNode odd = oddHead;
        ListNode even = evenHead;
        while(even != null && even.next != null){
            odd.next = even.next;       
            even.next = even.next.next;  
            odd = odd.next;              
            even = even.next;
        }
        // 与上题不同的是，此处一定要先断开最后的odd.next，否则就会出错，比如1->3->2->2->3->1，理想状态奇链表是拆成为1->2->3，但实际上不加这句就会拆成1->2->3->1，即最后一个odd还会指向最后一个even
        odd.next = null;     
        evenHead = reverseList(evenHead);
        return mergeTwoLists(oddHead,evenHead);
    }
    
    // 翻转链表
    private ListNode reverseList(ListNode head){
        if (head == null || head.next == null) return head; 
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
    
    // 合并两个有序链表
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode preHead = new ListNode(0);
        ListNode pre = preHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else {
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next;
        }
        pre.next = list1 ==null ? list2 : list1;
        return preHead.next;
    }  
}
```





### 143. 重排链表  114

给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln - 1 → Ln

请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。[143. 重排链表 - 力扣](https://leetcode-cn.com/problems/reorder-list/)

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E7%A4%BA%E4%BE%8B.png" alt="image-20220503215014680" style="zoom:200%;" />

**方法一：线性表**存储

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。题目其实就是给一个链表，然后依次头尾头尾头尾取元素，组成新的链表。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按题目需要的顺序访问指定元素，重建该链表即可。

时间复杂度：O(N)，空间复杂度：O(N)



**方法二：链表中点 + 翻转链表 + 合并链表**

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1. 找到原链表的中点：我们可以使用快慢指针找到链表的中间节点。参考876题
2. 将原链表的右半端反转：我们可以使用迭代法实现链表的反转。参考206题
3. 将原链表的两端合并：因为两链表长度相差不超过 1，也不用比较元素大小，因此直接合并即可。

```
1 -> 2 -> 3 -> 4 -> 5 -> 6
第一步，将链表平均分成两半
1 -> 2 -> 3
4 -> 5 -> 6
    
第二步，将第二个链表逆序
1 -> 2 -> 3
6 -> 5 -> 4
    
第三步，依次连接两个链表
1 -> 6 -> 2 -> 5 -> 3 -> 4
```

代码：

```Java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) return;
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null; // 注意断开mid的next指针，因此偶数个节点时必须返回第一个中点
        l2 = reverse(l2);
        mergeList(l1,l2);
    }

    // 返回中间节点， 偶数个节点返回第一个中点
    private ListNode middleNode(ListNode head){
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 翻转链表
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }

    // 拼接链表，注意没有返回值
    private void mergeList(ListNode list1, ListNode list2){
        ListNode temp1;
        ListNode temp2;
        while(list1 != null && list2 != null){
            temp1 = list1.next;
            temp2 = list2.next;
            list1.next = list2;
            list1 = temp1;
            list2.next = list1;
            list2 = temp2;
        } 
    }
}
```

时间复杂度：O(N)，空间复杂度：O(1)





### 234. 回文链表  61

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 

[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```
输入：head = [1,2,2,1]
输出：true
```



**方法一：将值复制到数组中后用双指针法**

单向链表无法倒着索引，但数组可以，因此可以将链表元素放到数组中，然后首尾指针对比是否是回文

时间复杂度：O(n)，空间复杂度：O(n)



**方法二：链表中点 + 翻转链表**

和143题类似，也可以用链表中点+翻转链表来解决。具体来说，快慢指针用来找链表中点，将后半部分的链表翻转，再和前半部分对比，是否是回文

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null; // 注意断开mid的next指针
        l2 = reverse(l2);

        while(l1 != null && l2 != null){
            if(l1.val != l2.val) return false;
            l1 = l1.next;
            l2 = l2.next;
        }
        return true;
    }

    // 返回中间节点， 偶数个节点返回第一个中点
    private ListNode middleNode(ListNode head){
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 翻转链表
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```

注意，题目没要求不得改动原链表，否则还要把后半部分翻转回来

时间复杂度：O(n)，空间复杂度：O(1)



**方法三：翻转前半部分（知道思路，最好能写出来）**

翻转链表时自然也可以翻转前半部分，像上面一样调用函数去翻转前半部分这里就不提了，另一种方法是前半部分的慢指针找中点过程中，边找边翻转，时间复杂度更低。具体代码如下所示

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        ListNode slow = head, fast = head, pre = null, cur = head;
        // 注意这样写，如果是偶数个的话，slow会停在第二个中点，pre会停在第一个中点，符合我们的需求
        // 如果是奇数个，在退出循环时fast!=null，让slow再后移一个。总之始终保持slow在后半段第一个
        while(fast != null && fast.next != null){ 
            cur = slow;
            slow = slow.next;               // 快慢指针找中点
            fast = fast.next.next;
            cur.next = pre;                 // 反转链表
            pre = cur;
        }
        if(fast != null) slow = slow.next;  // 如果fast不为空，说明链表的长度是奇数个，跳过中点
        // 开始判断回文，分别是以cur为头的前半部分的翻转链表，以slow为头的后半部分的原链表
        while(cur != null && slow != null){
            if(cur.val != slow.val) return false;
            cur = cur.next;
            slow = slow.next;
        }
        return true;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)

此处的逻辑非常需要小心，正常的找中点和翻转是独立分开的，此处并不能完全意义上的先翻转或者先后移快慢指针

（1）翻转的过程中，slow是作为保存下一个结点来用的，要写在真正的翻转即`cur.next = pre; `之前，相当于反转链表里的`ListNode temp = cur.next`。但不能先反转再移动快慢指针，比如下面这段代码，cur.next已经原地翻转了，所以slow没办法向后指向真正的下一个结点了，而是向前指了

```Java
while(fast != null && fast.next != null){ 
    cur = slow;
    cur.next = pre;                 // 反转链表
    pre = cur;
    slow = slow.next;               // 快慢指针找中点
    fast = fast.next.next; 
}
```

（2）但`cur = slow;`又不能写在移动快慢指针之后，如下所示，cur还没翻转呢，就跳到下一个了

```Java
while(fast != null && fast.next != null){ 
    slow = slow.next;               // 快慢指针找中点
    fast = fast.next.next;
    cur = slow;
    cur.next = pre;                 // 反转链表
    pre = cur;
}
```





### 141. 环形链表  183

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。[141. 环形链表 - 力扣](https://leetcode-cn.com/problems/linked-list-cycle/)

![image-20220617104438983](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%9B%BE%E7%A4%BA.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```



**方法一：双指针**

定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步（走大于1步都行，2步最省时）。初始时，快慢指针都在位置 head。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。（在环形跑道上跑步，跑的慢的一定会与跑的快的相遇，因为快的会给慢的套圈。）

```Java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(true){
            if(fast == null || fast.next == null) return false;  // 快指针走到头了，链表无环
            fast = fast.next.next;         // 这一步需要前面的if里有fast.next != null，否则会报空指针异常
            slow = slow.next;     
            if(fast == slow)  return true; // 相遇说明有环
        }
    }
}
```

时间复杂度：O(N)，空间复杂度：O(1)

注意由于快慢指针都在位置 head，while条件不能用while(fast == slow)，如果用 while(fast != null && fast.next != null) 作为循环条件也可以，但是为了和142题代码保持统一，这里还是用 while(true)



**方法二：哈希表（也要掌握）**

使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```Java
public class Solution {
    public boolean hasCycle(ListNode head) {
        HashSet<ListNode> seen = new HashSet<>();
        while(head != null){
            if(seen.add(head) == false) return true;
            head = head.next;
        }
        return false;
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)



### 142. 环形链表Ⅱ  139

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)



**方法一：双指针**

和141一样仍然是快慢指针，难点在于如何找到环形入口

这道题需要数学公式推导+逻辑结合（推导过程需要掌握，面试会问）：

设环形入口前有a个节点，环形中有b个节点，初始化时快慢指针都指向head，快指针走了f步，慢指针走了s步，如果是环形链表就一定会相遇，此时，f=2s，**同时因为相遇，也能得到：f=s+nb（这里比较难想到）**，相减得到: s = nb。即第一次相遇时得到了s = nb，**注意这并不是现有逻辑的认知，而是推导出来的**。

**一个节点正常走到环形入口肯定是走了 a+nb 步（这个也不太好想）**, 那么现在s=nb，只要让slow再走a步就能到环形入口了。从哪里能得到a步？答案是从头节点走到环形入口，因此再重新把 fast 放到 head，slow和fast都往下走，走a步之后，s=a+nb，f=a，在入口处相遇，此时fast走的步数就是我们需要的a

![6270fa093a35f](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[环形链表 II（双指针法，清晰图解）](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(true){
            if(fast == null || fast.next == null) return null;  // 快指针走到头了，链表无环
            fast = fast.next.next; 
            slow = slow.next;     
            if(fast == slow)  break; // 相遇说明有环，退出循环，此时slow位置很重要，这是第一次相遇
        }
        
        fast = head;   // 重新将fast放到head
        while(fast != slow){
            slow = slow.next;
            fast = fast.next;
        }
        return fast;   // 第二次相遇，fast的位置就是环形入口
    }
}
```



本题扩展一：输出环的长度（环中的节点个数）

​	思路：让fast停在环形入口，slow继续走一圈，走到fast处，走过的路径可得环的长度





### 83. 删除排序链表中的重复元素  50

给定一个已排序的链表的头 `head` ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表。[83. 删除排序链表中的重复元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```
输入：head = [1,1,2]
输出：[1,2]
```



**方法一：迭代**

画草稿的时候多搞点重复元素，比如链表里有4个3

指定 cur 指针指向头部 head，当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了。当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果，如果不相等则 cur 移动到下一个位置继续循环

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode cur = head;
        while(cur != null && cur.next != null){
            if(cur.val == cur.next.val) 
                cur.next = cur.next.next;  // 注意不是更新cur，是更新cur.next
            else cur = cur.next;           // 确定cur.next没问题再更新cur
        }
        return head;
    }
}


// 或者
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode cur = head;
        while(cur != null && cur.next != null){
            while(cur.next != null && cur.val == cur.next.val){
                cur.next = cur.next.next;
            }
            cur = cur.next;
        }
        return head;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



**方法二：递归**

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        head.next = deleteDuplicates(head.next);
        // 递归返回什么看是否重复，重复就返回下一个结点(相当于删除自身)，不重复返回自身
        return head.val == head.next.val ? head.next : head;
    }
}
```

时间复杂度：O(N)，空间复杂度：O(N)，递归调用的时候会用到了系统的栈



### 82. 删除排序链表中的重复元素Ⅱ  94

给定一个已排序的链表的头 `head` ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表 。[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```



**方法一：迭代**

画草稿的时候多搞点重复元素，比如链表里有4个3

和上一题的区别就是删除全部重复的元素，那么不要去判断cur和cur.next是否相等，这时候cur已经在第一个相等元素处了，而是去判断cur.next和cur.next.next是否相等，这时cur还在相等元素的前一个元素。if里再加个while循环寻找合适的cur.next

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A1-%E5%9B%BE%E8%A7%A3.png" alt="img" style="zoom: 50%;" />

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode dummyHead = new ListNode(-1,head); // 注意取值不能是原链表范围内的数
        ListNode cur = dummyHead;
        while(cur.next != null && cur.next.next != null){
            if(cur.next.val == cur.next.next.val){
                int x = cur.next.val;          // 元素全部被删除了，单独备份一下
                while(cur.next != null && cur.next.val == x){  // 防止空指针异常
                    cur.next = cur.next.next;  // 注意不是更新cur，是更新cur.next
                }
            }
            else{
                cur = cur.next;                // 确定cur.next没问题再更新cur
            }
        }
        return dummyHead.next;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



**方法二：递归**

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)  return head;
        // 当前结点和下一个结点相等
        if (head.next != null && head.val == head.next.val) {
            // 先遍历到相同元素的最后一个元素，比如4个3，head定位到最后一个3
            while (head.next != null && head.val == head.next.val) {
                head = head.next;
            }
            // 返回下一个结点的递归，即抛弃最后一个3
            return deleteDuplicates(head.next);
        } else { // 当前结点和下一个结点不等，当前结点指向下一个结点为头的递归
            head.next = deleteDuplicates(head.next);
        }     
        // 最终返回头结点
        return head;    
    }
}
```

时间复杂度：O(N)，空间复杂度：O(N)，递归调用的时候会用到了系统的栈



### 203. 移除链表元素  4

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

本题逻辑很简单，但是不加虚拟头节点很麻烦，需要添加虚拟头节点，不用对头节点进行额外考虑

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null) return head;
        // 虚拟头节点
        ListNode dummy = new ListNode(-1,head);        
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur != null){
            if(cur.val == val){
                pre.next = cur.next;
            }
            else{
                pre = cur;
            }
            cur = cur.next;
        }

        return dummy.next;
    }
}
```

不设立虚拟头节点：

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //没有dummyHead，需要对head进行讨论
        //删除值相同的头结点后，可能新的头结点也值相等，用循环解决
        while (head!=null && head.val == val){
            head = head.next;
        }        
        if (head == null)        //如果链表为空，返回null
            return null;
        ListNode prev = head;    //找到待删除节点的前一个节点        
        while (prev.next!=null){ //确保当前结点后还有结点
            if (prev.next.val == val){
                prev.next = prev.next.next;
            }
            else
                prev = prev.next;
        }
        return head;
    }
}
```

递归：

```Java
class Solution {
        public ListNode removeElements(ListNode head, int val) {
        if (head == null)
            return null;
        // 删除节点递归思想：将链表拆分为头节点和剩下的链表，删除剩下的链表元素中等于val的节点，
        // 再判断头节点是否需要删除，如果不要就和剩下的拼起来，如果要那么只剩删除后的链表，随后递归
        head.next = removeElements(head.next, val);
        // 删除元素就发生在这一步中
        return head.val == val ? head.next : head;
    }
}
```



### 146. LRU 缓存  413

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。实现 LRUCache 类：

* LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
* int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
* void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```



**方法一：双向链表+哈希表**

O(1) 的快速查找，就哈希表了。光靠哈希表可以吗？哈希表是无序的，无法知道里面的键值对哪些最近访问过，哪些很久没访问。快速删除，谁合适？数组？元素的插入/移动/删除都是 O(n)。不行。单向链表？删除节点需要访问前驱节点，只能花 O(n) 从前遍历查找。不行。双向链表，结点有前驱指针，删除/移动节点都是纯纯的指针变动，都是 O(1)。因此，确定下来：双向链表+哈希表

双向链表、哈希表，各自的角色：

* 双向链表的结点：存 key 和 对应的数据值。这个得自己定义
* 哈希表的存在意义：快速访问【存储于双向链表】的数据，不是它自己存数据
    * key：双向链表中存的 key
    * value：链表中的结点

![img](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/146LRU%E7%BC%93%E5%AD%98-%E5%9B%BE%E8%A7%A3.png)

下面的代码把链表尾部作为最新cache的位置，头部为最久未用

```Java
class LRUCache {
    private HashMap<Integer, Node> map;
    private DoubleList cache;
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }
    
    public int get(int key) {
        if(!map.containsKey(key)) return -1;
        // 将某个 key 提升为最近使用的
        Node x = map.get(key);
        cache.remove(x);    // 先从链表中删除这个节点
        cache.addLast(x);   // 重新插到链表尾部，链表尾部就是最近使用的元素
        return x.val;
    }
    
    public void put(int key, int value) {
        Node x = new Node(key,value);
        // 注意下面的结构必须用 if-else if，因为节点只会分为 存在、不存在缓存满，不存在缓存未满，最后一种无需额外处理，前两种情况是互斥的
        if(map.containsKey(key)){            // 若该节点已经存在，先从cache里删除，后面再添加
            cache.remove(map.get(key));         
        } else if(capacity == map.size()){   // 若该节点不存在，但cache已满，就删除最久未使用的
            Node first = cache.removeFirst();// 链表头部的第一个元素就是最久未使用的
            map.remove(first.key);           // map里也要删除                             
        }
        cache.addLast(x);  // 链表尾部就是最近使用的元素
        map.put(key,x);    // 别忘了在 map 中添加 key 的映射
    }
}


class Node{
    public int key,val;
    public Node next,pre;
    public Node(int k, int v){
        this.key = k;
        this.val = v;
    }
}

class DoubleList{
    private Node head,tail;      // 头尾虚拟节点

    public DoubleList() {
        head = new Node(0,0);
        tail = new Node(0,0);
        head.next = tail;
        tail.pre = head;
    }

    public void addLast(Node x){ // 在链表尾部添加节点x，时间O(1)，记得画图
        x.pre = tail.pre;
        x.next = tail;
        tail.pre.next = x;
        tail.pre = x;
    }

    public void remove(Node x) {  // 删除链表中的 x 节点（x 一定存在），时间 O(1)
        x.pre.next = x.next;
        x.next.pre = x.pre;
    }

    public Node removeFirst() {   // 删除链表中第一个节点，并返回该节点，时间 O(1)
        if(head.next == tail) return null; // 只有两个虚拟节点表明链表里无节点
        Node first = head.next;
        remove(first);
        return first;
    }
}
```

当然了上面是自己写的双向链表，也可以使用库里的LinkedList

```Java
class LRUCache {
    private HashMap<Integer, Node> map;
    private LinkedList<Node> cache;
    private int capacity;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new HashMap<>();
        cache = new LinkedList();
    }
    
    ...
}
```



### 160. 相交链表  163

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。题目数据 **保证** 整个链式结构中不存在环。**注意**，函数返回结果后，链表必须 **保持其原始结构** 。[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

图示两个链表在节点 `c1` 开始相交：

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E7%A4%BA%E4%BE%8B.png" alt="image-20220503212241705" style="zoom:200%;" />



**方法一：双指针**

我先走我的路，再走你的路，你先走你的路，再走我的路，这样咱俩走的路程就一样了，速度一样，那么肯定在咱俩两条路的交叉口相遇（若相交，链表A： a+c， 链表B : b+c， a+c+b+c = b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b = b+a 。因此相遇处是NULL）

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;

        // 要么相遇即节点相等，要么都为空（只走一次对方的路，都有尽头为null），最终都能跳出循环。
        while(curA != curB){
            // 两人以相同的速度（一次一步）沿着各自的路径走
            // 当走完各自的路时，再“跳”至对方的路上。（起点平齐速度相同，终点即为相遇点）
            curA = (curA == null? headB: curA.next);
            curB = (curB == null? headA: curB.next);
        }
        return curA;
    }
}
```

时间复杂度：O(m+n)   空间复杂度：O(1)



**方法二：哈希集合**

首先遍历链表 headA，并将链表headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：如果当前节点不在哈希集合中，则继续遍历下一个节点；如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        Set<ListNode> visited = new HashSet<ListNode>();
        ListNode temp = headA;
        while (temp != null) {
            visited.add(temp);
            temp = temp.next;
        }
        temp = headB;
        while (temp != null) {
            if (visited.contains(temp)) {
                return temp;
            }
            temp = temp.next;
        }
        return null;
    }
}
```

时间复杂度：O(m+n)   空间复杂度：O(m)



### 2. 两数相加  92

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值，如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1。

逻辑上不难，不要陷于非要求和的逻辑，比如先得到342和465再相加，而是转为加法进位本位，细节已注释，逻辑统一加上虚拟头结点

代码如下：

```Java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(-1);  // 定义新链表虚拟头节点
        ListNode cur = dummyHead;              // 可移动指针，初始化指向虚拟头节点
        int carry = 0;                         // 进位数，进位数先使用后计算，所以得提前定义好   
        while(l1 != null || l2 !=null){        // 注意这里，有一个空无所谓，两个都为空才停下来
            int x = (l1 != null ? l1.val : 0);  // 有值就取，没有补0
            int y = (l2 != null ? l2.val : 0);  
            int sum = x + y + carry;           // 将两个链表的值进行相加，并加上前一轮的进位数
            carry = sum / 10;                  // 计算进位数
            sum = sum % 10;                    // 计算本位数
            // 将求和数赋值给新链表的节点，注意别写为cur.next = sum
            cur.next = new ListNode(sum);      
            cur = cur.next;
            // 注意if条件不能是l1.next != null，要让l1走到null才行，才能退出while循环
            if(l1 != null) l1 = l1.next;
            if(l2 != null) l2 = l2.next;
        }
        // 循环结束了，但最高位还有进位，而且也只能是1，就再加一个节点
        if(carry == 1) cur.next = new ListNode(1);
        return dummyHead.next;                 // 注意返回真正的头节点
    }
}
```





### 138. 复制带随机指针的链表  40

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。 [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。

random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

![image-20220504232113851](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```



本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建



**方法一：迭代原地模拟**

那么我们可以利用原链表的 next 做一个临时中转，从而实现映射。

具体的，我们可以按照如下流程进行：

* 对原链表的每个节点节点进行复制，并追加到原节点的后面；

* 之后，链表的奇数位置代表了原链表节点，链表的偶数位置代表了新链表节点，且每个原节点的 next 指针执行了对应的新节点。这时候，我们需要构造新链表的 random 指针关系，可以利用观察到的规律：如果原节点`i`的随机指针指向的是原节点`j`，那么新节点`i+1`的随机指针，指向的是原节点`j`的**next**，即为

    `link[i + 1].random = link[i].random.next`，i 为奇数下标。

    比如下图1的random指向3，那么1的下一个1的random就指向3的下一个3

* 对链表进行拆分操作。（拆分操作需要前继节点，创建虚拟头节点）

![image-20220505141352525](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A32.png)

>  图源：[【宫水三叶】一题双解：「哈希表」&「原地算法」 - 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/)

写构建和拆分代码之前一定要先画图，搞清楚指针指向顺序

```Java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        // 第一次遍历构建新链表架子
        Node cur = head;                  
        while(cur != null){
            Node newNode = new Node(cur.val);
            newNode.next = cur.next; // 注意顺序，先连接后面
            cur.next = newNode;
            cur = newNode.next;          
        }
        // 第二次遍历构建新链表指向
        cur = head;
        while(cur != null){
            if (cur.random != null)   // 注意当random指针指向空就不用指了
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 第三次遍历拆分链表，这部分容易忘记
        cur = head;
        // 注意一定要先保留第二个节点为头的链表，不能在最后再返回head.next，那会head不是链表头
        Node res = head.next;      
        while(cur != null && cur.next != null){
            Node temp = cur.next;  // 先保存后面的节点
            cur.next = temp.next;
            cur = temp;  // 不用再搞什么temp.next，直接让cur指向temp即可完成链表拆分
        }
        return res;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



**方法二：哈希表**

我们用哈希表来解决这个问题，首先创建一个哈希表，先遍历原链表，遍历的同时不断在新链表中创建节点，我们将原节点作为**key**，新节点作为**value**放入哈希表中。

![image-20220505134940263](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png)

从上图中我们可以发现，原节点和新节点是一一对应的关系，所以能够得出：

* 新节点.next = map.get(原节点.next)
* 新节点.random = map.get(原节点.random)

所以再进行第二次遍历原链表，这次我们要将新链表的next和random指针给设置上。

![image-20220505135225570](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.png)

> 图源：[两种实现+图解 138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/liang-chong-shi-xian-tu-jie-138-fu-zhi-dai-sui-ji-/)

最后，`map.get(head)`，也就是返回对应的新链表的头节点

总结为先根据原链表创建新链表，再根据原链表构建新链表指向

```Java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Map<Node,Node> map = new HashMap<>();
        Node cur = head;
        while(cur != null){  // 第一次遍历构建哈希表与新链表架子
            Node newNode = new Node(cur.val);
            map.put(cur,newNode);
            cur = cur.next;
        }
        cur = head;          // 第二次遍历构建新链表指向
        while(cur != null){
            Node newNode = map.get(cur);          // 获取哈希表中新链表的节点
            newNode.next = map.get(cur.next);     // 构建新链表节点的next指向
            newNode.random = map.get(cur.random); // 构建新链表节点的random指向
            cur = cur.next;
        }
        return map.get(head);
    }
}
```

时间复杂度：O(n)，空间复杂度：O(n)









## 栈

栈（Stack）是一种线性结构，先进后出。常用方法为：

| 方法名                      | 方法描述                                       |
| --------------------------- | ---------------------------------------------- |
| Object push(Object element) | 把元素压入堆栈顶部                             |
| Object pop( )               | 移除堆栈顶部的对象，并作为此函数的值返回该对象 |
| Object peek( )              | 查看堆栈顶部的对象，但不从堆栈中移除它         |
| boolean isEmpty()           | 测试堆栈是否为空                               |

栈是抽象的概念，栈可以用「数组」或者「链表」实现。使用「数组」实现的栈，删除和添加元素发生在数组的末尾；使用「链表」实现的栈，删除和添加元素发生在数组的开头；

Java中一般有两个实现类去实现栈，分别是`LinkedList`、 `ArrayDeque`<font color=red>（注意是ArrayDeque不是ArrayQueue）</font>。他们都可以作为栈的实现类，内部均有上面的方法。目前刷题来看，很多题解里使用`LinkedList`居多，但其实`ArrayDeque `是比 `LinkedList `快的

```Java
LinkedList<Integer> stack = new LinkedList<>();
ArrayDeque<Integer> stack = new ArrayDeque<>();
```



### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)

有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。

```
输入：s = "()[]{}"
输出：true
输入：s = "()[{}]"
输出：true
输入：s = "([)]"
输出：false
```



**方法一：栈**

创建一个栈，遍历整个字符串，对每一个字符进行如下操作：若为左括号，则往栈中存放对应的右括号。

若为右括号，则取出栈顶元素，并判断二者是否一样，一样则继续，不一样则返回false（当然每一步判断之前要先判断栈是否为空，为空也返回 false，之后才能判断取出的栈顶元素）。这是利用了有效括号的配对信息和位置信息

最后返回栈是否为空的状态，为空返回 true 表明所有括号都配对成功， 不为空返回 false，还有剩余的括号没配对好。

```Java
class Solution {
    public boolean isValid(String s) {
        ArrayDeque<Character> stack = new ArrayDeque<>();
        for(char c:s.toCharArray()){
            if(c == '('){
                stack.push(')');  
            } else if(c == '['){
                stack.push(']');
            } else if(c == '{'){
                stack.push('}');
            // 先判定栈是否为空，为空立刻返回fasle，不为空才判断和弹出的栈顶元素是否相等，利用了||的短路特性
            } else if(stack.isEmpty() || c != stack.pop()){
                return false;
            }
        }
        return stack.isEmpty(); // 返回栈是否为空的状态
    }
}
```

时间复杂度：O(n)，空间复杂度：O(n)（栈中的字符数量为 O(n)）

注意点：`s.toCharArray() `这个方法容易忘掉，迭代for循环方式也是字符串里常用的，多练习



**本题扩展一：**阿里面试，问“左括号必须以正确的顺序闭合”，这个条件去掉如何实现。

个人思路，左括号不管顺序的话，意味着只要统计左右括号个数是否相等即可，可以用map。碰到左括号，往里加右括号，个数+1。碰到右括号，将其-1，最后看map里三个括号的个数是否为0。简单来说就是不用栈的先进后出性质了，因为对顺序没有要求



**本题扩展二：**面试考了一个变形版的，要求必须按 { [ ( 的顺序进行关闭，可以有连续的左括号或者右括号。

思路：可以给这三种括号分别赋值0,1,2表示等级，新开一个栈，按照括号顺序往里加，比如`{[()]}`，那新栈往里加的就是012，然后弹出的时候看当前闭合的括号等级是否会高于之前闭合的等级，高于就就return false



### 155. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。



**方法一：两个栈**

这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的辅助栈的具体操作流程如下：

1. 将第一个元素入辅助栈。
2. 新加入的元素如果大于辅助栈顶元素，那么新加入的元素就不处理。
3. 新加入的元素如果小于等于辅助栈顶元素，那么就将新元素入栈。
4. 主栈出栈元素不等于辅助栈顶元素，不操作。主栈出栈元素等于辅助栈顶元素，那么就将辅助栈顶元素出栈。

![2](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/155%E6%9C%80%E5%B0%8F%E6%A0%88-%E5%9B%BE%E8%A7%A3.png)

```Java
class MinStack {
    ArrayDeque<Integer> stack;     // 主栈
    ArrayDeque<Integer> minStack;  // 辅助栈

    public MinStack() {
        stack = new ArrayDeque<>();
        minStack = new ArrayDeque<>();
    }

    public void push(int val) {
        stack.push(val);         // 主栈正常push
        if(minStack.isEmpty()){  // 辅助栈为空，直接添加
            minStack.push(val);
        } else{                  // 辅助栈不为空，进行判断
            if(val <= minStack.peek()){
                minStack.push(val);
            }
        }
    }

    public void pop() {
        // 弹出时，主栈正常弹出，只有主栈弹出的元素和辅助栈顶元素相等，辅助栈才弹出
        // 注意如果用if(stack.pop().equals(minStack.peek()))，得用equals，不能用等号判断
        int pop = stack.pop();
        if(pop == minStack.peek()){  
            minStack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return minStack.peek();
    }
}
```

这个方法自己在写的时候，pop()方法中，用了 `if(stack.pop()==minStack.peek())`，两个是 Integer 类型，并且超过了整数常量池范围，所以哪怕值相等返回的也是false，得用 equals

时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。

空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。



**方法二：一个栈（不使用额外空间，需要掌握）**

只用一个栈也是可以的，需要额外维护一个当前最小值，存入当前 push 元素的同时，判断一下新元素是否比最小值小，小的话就更新最小值，并在新元素入栈之前，把之前的最小值再压一次进去，即**在更小值入栈之前，先入当前的最小值**。如果是更大的值，那就直接入栈	

出栈时，正常元素直接出，当出栈元素是最小元素时，把下一个元素也出栈并赋给最小值，以达到更新最小值的目的。

![1](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/155%E6%9C%80%E5%B0%8F%E6%A0%88-%E5%9B%BE%E8%A7%A31.png)

```Java
class MinStack {
    ArrayDeque<Integer> stack;
    int min;

    public MinStack() {
        stack = new ArrayDeque<>();
        min = Integer.MAX_VALUE;
    }
    
    public void push(int val) {
        if(val <= min){
            stack.push(min); // 如果当前值更小，就把之前的最小值添加进栈里保存
            min = val;       // 更新最小值
        }
        stack.push(val);
    }
    
    public void pop() {
        if(stack.pop() == min){  // 如果弹出的值是最小值，
            min = stack.pop();   // 那么将下一个元素也弹出，并更新为最小值
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min;
    }
}
```

时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。

空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时栈占用的空间为 O(n)。



**方法三：使用链表**

我们可以不用Java提供的栈，直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 Node 节点中增加一个 min 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 min 值即可。

```Java
class MinStack {
    class Node{
        int value;
        int min;
        Node next;
        Node(int x, int min){
            this.value = x;
            this.min = min;
            next = null;
        }
    }

    Node head;

    public MinStack() {
        head = null;
    }
     
    // 每次加入的节点放到头部！！！注意是头插，不是尾插
    public void push(int val) {
        if(head == null){
            head = new Node(val, val);
        } else{
            // 当前值和之前头结点的最小值较小的做为当前的 min
            Node newHead = new Node(val, Math.min(val,head.min));
            newHead.next = head;
            head = newHead;
        }
    }
    
    public void pop() {
        if(head != null){
            head = head.next;
        }   
    }
    
    public int top() {
        if(head != null){
            return head.value;
        }
        return -1;
    }
    
    public int getMin() {
        if(head != null){
            return head.min;
        }
        return -1;
    }
}
```

时间复杂度： O(1)。空间复杂度：O(n)



### 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
输入：s = "3[a2[c]]"
输出："accaccacc"  
```



**方法一：两个栈**

外层的解码需要等待内层解码的结果。先扫描的字符还用不上，但不能忘了它们。我们准备由内到外，层层解决`[ ]`，需要保持对字符的记忆，于是用栈保存信息。字符的“倍数”和字符本身都需要保存，所以可以构建两个栈。

入栈时机：遇到`[`。意味着要解决内部的人了，外部的数字和字母，去栈里等。

* 已经扫描的数字就是“倍数”，入数字栈暂存
* 已经扫描的字母入字符栈等待，括号里的解码完了，一起参与构建字符串。

出栈时机：遇到`]`。内层的扫描完了，两个栈的栈顶元素可以出栈了，共同参与子串的构建。

- 两个栈顶就是最近遇到的“倍数”和字母

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/394%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-%E5%9B%BE%E8%A7%A3.png" alt="QQ图片20220627152351" style="zoom:80%;" />

总结：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈（这个数字不一定是个位数），弹出一个字符串栈（这个字符串不一定是一个字母），比如图中示例改为"3[ab2[c]]"，碰到第一个右括号时弹出的数字是2，弹出的字符串是"ab"

```Java
class Solution {
    public String decodeString(String s) {
        ArrayDeque<Integer> multiStack = new ArrayDeque<>();
        ArrayDeque<StringBuilder> strStack = new ArrayDeque<>();
        int multi = 0;
        StringBuilder res =  new StringBuilder();
        for(char c : s.toCharArray()){
            if(c >= '0' && c <= '9'){ // 如果是数字就临时存储，注意可能不仅为个位
                multi = c - '0' + multi * 10; 
            } else if(c == '['){      // 如果是左括号，把当前multi和res入栈，入完归零
                multiStack.push(multi);
                strStack.push(res);
                multi = 0;
                res = new StringBuilder();
            } else if(c == ']'){          // 如果是右括号，按照multistack弹出来的值重复拼接res
                int num = multiStack.pop();// 这里不要重复用 multi 这个变量，防止逻辑上出错
                StringBuilder temp = new StringBuilder();
                for(int i=0; i<num; i++){
                    temp.append(res);
                }
                res = strStack.pop().append(temp); // 和strStack弹出来的值合并，注意顺序
            } else{
                res.append(c);
            }
        }
        return res.toString();
    }
}
```

时间复杂度 O(N)，一次遍历 `s`；空间复杂度 O(N)，辅助栈在极端情况下需要线性空间，例如 `2[2[2[a]]]`。



**方法二：递归**

暂时没写



### 224. 基本计算器

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。s 由数字、'+'、'-'、'('、')'、和 ' ' 组成。[224. 基本计算器 - 力扣（LeetCode）](https://leetcode.cn/problems/basic-calculator/)

注意：'+' 不能用作一元运算（例如， "+1" 和 "+(2 + 3)" 无效）；'-' 可以用作一元运算（即 "-1" 和 "-(2 + 3)" 是有效的）



**方法一：单栈**

本题目只有 `"+"`, `"-"` 运算，没有 `"*"` , `"/"` 运算，因此少了不同运算符优先级的比较；

对遍历到的字符做分情况讨论：

* 空格 ： 跳过

* 数字 ：从当前位置开始继续往后取，将整一个连续数字整体取出，加入 res

* +/- ：将符号sign分别设为1和-1，用于后面准备和res相乘

* `( ` ：碰到左括号需要把左括号前的计算结果 res 和符号 sign 保存到栈中，同时把 res 和 sign 初始化，准备先计算括号里的内容。比如 12 + (3 - 1) 那就是把12和+先保存起来，准备先计算(3-1)

* `)` ：碰到右括号代表小括号里的内容计算结束，准备和之前栈里的进行计算，先弹出符号sign，再弹出结果res

    

```java 
class Solution {
    public int calculate(String s) {
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        int res = 0, sign = 1;
        int length = s.length();
        for(int i=0; i<length; i++){
            char c = s.charAt(i);

            if(Character.isDigit(c)){
                int cur = c-'0';
                while (i + 1 < length && Character.isDigit(s.charAt(i + 1)))  // 防止越界
                    // 这里需要注意：一定是先得到i+1，再返回i+1，只能是++i
                    // 这里的 c-'0'最好加上括号，避免整型溢出
                    cur = cur * 10 + (s.charAt(++i) - '0');  
                res = res + sign*cur;
            } else if(c=='+'){
                sign=1;
            } else if(c=='-'){
                sign=-1;
            } else if(c=='('){
                stack.push(res);
                res = 0;
                stack.push(sign);
                sign = 1;
            } else if(c==')'){
                res = stack.pop()*res + stack.pop();
            }
        }
        return res;
    }
}
```



### 227. 基本计算器Ⅱ

给你一个字符串表达式 s ，s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开。请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。你可以假设给定的表达式总是有效的。所有中间结果将在 [-2^31^, 2^31^ - 1] 的范围内。表达式中的所有整数都是非负整数，且在范围 [0, 2^31^ - 1] 内，题目数据保证答案是一个 32-bit 整数

**说白了就是 +- × /，没括号**



**方法一：单栈**

没有括号的情况下，四则运算只需要保存每个数字及其前面的符号为一组，存到栈里就可以。拿字符串算式`1-12+3`为例，把一个运算符和数字组合成一对儿，也就是三对`+1`，`-12`，`+3`，把它们转化成数字，然后依次放到栈中。最后将栈中所有的数字求和，就是原算式的结果。因此遍历所有字符，如果是符号的话，就要看看上一个是什么符号，因为只有上一个符号才和前面这个数字是一对，比如例子里扫到了第一个-，判断上一个符号为+，就把+1入栈，扫到了后面的+，判断上一个符号为-，就把-12入栈

注意点：

* 不只遇到新的符号会触发入栈，当`i`走到的尽头（`i == s.size() - 1`），也应该将前面的数字和符号入栈

* **乘除法优先于加减法体现在，乘除法可以和栈顶的数结合，而加减法只能把自己放入栈**。

    拿字符串算式`2-3*4+5`为例，还是拆为`+2`，`-3`，`*4`，`+5`几对，遍历碰到+这个符号，判断上一个符号为×，就把栈里的-3弹出来，和4相乘，再压入栈中。除号类似

```Java
class Solution {
public int calculate(String s) {        
        // 保存上一个符号，初始为 +  务必注意是上一个符号，后面if判断里都是对上一个符号进行判断
    	char sign = '+';  
        Stack<Integer> numStack = new Stack<>();
        int num = 0, res = 0;
        for(int i = 0; i < s.length(); i++){
            char ch = s.charAt(i);
            if(Character.isDigit(ch)){
                num = num*10 + (ch - '0');  // 加括号防止整型溢出
            }
            if(!Character.isDigit(ch) && ch !=' ' || i == s.length()-1){
                // 务必注意：判断上一个符号
                switch(sign){
                    // 当前符号前的数字直接压栈
                    case '+': numStack.push(num);break;
                    // 当前符号前的数字取反压栈
                    case '-': numStack.push(-num);break;
                    // 数字栈栈顶数字出栈，与当前符号前的数字相乘，结果值压栈
                    case '*': numStack.push(numStack.pop()*num);break;
                    // 数字栈栈顶数字出栈，除于当前符号前的数字，结果值压栈
                    case '/': numStack.push(numStack.pop()/num);break;
                }                
                sign = ch;  // 更新符号：记录当前遍历到的符号                
                num = 0;    // 更新数字：清零
            }
        }
        while(!numStack.isEmpty()){  // 将栈内剩余数字累加，即为结果
            res += numStack.pop();
        }
        return res;
    }
}
```



### 232. 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

![232.gif](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/232%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[动画讲解：如何使用两个栈实现一个队列 - 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/solution/dong-hua-jiang-jie-ru-he-shi-yong-liang-6g7ub/)

用两个栈来模拟队列的特性，一个栈为入队栈，一个栈为出对栈。

当出队栈存在内容时，出队栈的栈顶，即为第一个出队的元素。

若出队栈无元素，我们的需求又是出队的话，我们就需要将入队栈的内容反序导入出队栈，然后弹出栈顶即可。

```java
class MyQueue {

    ArrayDeque<Integer> inStack;
    ArrayDeque<Integer> outStack;


    public MyQueue() {
        inStack = new ArrayDeque<Integer>();
        outStack = new ArrayDeque<Integer>();

    }
    
    // 向入队栈顶push元素
    public void push(int x) {
        inStack.push(x);

    }
    
    // 只要出队栈为空，就把入队栈的元素运过去，否则就返回出队栈顶元素
    public int pop() {
        if(outStack.isEmpty()){
            in2out();
        }
        return outStack.pop();
    }
    
    // 同上
    public int peek() {
        if(outStack.isEmpty()){
            in2out();
        }
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }

    // 核心思想：将入队栈顶的元素依次push到出队栈
    private void in2out(){
        while(!inStack.isEmpty()){
            outStack.push(inStack.pop());
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

时间复杂度：push() 时间复杂度是 O(1)；peek()/pop() 均摊时间复杂度是 O(1)，单步操作的最坏时间复杂度是 O(N)。
空间复杂度：空间复杂度是 O(N)，因为总的占用了 NN 个元素的空间。





### 单调栈

**什么时候用单调栈**

- 通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素
- 且要求 O(n) 的时间复杂度



### 739. 每日温度

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]

输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```



**方法一：单调栈**

题意：每个元素找到它右边第一个比它大的元素的位置，求它们的距离。

可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，将每次遍历到的元素压入栈，如果有一天的温度大于当前栈顶，就能够计算出索引距离。计算完索引距离后，把栈顶元素弹出。

注意计算索引距离并不一定是按照顺序的，如下图里的索引2对应的25，直到遍历索引6才能计算出距离，我们应该严格比较 当前遍历元素和栈顶元素的大小，进行计算，只要遍历元素比栈顶元素大，那么就能够计算出栈顶元素对应索引的索引距离



![739题解](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[【程序员的自我修养】739. Daily Temperatures - 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/solution/cheng-xu-yuan-de-zi-wo-xiu-yang-739-daily-temperat/)

```Java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] res = new int[len];
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        for(int i=0; i<len; i++){
            // 栈不为空并且当前元素大于栈顶元素
            while(!stack.isEmpty() && temperatures[i]>temperatures[stack.peek()]){
                int index = stack.pop();
                res[index] = i-index;
            }
            stack.push(i);
        }
        return res;
    }
}
```

时间复杂度： O(n)，该方法只需要对数组进行一次遍历，每个元素最多被压入和弹出堆栈一次

空间复杂度： O(n)



**方法二：单调栈**

单调栈的另一种解答，当前元素关注的是它**右边**的元素，选择从右遍历，先为最右的元素找目标元素，需要考察的右边元素由少到多。每次遍历的当前项需要入栈，在这之前，需要先做判断，如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小。此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-%E5%9B%BE%E8%A7%A31.png)

> 图源：[「手画图解」单调栈思路的形成+模板套路 - 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/solution/shou-hui-ti-jie-fang-da-guan-cha-dan-diao-zhan-si-/)

```Java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] res = new int[len];
        ArrayDeque<Integer> stack = new ArrayDeque<>();
        for(int i=len-1; i>=0; i--){
            while(!stack.isEmpty() && temperatures[i]>=temperatures[stack.peek()]){
                stack.pop();
            }
            res[i] = stack.isEmpty() ? 0 : stack.peek() - i;
            stack.push(i);
        }
        return res;
    }
}
```

时间空间复杂度同上。



这个题解对于单调栈的总结很不错

**单调递增栈会剔除波峰，留下波谷；单调递减栈会剔除波谷，留下波峰**

![image.png](https://pic.leetcode-cn.com/0051296ee260c55479a5dc139fedadc99d0ee32f30a7d27d216c4c4dcc51c7ad-image.png)

当前项向左找第一个比自己大的位置 —— 从左向右维护一个单调递减栈
当前项向左找第一个比自己小的位置 —— 从左向右维护一个单调递增栈
当前项向右找第一个比自己大的位置 —— 从右向左维护一个单调递减栈（本题）
当前项向右找第一个比自己小的位置 —— 从右向左维护一个单调递增栈





**方法三：暴力**

让 i 指向当前元素，j 扫描它的右边，找到比当前元素大的元素，记录 j-i，考察下一位，重复上述过程。

```Java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] res = new int[len];
        for(int i=0; i<len; i++){
            for(int j=i+1; j<len; j++){
                if(temperatures[j]>temperatures[i]){
                    res[i] = j-i;
                    break;
                }
            }
        }
        return res;
    }
}
```

时间复杂度 O(n^2^)



### 42. 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子下雨之后能接多少雨水。[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

![image-20220525211354394](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%9B%BE%E8%A7%A3.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```



**方法一：单调栈**







## 队列

队列（Queue）也是一种线性结构，**先进先出**（First In First Out, FIFO）。接口Queue 常用的队列方法如下表所示，刷题时经常会用到。由于刷题更注重逻辑，不希望抛异常，所以主要记住第二列的方法

|                    | **throw Exception** | **返回false或null** |
| ------------------ | ------------------- | ------------------- |
| 添加元素到队尾     | add(E e)            | boolean offer(E e)  |
| 取队首元素并删除   | E remove()          | E poll()            |
| 取队首元素但不删除 | E element()         | E peek()            |

其他常用的还有实现自Collection的方法：

* `int size()`：获取队列长度；
* `boolean isEmpty()`：判读队列是否为空

注意Queue在表示单端队列时没有removeFirst这种方法，它的removeFirst其实是poll()方法，自然也更没有removeLast，不是双端队列。

双端队列（接口Deque，继承自Queue）方法比较多，add/offer/remove/poll/peek等，并且都有对应的 First和Last

Java中关于队列的实现类，从继承图上能够看出，分别是`LinkedList`、 `ArrayDeque`<font color=red>（注意是ArrayDeque不是ArrayQueue）</font>。他们都可以作为队列的实现类，内部均有上面的方法。目前刷题来看，使用`LinkedList`居多。他们两也可以实现栈

```Java
// 单向队列，注意对比栈的构造函数
Queue<Integer> queue = new LinkedList<>();
Queue<Integer> queue = new ArrayDeque<>();
// 双端队列
Deque<Integer> deque = new LinkedList<>();
Deque<Integer> deque = new ArrayDeque<>();
```

虽然使用`LinkedList`居多，但要知道ArrayDeque 是比 LinkedList 快的。



### 239. 滑动窗口最大值  77

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```



**方法一：单调队列&& 双端队列**

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%9B%BE%E8%A7%A3.png" alt="image-20211203150704023.png" style="zoom:67%;" />

> 图源：[滑动窗口最大值 | 图解单调队列 | 最清晰易懂的讲解【c++/java】 - 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/solution/tu-jie-suan-fa-dan-diao-dui-lie-zui-jian-h012/)

如样例所示，nums = [1,3,-1,-3,5,3,6,7]，k = 3，我们输出[3,3,5,5,6,7] 。

最朴素的做法是模拟滑动窗口的过程，每向右滑动一次都遍历一遍滑动窗口，找到最大的元素输出，这样的时间复杂度是O(nk)。考虑优化，其实滑动窗口类似于数据结构双端队列，窗口向右滑动过程相当于向队尾添加新的元素，同时再把队首元素删除。其实我们可以发现，队列中没必要维护窗口中的所有元素，我们可以在队列中只保留那些可能成为窗口中的最大元素，去掉那些不可能成为窗口中的最大元素。

**如果新进来的数字大于滑动窗口的末尾元素，那么末尾元素就不可能再成为窗口中最大的元素了**，因为这个大的数字是后进来的，一定会比之前先进入窗口的小的数字要晚离开窗口，因此我们就可以将滑动窗口中比其小的数字弹出队列，于是队列中的元素就会维持从队头到队尾单调递减，这就是单调递减队列。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/239%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E5%9B%BE%E8%A7%A31.png" alt="image-20211203112818054.png" style="zoom:67%;" />

为了方便判断队首元素与滑动窗口的位置关系，队列中保存的是对应元素的**下标**。

思路过程：（梳理过程时，一定要注意区分队列和滑动窗口，如果k=3，窗口只能是个元素，队列可能有1、2、3个元素）

初始时单调队列为空，随着对数组的遍历过程中，每次插入元素前，需要考察两个事情：

1. **合法性检查：队头下标如果距离 i 超过了 k ，则应该出队。**

比如 k=3，队列里是 [1,2,3]，即下标为1、2、3的三个元素，现在 i 遍历到了4，4-1+1>3，表明下标为1的元素不应该在队列里了，要让他出队。毕竟遍历到下标为4时，长度为3的窗口最左边也只可能是2

2. **单调性维护：如果 nums[i] 大于或等于队尾元素下标所对应的值，则当前队尾再也不可能充当某个滑动窗口的最大值了，故需要队尾出队，始终保持队中元素从队头到队尾单调递减。**

比如队列里对应下标的元素是 [3, -1, -3]，现在新元素是 5，那么-3和-1都应该出队，因为后面的窗口里只要5在，-1和-3都不可能是最大值

3. 遍历一遍数组，队头就是每个滑动窗口的最大值所在下标。**注意要当滑动窗口的元素达到了k个，才可以将其加入答案数组中（注意不是看队列里的元素个数！！！**如果k=3，只要 i=2，则表示滑动窗口元素达到了3个）

```Java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        Deque<Integer> deque = new ArrayDeque<>();
        int[] res = new int[len-k+1];
        int j = 0;
        for(int i=0; i<len; i++){
            // 合法性检查：队首下标离i超过了k，队首元素就不应该在滑动窗口里，这里用if也可以
            while(!deque.isEmpty() && i-deque.peekFirst()+1 > k)
                deque.pollFirst();                   
            // 单调性维护
            while(!deque.isEmpty() && nums[i] > nums[deque.peekLast()])
                deque.pollLast();            
            deque.offer(i); // 当前遍历的元素插入队尾
            if( i >= k-1)   // i>=k-1表示窗口形成，把队首对应元素加到结果数组里
                res[j++] = nums[deque.getFirst()]; 
            
        }
        return res;
    }
}
```

时间复杂度： 每个元素最多入队出队一次，复杂度为O(n)。

空间复杂度：O(k)，队列中最多 k 个元素，因此队列使用的空间为 O(k)。



**方法二：优先队列**





### 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

queue1 为主队列，queue2 为辅助队列，当执行入栈操作时，先将当前元素放入queue2，再将queue1 的内容依次放到queue2 里，再交换2个队列，这样就能保证 queue1 始终为主队列并且新添加的元素始终在队列头部。其他操作对主队列执行即可。

![fig1](https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif)

> [用队列实现栈 - 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/)

```Java
class MyStack {
    Queue<Integer> queue1;
    Queue<Integer> queue2;

    public MyStack() {
        queue1 = new ArrayDeque<Integer>();
        queue2 = new ArrayDeque<Integer>();
    }
    
    public void push(int x) {
        queue2.offer(x);
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp; 
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

补充：用一个双端队列实现栈。要是能够用pollLast和peekLast或者offerFirst那就太简单了，这里题目的意思还是只能访问队列首部的元素以及从尾部添加元素，即只能用 offerLast、pollFirst、peakFirst。只需要在pop时，将最后一个元素之前的所有元素移到最后一个元素之后。peek同理

```Java
class MyStack {
    Deque<Integer> deque;
    
    public MyStack() {
        deque = new ArrayDeque<>();
    }
    
    public void push(int x) {
        deque.offerLast(x);
    }
    
    public int pop() {
        int size = deque.size()-1; // 除最后一个值
        while (size-- > 0) {
            deque.offerLast(deque.peekFirst()); // 将前面的元素依次添加到后面
            deque.pollFirst();
        }
        return deque.pollFirst(); // 现在的第一个就是原来的最后一个
    }
    
    public int top() {
        int size = deque.size()-1; // 除最后一个值
        while (size-- > 0) {
            deque.offerLast(deque.peekFirst()); // 将前面的元素依次添加到后面
            deque.pollFirst();
        }
        return deque.peekFirst(); // 现在的第一个就是原来的最后一个
    }
    
    public boolean empty() {
        return deque.isEmpty();
    }
}
```



## 二叉树

二叉树的定义与力扣保持一致，要能写得出来

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

二叉树题型可以大概分为下面几类：

* 二叉树的遍历：
    * 前中后序遍历：94、144、145、226
    * 层序遍历：103、199、662

* 二叉树的属性，一般都是递归左右子树：104、559、111、101、100、110
* 二叉树的修改与改造：
* 二叉树的公共祖先：
* 二叉搜索树的属性：





二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历。大部分二叉树的题目最终都是归结到遍历操作上，因此针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。

#### 前中后序遍历（DFS）

递归和迭代两种方式都需要掌握，面试更多考察迭代遍历

##### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示。节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。

前序遍历： 每个节点都按照“**中**--左--右”（中在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做。例子顺序是 1 2 4 5 3 6 7

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        preOrder(root, res);
        return res;
    }

    private void preOrder(TreeNode node, List<Integer> res){
        if(node == null) return;
        res.add(node.val);           // 第一次碰到该节点，处理元素
        preOrder(node.left, res);  
        preOrder(node.right, res);
    }
}
```



中序遍历：每个节点都按照“左--**中**--右”（中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做。例子顺序是 4 2 5 1 6 3 7 

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inOrder(root,res);
        return res;
    }

    public void inOrder(TreeNode node, List<Integer> res) {
        if(node == null) return;
        inOrder(node.left,res);
        res.add(node.val);       // 第二次碰到该节点，处理元素
        inOrder(node.right,res);
    }
}
```



后序遍历：每个节点都按照“左--右--**中**”（中在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做。例子顺序是 4 5 2  6 7 3 1

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        postOrder(root, res);
        return res;
    }

    public void postOrder(TreeNode node, List<Integer> res) {
        if(node == null) return;
        postOrder(node.left, res);
        postOrder(node.right, res);
        res.add(node.val); // 第三次碰到该节点，处理元素
    }
}
```



##### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

**在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。**

**一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。**



前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (! stack.isEmpty()){
            root = stack.pop();
            res.add(root.val); // 处理元素
            if (root.right != null) stack.push(root.right);
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```



后序遍历

后序遍历的本质还是前序遍历，前序遍历是头左右，后序遍历是左右头，只需要调整一下前序遍历的顺序，设为头右左，再翻转一下res数组，就可以得到左右头。因为栈先入后出，所以应该先压左再压右。

观察下面的代码，与前序的差别就在于压栈顺序和翻转数组

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            root = stack.pop(); 
            res.add(root.val); // 处理元素
            if (root.left != null) stack.push(root.left);
            if (root.right != null) stack.push(root.right);
        }
        Collections.reverse(res); // 翻转数组
        return res;
    }
}
```



中序遍历

中序遍历和前序遍历不能通用，前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**而中序遍历是左中右，但先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈

* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

    ![1.gif](E:/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98.assets/47fff35dd3fd640ba60349c78b85242ae8f4b850f06a282cd7e92c91e6eff406-1.gif)

    > 图源：[动画演示+三种实现 94. 二叉树的中序遍历 - 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        ArrayDeque<TreeNode> stack = new ArrayDeque<>();
        // 这里的逻辑是合并起来写的，一方面希望栈不为空时，能弹出栈顶元素。另一方面又希望哪怕栈为空，但root不为空时，要能push进栈
        while(!stack.isEmpty() || root != null){ 
            while(root != null){ // 要写while，而不是if
                stack.push(root);
                root = root.left;
            }
            root = stack.pop(); // 弹出栈顶元素
            res.add(root.val);  // 处理元素
            root = root.right;  // 对弹出元素的右子树循环此操作，继续将左边界进栈            
        }
        return res;
    }
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。形成    左头 右（左头右）的循环结构

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png"  height=300>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" height=300>
</div>



##### Morris遍历

Morris遍历是一种遍历二叉树的方式，并且时间复杂度O(N)，**空间复杂度O(1)**，它通过利用原树中大量空闲指针的方式，达到**节省空间**的目的

这种方法的意义在于**面试时聊天**二叉树题目的优化，因为二叉树很多题目都和遍历紧密结合，前面递归方法是使用系统栈、迭代方法自己压栈，都使用了额外的空间，即二叉树的高度。而Morris遍历方法空间复杂度是O(1)，显然是一种优化。但由于其代码量更大，**思路也比较难，不适合在笔试时使用**（说白了就是难写出来）

遍历过程：

假设来到当前节点cur，开始时cur来到头节点位置，

* 如果cur没有左孩子，cur向右移动
* 如果cur有左孩子，找到左子树上最右的节点mostRight：
    * 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动 
    * 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动（说明rightMost.right曾经被修改过，我们这是第二次来到这个点，重新修改其为null，**说明该节点的左子树全部访问完毕**，所以此时**cur向右走**。）
* cur为空时遍历停止

（cur是真正有效的移动指针，它会走过所有的节点，rightMost是为了修改指针而存在的）

```Java
public static void morrisIn(Node head) {
    if (head == null) return;
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {          // cur为空时遍历停止
        
        // 如果cur有左子树
        if (mostRight != null) {
            mostRight = cur.left;      // 先找cur左子树         
            // 找左子树的最右节点mostRight，因为我们后续人为地将mostRight指向了空或者cur，所以此处要判断
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            
            // 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue; // while循环进入下一次
            } 
            
            // 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动，在第29行
            else {
                mostRight.right = null;
            }
        }
        
        // 如果cur没有左子树，cur向右移动
        cur = cur.right; 		
    }
    System.out.println();
}
```

其实不难发现，在这种遍历方式中，有些节点会访问两次，有些节点会访问一次。**因为我们有两个指针cur和rightMost，cur会走过所有的节点，rightMost会修改节点指向，使得cur重新访问到某个父节点。** 更具体的可以见这篇博客[Mirrors遍历]([(22条消息) 树（一）——Morris 二叉树神级遍历_yindarui的博客-CSDN博客_mirrors遍历](https://blog.csdn.net/qq_38684427/article/details/107708469))



#### 0102. 层序遍历（BFS）  201

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，按每一层的顺序打印。[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

与深度优先遍历非递归方式使用栈不同，宽度优先遍历主要使用队列来解决问题。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点）（队列是先进先出，所以先左再右），没有子节点就不放
* 循环

因为此题要用两层列表输出，所以需要知道每一层有多少个元素，其实也就是每次队列的长度。因为每一层节点弹出去之后，放进去左右节点，那么当前层所有节点都被弹出去之后，队列里剩下的就是下一层所有的节点。知道这个长度之后，加个for循环弹出当前层的元素个数，这也是层序遍历需要对每层操作的经典方式

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return res;
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> level = new LinkedList<>();         
            int n = queue.size(); // for循环弹出当前层的元素个数
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();  // 规范起见，这里不要用root=queue.poll()；
                level.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

也有很多力扣题目BFS是可以作为解法的（但不一定是最优解），例如：[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)、[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

层序遍历也有DFS方式，后面研究下

```Java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```



#### 0103. 二叉树的锯齿形层序遍历  178

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

和层序遍历一样，额外维护一个状态标志即可，主要是能想到list的add方法也是可以插在指定索引处的

```Java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return res;
        boolean isLeft = true;  // 状态标志
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> level = new LinkedList<>();
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                if(isLeft) level.add(cur.val); // 添加在列表尾部
                else level.add(0, cur.val);    // 添加在列表头部
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
            isLeft = !isLeft;  // 变化状态
        }
        return res;
    }
}
```



#### 0199. 二叉树的右视图  108

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

和层序遍历类似

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        Deque<TreeNode> deque = new ArrayDeque<>();
        if(root == null) return res;
        deque.offer(root);
        while(!deque.isEmpty()){
            int n = deque.size();
            for(int i=0; i<n; i++){
                TreeNode cur = deque.poll();
                if(cur.left != null) deque.offer(cur.left);
                if(cur.right != null) deque.offer(cur.right);
                if(i == n-1) res.add(cur.val);
            }
        }
        return res;
    }
}
```



#### 0662. 二叉树的最大宽度  45

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

注意：最大宽度并不是每层最多的节点个数

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

画个草稿能够得出，左子节点索引下标 = 父节点 × 2， 右子节点索引下标 = 父节点 × 2 + 1。

每轮层序遍历的循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标，比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        Deque<TreeNode> deque = new ArrayDeque<>();
        // 辅助队列/数组，由于后面要使用removeFirst()，List接口没有这个方法，得用LinkedList接口
        LinkedList<Integer> list = new LinkedList<>(); 
        deque.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值
        while(!deque.isEmpty()){          
            int n = deque.size();
            for(int i=0; i<n; i++){ 
                TreeNode cur = deque.poll();
                int curIndex = list.removeFirst(); // 弹出元素的下标用于添加下一层元素的下标
                if(cur.left != null){
                    deque.offer(cur.left);
                    list.offer(curIndex * 2);      // 添加子节点下标
                }
                if(cur.right != null){
                    deque.offer(cur.right);
                    list.add(curIndex * 2 +1);     // 添加子节点下标
                }
            }
            if(list.size() >= 2){  // 必须要确保list长度大于1才能用getLast，经常漏这个判断
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        return res;  // while循环结束，队列为空，res为最大宽度
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)



#### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转二叉树非常简单，不用想的太复杂，其实就是把每个节点的左右子节点交换而已，那么如何访问到每个节点自然是关键之处，还是使用各种遍历方法。前序、后序、层序都很简单。中序遍历会把某些节点的左右孩子翻转了两次，虽然可以通过代码避免，不建议使用（动笔写写画画就知道了）

前序递归遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

层序遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                swap(cur);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
        }
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```





#### xxxx. 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。

例如：N=1时，打印: down       N=2时，打印: down down up

本题考察的是二叉树的中序遍历，可以试着折两下子，发现每一次折都会在**最新的折痕上下位置**出现两个新的折痕，并且都是上面为down折痕，下面为up折痕，命名什么不重要，重点是二叉树的结构。打印的时候，从上往下打印，类似于二叉树的中序遍历

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98-%E5%9B%BE%E8%A7%A3.png" alt="image-20220420153749056" style="zoom:150%;" />

![image-20220420154722278](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98-%E5%9B%BE%E8%A7%A31.png)

其代码就是简单的中序遍历，左节点是down，右节点是up

```Java
class Solution {	
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	public static void printProcess(int i, int N, boolean down) {
		if (i > N) return;
		printProcess(i + 1, N, true);
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false);
	}
}
```



#### 0104. 二叉树的最大深度  71

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

解决此类递归问题，需要将目光聚焦于任意一个节点x为根的树，它的最大深度为什么。

针对此题能够得出：任意一个节点x为根的树其最大深度为左子树和右子树的最大深度 +1

```Java
class solution {
    public int maxdepth(treenode root) {
        if (root == null) return 0;
        int leftdepth = maxdepth(root.left);
        int rightdepth = maxdepth(root.right);
        return Math.max(leftdepth, rightdepth) + 1;
    }
}
// 或者简化为：
return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
```

时间复杂度：O(N)，空间复杂度O(N)，栈

或者也可以使用层序遍历，每一层记录高度+1

```Java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()){
            int n = queue.size();
            depth++;
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                if(cur.left!=null) queue.offer(cur.left);
                if(cur.right!=null) queue.offer(cur.right);
            }
        }
        return depth;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



#### 0559. N 叉树的最大深度  7

同样的逻辑也可以处理一下[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

```Java
class Solution {
    public int maxDepth(Node root) {
        if(root == null) return 0;
        int depth = 0;
        for(Node node: root.children){
            depth = Math.max(depth, maxDepth(node));
        }
        // 必须是每一个节点算完了所有子节点之后，才+1
        return depth+1;
    }
}
```



#### 0111. 二叉树的最小深度  16

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

针对此题能够得出：任意一个节点x为根的树其最小深度需要具体讨论，所有的情况都如下

* 如果其左右子树都为空，最小深度就是其自身，也就是1
* 如果其左子树为空，那么就是右子树的最小深度 +1
* 如果其右子树为空， 那么就是左子树的最小深度 +1
* 如果其左右子树都不为空，那就递归下去，是左右子树的最小深度 +1

其中第23种情况，第一反应有点难理解，左子树为空在草稿纸上可能习惯性的打一个箭头写null，但其实只是为了示意而已，实际上根本就没有左节点，这棵子树必须只能看它的右子树。如下图中的节点7，左子树为空，习惯性的打个箭头指向null，那么现在7为根的树，深度为多少？光看图还以为是2呢，以为是 7->null，但实际上左边压根就没有，只能算右子树，所以7为根的树，深度为3

![image-20220820124302312](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-%E5%9B%BE%E8%A7%A3.png)

按照上面四种情况的分析，写出来的代码为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int L = minDepth(root.left);
        int R = minDepth(root.right);
        if(root.left == null && root.right == null) return 1;
        if(root.left == null) return R+1;
        if(root.right == null) return L+1;
        return Math.min(L, R)+1;
    }
}
```

但显然前三种条件可以统一简化为：左右子树任一个子树为空。前三种的结果也可以统一化简为一个公式，即 leftDepth + rightDepth +1; 

因为第一种情况，左右子树最小深度就是0，公式结果为1；第二种情况，左子树深度为0，公式结果为 rightDepth + 1;  第三种情况，右子树深度为0，公示结果为 leftDepth + 1。 

因此代码可以化简为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int L = minDepth(root.left);
        int R = minDepth(root.right);
        if(root.left == null || root.right == null) return L + R +1;
        return Math.min(L, R)+1;
    }
}
```

虽然还可以用三元表达式进一步化简，但意义不大，可读性较差

同样的，此题也可以用层序遍历，在for循环外加上depth计数，for循环里加上判断，如果弹出的节点是叶子节点，直接返回depth即可，此时就是最小深度

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isEmpty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = deque.poll();
                 // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值
                if (poll.left == null && poll.right == null) return depth;
                if (poll.left != null) deque.offer(poll.left);
                if (poll.right != null) deque.offer(poll.right); 
            }
        }
        return depth;
    }
}
```



#### 0101. 验证对称二叉树  68

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

首先写写画画梳理正确的逻辑，才能写出正确的递归。此题显然是自顶向下的递归，对称，就是左右两边相等，也就是左子树和右子树相等。将每个节点的左子树记做 left，右子树记做 right。首先要比较 left 和 right 的值是否相等，不等的话直接返回false。相等的话继续比较外侧是否对称，即 left 的左子树 和 right 的右子树是否相等， 还要比较内侧是否对称，即 left 的右子树 和 right 的左子树是否相等， 都不出问题，才是对称。什么情况下出问题呢？分别是：两个节点中只有一个为空，肯定不对称；两个节点的值不相等，也肯定不对称。递归到什么程度就对称了，递归到左右节点都没有子节点了，即两个节点都为空了。

基于以上的逻辑再写递归，不要上来就按照三部曲写递归，逻辑都不清楚，写什么递归。

递归三部曲

1.确定递归函数的参数和返回值

​	因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。返回值自然是bool类型。

```Java
public boolean compare(TreeNode left, TreeNode right){}
```

2.确定递归终止条件

一定要先判断节点为空的情况，再判断数值是否相等，否则会出现空指针问题（这在二叉树里尤为重要）

- 左子树为空，右子树为空，对称，return true
- 左右子树只有一个为空，不对称，return false
- 左右子树根节点的值不相等，不对称，return false

同时也要注意，判断时可以写 if 或者 else if，但不能写else，因为还有情况是左右子树都不为空且左右子树根节点值相等的情况，但这种情况显然可能并没有递归到底，所以并不能作为终止条件

```Java
if (left == null && right == null) return true;
if (left == null || right == null) return false;
if (left.val != right.val)  return false;
```

3.确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右子树都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

整体代码如下：

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        //调用递归函数，比较左节点，右节点
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode left, TreeNode right){
        //递归的终止条件是两个节点都为空或者两个节点中有一个为空或者两个节点的值不相等
        if (left == null && right == null) return true;
        if (left == null || right == null) return false;
        if (left.val != right.val)  return false;
        // 比较外侧，即左节点的左孩子 和 右节点的右孩子
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧，即左节点的右孩子 和 右节点的左孩子
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
}
```

此题使用递归方法，自然也可以使用非递归方法，还是那个道理，递归是系统压入栈，我们自然可以自己实现栈（队列也可以），将需要比较的节点放入栈或队列，弹出后比较，弹出时再放入子节点

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null || (root.left==null && root.right==null)) return true;
        //用队列保存节点
        Queue<TreeNode> queue = new LinkedList<>();
        //将根节点的左右孩子放到队列中
        queue.offer(root.left);
        queue.offer(root.right);
        while(!queue.isEmpty()) {
            //从队列中取出两个节点，再比较这两个节点
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            //如果两个节点都为空就继续循环，两者有一个为空就返回false
            if(left==null && right==null) continue;  // continue + while循环 取代递归法中的递归终止条件
            if(left==null || right==null) return false;
            if(left.val!=right.val) return false;
            //将左节点的左孩子， 右节点的右孩子放入队列
            queue.offer(left.left);
            queue.offer(right.right);
            //将左节点的右孩子，右节点的左孩子放入队列
            queue.offer(left.right);
            queue.offer(right.left);
        }
        return true;
    }
}
```



#### 0100. 相同的树  16

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。[100. 相同的树](https://leetcode.cn/problems/same-tree/)

比上一题还简单

```java 
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null || q == null) return false;
        if(p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```



#### 0572. 另一棵树的子树

[572. 另一棵树的子树 - 力扣（LeetCode）](https://leetcode.cn/problems/subtree-of-another-tree/)



#### 0110. 验证平衡二叉树  73

给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

左程云介绍的递归套路，可以解决二叉树的树型DP问题，即可以通过从左右子树获取信息的方式来解决的问题

以本题为例，首先分析二叉树里，以任意一个节点x为根的树，需要什么样的条件，才能是平衡二叉树：

* 左子树是平衡二叉树
* 右子树是平衡二叉树
* | 左子树高度-右子树高度 | < 2

只有同时满足上述三个条件，x为根的树才能是平衡二叉树。那么现在x为根的树需要子树提供什么样的信息呢：

* 左子树提供是否是平衡二叉树、以及左子树的高度
* 右子树提供是否是平衡二叉树、以及右子树的高度

因为是递归，左右子树需要统一信息，即子树提供两个信息：子树提供是否是平衡二叉树、子树的高度，编写代码时将其作为单独的类封装起来，供递归调用

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 封装子树需要提供的信息
    public static class ReturnType {   
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

    public static ReturnType process(TreeNode x) {
        if(x == null) return new ReturnType(true,0); // 递归的base

        // 左右子树递归
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);

        // 递归所需信息的处理
		int height = Math.max(leftData.height, rightData.height) + 1; // 左右子树的最大高度加1
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;

        // 返回递归所需信息
        return new ReturnType(isBalanced, height);

    }
}
```

此思想的简化代码版本，来自力扣题解。核心思想是一致的，即构造一个获取当前节点最大深度的方法`depth(root)`，通过比较此子树的左右子树的最大高度差来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。

简单来说，就是将上面封装类中的isBalanced写为递归函数。

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

这个代码思想是自顶向下的递归，更优解是自底向上的递归，后续再整理

这道题后面也可以整理一下，还是聚焦于判断，一个根节点为x的二叉树，满足什么条件才是平衡二叉树，就和二叉树的最大深度、最小深度一样。想清除这个自顶向下的递归逻辑，就容易写出来，感觉左程云的套路还是稍微复杂了一点，虽然思想是一样的







#### 0112. 路径总和  62

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

总体思路：二叉树的递归遍历+回溯

targetSum 是从根节点到叶子节点的路径上的节点值相加的目标和，对 root 递归。转为判断：root 的左、右子树中能否找出和为 sum-root.val 的路径，这样就变成一个规模小一点的相同问题。即，每遍历一个节点，sum 就减去当前节点值，当遍历到叶子节点时，因为没有子节点了，如果 sum - 当前叶子节点值 == 0 ，即找到了从根节点到叶子节点的和为 sum 的路径。

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        // 遍历到叶子节点，如果当前剩下的targetSum-当前节点的val = 0，那就刚好返回true
        if(root.left == null && root.right == null) return targetSum-root.val == 0;
        // 不是上面的情况，则拆成两个子树的问题，其中一个true了就行
        if (root.left != null){
            // 这里不能直接写成 return hasPathSum(root.left,targetSum-root.val); 
            // 因为如果返回的false只是代表左子树可能没有，但右子树可能有，直接返回false就没考虑右子树
            boolean left = hasPathSum(root.left,targetSum-root.val);
            if (left) return true;
        }
        if (root.right != null){
            boolean right = hasPathSum(root.right,targetSum-root.val);
            if (right) return true;
        }
        return false;
    }
}
```

if (root.left != null) 处的注释需要格外关注，所以更好的写法是下满这种，|| 很好的解决了这种冲突，在二叉树左右子树的递归问题里很常见

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        // 遍历到叶子节点，如果当前剩下的targetSum-当前节点的val = 0，那就刚好返回true
        if(root.left == null && root.right == null) return targetSum-root.val == 0;
        // 不是上面的情况，则拆成两个子树的问题，其中一个true了就行
        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
    }
}
```

时间复杂度：O(n)，每个节点被遍历一次



#### 0113. 路经总和Ⅱ  67

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。[113. 路径总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum-ii/)

和上一题类似，只是本题需要将path记录下来，回溯做多了的话此题并不难

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new ArrayDeque<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root == null) return res;
        backTracking(root, targetSum);
        return res;
    }

    public void backTracking(TreeNode node, int targetSum){
        // 递归终止条件1
        if(node == null) return;
        // 递归终止条件2：叶子节点目标
        if(node.left == null && node.right == null && targetSum-node.val == 0){
            // 自己写的时候漏加了这一步的addLast和removeLast
            // 其实这一步满足条件只是判定了下，但还没有加进队列以及回溯出去，以后需要注意
            path.addLast(node.val);
            res.add(new ArrayList(path));
            path.removeLast();
            return;
        }
        // 单层递归，回溯左右子树
        path.addLast(node.val);
        backTracking(node.left,targetSum-node.val);
        backTracking(node.right,targetSum-node.val);
        path.removeLast();
    }
}
```

上面的单层递归里，还可以写成下面这样，但其实没必要，因为进入左右子树的path是一样的，左右子树递归到最后，总要回溯的，也就是总要调用removeLast()。写写画画就知道了

```Java
path.addLast(node.val);
backTracking(node.left,targetSum-node.val);
path.removeLast();		 // 其实和最后一行重复
path.addLast(node.val);  // 其实和第一行重复
backTracking(node.right,targetSum-node.val);
path.removeLast();
```



#### 0129. 求根节点到叶节点数字之和

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字：例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。计算从根节点到叶节点生成的 所有数字之和 。[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```



**方法一：dfs**

一种直观的方法是把所有的路径像113题一样，都放到res里，然后加起来，也比较简单，思路和113题一样

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new ArrayDeque<>();
    int ans = 0;
    public int sumNumbers(TreeNode root) {
        if(root == null) return 0;
        backTracking(root);
        for(List<Integer> list : res){
            int sum = 0;
            for(Integer num : list){
                sum = sum*10 + num;
            }
            ans += sum;
        }
        return ans;
    }

    private void backTracking(TreeNode node){
        if(node == null) return;
        if(node.left == null && node.right == null){
            path.add(node.val);
            res.add(new LinkedList(path));
            path.removeLast();
            return;
        }
        path.add(node.val);
        backTracking(node.left);
        backTracking(node.right);
        path.removeLast();
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)

但其实并不用这样，只要在递归的过程中，把和sum在递归中传递下去就可以

```Java
class Solution {
    public int sumNumbers(TreeNode root) {
        if(root == null) return 0;
        return dfs(root, 0);
    }

    public int dfs(TreeNode root, int preSum){
        if(root == null) return 0;
        int sum = preSum * 10 + root.val;
        if(root.left == null && root.right == null) return sum;
        return dfs(root.left, sum) + dfs(root.right, sum); // 左右节点都要加进去
    }
}
```



**方法二：bfs**

使用广度优先搜索，需要维护两个队列，分别存储节点和节点对应的数字。初始时，将根节点和根节点的值分别加入两个队列。每次从两个队列分别取出一个节点和一个数字，进行如下操作：

* 如果当前节点是叶子节点，则将该节点对应的数字加到数字之和
* 如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。

搜索结束后，即可得到所有叶子节点对应的数字之和。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/129%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C-%E5%9B%BE%E8%A7%A3.png" alt="631845faebc0c" style="zoom: 67%;" />

```Java
class Solution {
    public int sumNumbers(TreeNode root) {
        Deque<TreeNode> nodeDeque = new ArrayDeque<>();
        Deque<Integer> numDeque = new ArrayDeque<>();
        nodeDeque.offer(root);
        numDeque.offer(root.val);
        int sum = 0;
        while(!nodeDeque.isEmpty()){
            TreeNode cur = nodeDeque.poll();
            int num = numDeque.poll();
            if(cur.left == null && cur.right == null){
                sum += num;
            } else{
                if(cur.left != null){
                    nodeDeque.offer(cur.left);
                    numDeque.offer(num * 10 + cur.left.val);
                }
                if(cur.right != null){
                    nodeDeque.offer(cur.right);
                    numDeque.offer(num * 10 + cur.right.val);
                }
            }
        }
        return sum;
    }
}
```



#### 0124. 最大路径和

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 root ，返回其 最大路径和 。



#### 0297. 二叉树的序列化与反序列化

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。[297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)



**方法一：DFS**

序列化：递归的第一步都是特例的处理，因为这是递归的中止条件：按照先序遍历，如果根节点为空，返回”null“，序列化的结果为：根节点值 + "," + 左子节点值(进入递归) + "," + 右子节点值(进入递归)，递归就是不断将“根节点”值加到结果中的过程

反序列化：先将字符串转换成队列，接着也是前序遍历的递归，弹出左侧元素，即队列出队，如果元素为“null”，返回null，否则，新建一个值为弹出元素的新节点，其左子节点为队列的下一个元素，进入递归；右子节点为队列的下下个元素，也进入递归，递归就是不断将子树的根节点连接到父节点的过程

```Java
public class Codec {
    // 序列化
    public String serialize(TreeNode root) {
        if(root == null) return "X,"; // X表示为空节点,反序列化时要用","作为分隔符,所以要加上","
        String data = root.val + ","; // 前序遍历
        data += serialize(root.left);
        data += serialize(root.right);
        return data;
    }
    // 反序列化
    public TreeNode deserialize(String data) {
        // 或for循环遍历填入
        Deque<String> deque = new ArrayDeque<>(Arrays.asList(data.split(","))); 
        return dfs(deque);
    }
    public TreeNode dfs(Deque<String> deque){
        String val = deque.poll();
        if("X".equals(val)) return null; // 不能用val == "null"
        TreeNode node = new TreeNode(Integer.parseInt(val)); // 依然是前序遍历
        node.left = dfs(deque);
        node.right = dfs(deque);
        return node;
    }
}
```





**方法二：BFS**

维护一个队列，初始让根节点入列，考察出列节点：

* 如果出列的节点是 null，将符号 'X' 推入 res 数组。
* 如果出列的节点是数值，将节点值推入数组 res，并将它的左右子节点入列。

子节点 null 也要入列，它对应 "X"，要被记录，只是它没有子节点可入列。入列、出列…直到队列为空，就遍历完所有节点，res构建完毕，转成字符串就好。其实就是层序遍历

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root == null) return "";
        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode node = queue.poll();
            if(node == null) {
                sb.append("X,");
            }else{
                sb.append(node.val + ",");
                queue.offer(node.left);
                queue.offer(node.right);
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if(data == "") return null;
        Queue<String> stringQueue = new LinkedList<>(Arrays.asList(data.split(",")));
        Queue<TreeNode> nodeQueue = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.parseInt(stringQueue.poll()));
        nodeQueue.offer(root);
        while(!nodeQueue.isEmpty()){
            TreeNode node = nodeQueue.poll();
            String left = stringQueue.poll();
            String right = stringQueue.poll();
            if(!"X".equals(left)){
                node.left = new TreeNode(Integer.parseInt(left));
                nodeQueue.offer(node.left);
            }
            if(!"X".equals(right)){
                node.right = new TreeNode(Integer.parseInt(right));
                nodeQueue.offer(node.right);
            }
        }
        return root;
    }
}
```

这里引出来一个问题，<font color=red>需要向队列添加空节点时，用ArrayDeque作为Queue的实现类，会报空指针异常，而使用LinkedList就不会，</font>所以上面直接全用了LinkedList，详细分析可以见博客[向ArrayDeque和LinkedList添加null元素_linkedlist允许null](https://blog.csdn.net/weixin_50813961/article/details/124930369)



#### 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

说白了就是两个点往上，第一个在哪里汇聚，包括其中一个点是自身。



这道题还是用递归去解决，现在用以后一直贯穿的思想，递归三部曲：

（1） 递归函数的功能、返回值、参数类型

本题递归函数就是为了在树上找节点，主要目的有三个：对于给定两个节点 p 和 q，

* 如果 p 和 q 都存在，则返回它们的公共祖先；
* 如果只存在一个，则返回存在的一个；
* 如果 p 和 q 都不存在，则返回NULL

```Java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {}
```

（2）递归的终止条件

向下找一直找到了叶子节点，那肯定得返回。还有就是找到了p或者q节点，那这棵树一定返回 p 或者 q

```Java
if(root == null) return root;           //递归终止条件1：找完叶子节点
if(root == p || root == q) return root; //递归终止条件2：找到了p或q节点
```

（3）单层递归逻辑

若 root是 p, q 的 **最近公共祖先** ，则只可能为以下情况之一：

* p 和 q 在 root 的子树中，且分列 root 的异侧（即分别在左、右子树中）；
* p = root，且 q 在 root 的左或右子树中；
* q = root，且 p 在 root 的左或右子树中；

递归左右子树，**因为是递归，使用函数后可认为左右子树已经算出结果**，用 left 和 right 表示。若left为空，那最终结果只要看右子树返回；若 right为空，那最终结果只要看左子树返回（如果 left 和 right 都空其实也包含在这里面）。如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先

```Java
TreeNode left = lowestCommonAncestor(root.left,p,q);
TreeNode right = lowestCommonAncestor(root.right,p,q);
if(left == null) return right;
if(right == null) return left;
return root;  // if(left != null && right != null)
```



完整代码为：

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;           //递归终止条件1：找完叶子节点
        if(root == p || root == q) return root; //递归终止条件2：找到了p或q节点
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left == null) return right;
        if(right == null) return left;
        return root; // if(left != null && right != null)
    }
}
```



#### 235. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。



#### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
		LinkedList<Long> inOrderList = new LinkedList<>();
		process(root, inOrderList);
        long pre = Long.MIN_VALUE;
        for(long cur: inOrderList){
            if(pre >= cur) return false;
            pre = cur;
        }
        return true;
    }

    public static void process(TreeNode node, LinkedList<Long> inOrderList) {
        if (node == null) {
            return;
        }

        process(node.left, inOrderList);
        inOrderList.add((long)node.val); // 操作元素，注意转换
        process(node.right, inOrderList);
	}
}
```



解法二：在递归过程中，判断是否升序（**最佳**）

中序递归遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。其实也就是把中序遍历的打印操作换成一个判断操作

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        // 递归左子树
        if(!isValidBST(root.left)) return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if(root.val <= pre) return false;
        pre = root.val;
        
        // 递归右子树
        return isValidBST(root.right);
    }
}
```



解法三：在非递归过程中，判断是否升序

和解法二类似，都是在过程中判断是否升序，只不过换成了非递归的中序

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); 
               
                // 非递归遍历中加入的判断
                if(root.val <= pre) return false;
                else pre = root.val;

                root = root.right; 
            }
        }
        return true;
    }
}
```





#### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。





#### xxx. 寻找二叉树的后继节点

此题来自左程云算法课，没找到对应力扣，记录一下

现在有一种新的二叉树节点类型如下：

```Java
public class Node {
    public int value;
    public Node left;
    public Node right;
    public Node parent;
    public Node(int val) {
    	value = val;
    }
}
```

该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。
只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。**在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。**

分析：

本题返回的后继节点在平常自然可以通过二叉树的中序遍历找到，但时间复杂度为O(n)，但其实如果一个节点到后继节点的距离为k，**根据新结构**是可以得到时间复杂度为O(k)的设计。比如一棵二叉树为 1 2 3 4 5 6 7。中序遍历顺序为4 2 5 1 6 3 7

4到2树上的距离显然是1，不用中序遍历才能找到4的后继节点2，再比如5的后继节点是1，树上的距离为2，可以用O(2)的复杂度得到1，当然了这是建立在此题的二叉树新结构基础上。

就本题而言，任意一个节点x，其后继节点分为两种情况：

* x有右子树的时候，x的后继节点为右子树的最左叶子节点Y，从中序遍历的角度去想是不难的

    ![image-20220420104629607](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A3)

* x无右子树的时候，往上走看每个节点，看自己是不是父亲的左孩子，是的话，该节点Y就是x的后继节点。因为从节点Y看，x就是自己左树的最右子节点。其后继节点就是Y。不是的话，说明x就是整棵树的最右叶子节点，他的后继是空

    ![image-20220420105003143](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A31.png)

整体代码为：

```Java
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return node;
    }
    // 情况1：节点x有右子树，x的后继节点为右子树的最左叶子节点
    if (node.right != null) {
        return getLeftMost(node.right);
    } else {
        // 情况2：节点x没有右子树，向上遍历
        Node parent = node.parent;
        // 向上遍历停止的条件：
        //（1）遍历到空了，说明节点x是整棵树的最右叶子节点
        // (2) 发现了自己是父节点的左孩子
        while (parent != null && parent.left != node) {
            // 这两步是一直向上遍历
            node = parent;
            parent = node.parent;
        }
        // 此时的parent就是x节点的后继节点
        return parent;
    }
}

public static Node getLeftMost(Node node) {
    if (node == null) {
        return node;
    }
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```









## 哈希表

常用方法：

* put(key，value)：我们经常用存储一些常用的数据，比如flag、百分比之类的，我们就可以返回map结构，如果key相同则值会覆盖，允许key和value为null。
* get(key)：主要用来取map中存储的数据，我们根据其key值，可以取到对应的value值，没有该key对应的值则返回null。
* remove(key)：主要用来删除map中对应的key及其value值。
* clear()：会清空map中的数据。
* containsKey(key)，判断map集合中是否包含某个key。
* containsKey(value)，判断map集合中是否包含某个value。
* entrySet()：hashmap.entrySet().iterator()，entrySet()的效率比keySet()要高。key和value存储在entry对象里面，遍历的时候，拿到entry对象就可以取到value了。
* keySet()：hashmap.keySet().iterator()，keySet是把key放到一个set集合中，通过迭代器遍历，再用hashmap.get(key)来取到value的值。



### 1. 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。 [1. 两数之和 - 力扣](https://leetcode.cn/problems/two-sum/)

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```



**方法一：哈希表**

两数之和问题，有序双指针，无序哈希表。

这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n^2)，由于哈希查找的时间复杂度为 O(1)，所以可以利用哈希容器 map 降低时间复杂度遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值。如果存在则找到了两个值，如果不存在则将当前的 (nums[i], i) 存入 map 中，继续遍历直到找到为止

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (map.containsKey(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
}
```

时间复杂度：O(N)，其中 N 是数组中的元素数量。

空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销



### 41. 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/)

```
输入：nums = [1,2,0]        输出：3
输入：nums = [3,4,-1,1]     输出：2
输入：nums = [7,8,9,11,12]  输出：1
```



本题的难点在只能使用常数级别的额外空间和O(n)的时间复杂度

1. 方法一：使用哈希表，先把这个数组中所有的元素放进哈希表，我们只需从最小的正整数 1 开始，依次判断 2、 3 、4 直到数组的长度 *N* 是否在哈希表中，如果当前考虑的数不在这个数组中，我们就找到了这个缺失的最小正整数；这种方法时间复杂度：O(N)，空间复杂度O(N)
2. 方法二：先排序，然后从第一个数开始遍历，找第一个突变的数，即不连续的数。这种方法时间复杂度：O(NlogN)，空间复杂度O(1)



**方法三：将数组视为哈希表**

注意看题意，找的是没有出现的最小正整数，那说白了就是从1开始找，找到 len+1为止，毕竟数组长度摆在那里，（数组长度为2，那么其实就是找1、2、3）。所以我们要找的数就在 `[1, len + 1]` 里，最后 `len + 1` 这个元素我们不用找。因为在前面的 `len ` 个元素都找不到的情况下，我们才返回 `len + 1`；

那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。

比如nums = [3,4,-1,1] ，用上述思想哈希完之后，会变成 [1,-1,3,4]，要注意当i=1时，交换了2次

![image-20220808123649580](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-%E5%9B%BE%E8%A7%A3.png)

原地哈希就相当于，让每个数字n都回到下标为n-1的家里。而那些没有回到家里的要么是根本就没有自己的家（数字小于等于0或者大于nums.size()），要么是自己的家被别人占领了（出现了重复）。这些流浪汉被临时安置在下标为i的空房子里，之所以有空房子是因为房子i的主人i+1失踪了（数字i+1缺失）。因此通过原地构建哈希让各个数字回家，我们就可以找到原始数组中重复的数字还有消失的数字。

```Java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int len = nums.length;
        for(int i=0; i<len; i++){
            // 满足正数且小于len的数字，并且没有放在正确位置上的数进行交换
            while(nums[i]>0 && nums[i]<len && nums[nums[i]-1] != nums[i]){
                // 交换完之后前面已经处理的数字放到了后面，交换过来的数还没有处理，所以这里用while
                // 即可能处理多次，而不是用if只处理一次
                swap(nums, nums[i]-1, i);
            }
        }
        for(int i=0; i<len; i++){
            if(nums[i] != i+1) 
                return i+1;
        }
        return len+1; // 都正确则返回数组长度+1
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



### 128. 最长连续序列

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```



**方法一：哈希表**

最朴素的思想是排序，但要求时间复杂度为O(n)，显然要拿空间换时间，可以把数组所有元素放入哈希表中。也刚好可以实现去重，重复元素显然是不影响最后结果的

现在要查找一个`x`, `x+1`, `x+2`,,,, `x+y`的连续序列，为了避免重复枚举一段序列，即确保以`x`为起点向后枚举，而不是从`x+1`,`x+2`,,,向后枚举。如何确保呢？其实只需要每次在哈希表中检查是否存在 `x−1`即可。如果`x-1`存在，说明当前数`x`不是连续序列的起始数字，我们跳过这个数。具体过程如下：

1. 定义一个哈希表hash，将nums数组中的数都放入哈希表中。
2. 遍历哈希表hash，如果当前数x的前驱x-1不存在，我们就以当前数x为起点向后枚举。
3. 假设最长枚举到了数y，那么连续序列长度即为y-x+1。
4. 不断枚举更新答案。

```Java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> hashset = new HashSet<>();
        for(int x : nums) hashset.add(x); // 先添加所有元素到哈希表
        int res = 0;
        for(int x : hashset){
            if(!hashset.contains(x-1)){  // 哈希表里没有x-1才以x开始遍历
                int y = x;               // 新变量从x开始  
                while(hashset.contains(y+1)){ // 有y+1则继续遍历，知道没有y+1
                    y++;
                }
                res = Math.max(res, y-x+1); // 更新
            }
        }
        return res;
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)



### 349.两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。输入：nums1 = [1,2,2,1], nums2 = [2,2]   输出：[2]   [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

面试官可能会问：两个数组怎么求交集？时间复杂度多少？如果两个数组都是非递减的，又该怎么求，复杂度多少？对应下面的几种解法：

**方法一：使用集合**

先把num1中的所有元素全部添加到集合set1中，然后遍历nums2中的所有元素，判断在集合set1中是否存在，如果存在，说明有交集，就把他添加到集合resSet中，最后再把resSet转化为数组

```Java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> tempSet = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        // 把nums1中的元素全部加入到集合tempSet中
        for(int num:nums1){
            tempSet.add(num);
        }
        // 查看nums2中的元素是否存在集合tempSet中，如果存在就加入到集合resSet中
        for(int num:nums2){
            if(tempSet.contains(num)) {
                resSet.add(num);
            }
        }
        //下面一大坨是把集合reSet转换为数组
        int[] res = new int[resSet.size()];
        int i=0;
        for(int num:resSet){
            res[i++] = num;
        }
        return res;
    }
}
```

复杂度分析：

时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n)的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。即O(n)级别

空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。



**方法二：排序+双指针**

首先将数组排序，定义一个数组保存结果result

两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位。如果两个数字相等，且该数字不等于result的尾部元素，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。（这个逻辑很简单，自己画图看看就知道了）

```Java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        //先对两个数组进行排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        // 双指针一开始都指向0
        int i = 0;
        int j = 0;
        // 由于要不停添加元素，显然List更好用
        List<Integer> resList = new ArrayList<>();
        // 有一个指针越界就停止
        while(i<nums1.length && j<nums2.length){
            if(nums1[i] < nums2[j]){
                i++;
            } else if(nums1[i] > nums2[j]){
                j++;
            } else{ // nums1[i] == nums2[j]
                // 空集合要先加入元素，容易漏掉
                // 判断当前相等元素和集合最后一个元素是否相同，去重
                // 或者此处直接用集合就不用判断了 resSet.add(nums1[i]);
                if(resList.size()==0 || nums1[i] != resList.get(resList.size()-1)){
                    resList.add(nums1[i]);
                }
                i++;
                j++;
            }
        }
        //下面一大坨是把List转换为数组
        int[] res = new int[resList.size()];
        int k=0;
        for(int num:resList){
            res[k++] = num; 
        }
        return res;
    }
}
```

复杂度分析

时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。对两个数组排序的时间复杂度分别是O(mlogm) 和 O(nlogn)，双指针寻找交集元素的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)。因此如果算排序时间，就是O(nlogn)，不算排序就O(n)级别

空间复杂度：O(logm+logn)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于排序使用的额外空间。



方法三：排序+二分

先排序，for循环遍历一个数组的每一个元素，然后去另一个数组里用二分找这个元素，找到了就加到集合里，结束。

时间复杂度不算排序的话，貌似是O(m + logn)？



### 350.两个数的交集Ⅱ

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序



## 并查集



## 字典树Trie

### 208. 实现Trie  22

Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。请你实现 Trie 类：[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

Trie() 初始化前缀树对象。

void insert(String word) 向前缀树中插入字符串 word 。

boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。

boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 tru0e ；否则，返回 false 。



方法一：TrieNode 结构节点使用Map

```Java
class Trie {
    private class TrieNode{
        public boolean isWord;
        public TreeMap<Character,TrieNode> next = new TreeMap<>();
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode curNode = root;
        for(int i=0; i<word.length(); i++){
            Character c = word.charAt(i);
            if(curNode.next.get(c)==null)
                curNode.next.put(c,new TrieNode());
            curNode = curNode.next.get(c);
        }
        curNode.isWord = true; // 注意此处没有判断加入的单词是否重复
    }
    
    public boolean search(String word) {
        TrieNode curNode = root;
        for(int i=0; i<word.length(); i++){
            Character c = word.charAt(i);
            if(curNode.next.get(c)==null)
                return false;
            curNode = curNode.next.get(c);
        }
        return curNode.isWord;// 循环结束后是不能直接返回true的，他有可能不是一个单词的结尾
    }
    
    public boolean startsWith(String prefix) {
        TrieNode curNode = root;
        for(int i=0; i<prefix.length(); i++){
            Character c = prefix.charAt(i);
            if(curNode.next.get(c)==null)
                return false;
            curNode = curNode.next.get(c);
        }
        return true;
    }
}
```



方法二： TrieNode 结构节点使用长度为26的一维数组

题目没有特殊要求，所以可以直接使用26的TrieNode 数组作为每个节点的内容。虽然这种方式从通用性上来说局限很多，但也要作为一种方式了解，对比map的结构，其遍历索引的方式，都值得了解

```java 
class Trie {
    private class TrieNode{
        boolean isWord;
        TrieNode[] next = new TrieNode[26];
    }

    TrieNode root;

    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode curNode = root;
        for(int i=0; i<word.length(); i++){
            int index = word.charAt(i)-'a';
            if(curNode.next[index]==null)
                curNode.next[index] = new TrieNode();
            curNode = curNode.next[index];
        }
        curNode.isWord = true;
    }
    
    public boolean search(String word) {
        TrieNode curNode = root;
        for(int i=0; i<word.length(); i++){
            int index = word.charAt(i)-'a';
            if(curNode.next[index]==null)
                return false;
            curNode = curNode.next[index];
        }
        return curNode.isWord;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode curNode = root;
        for(int i=0; i<prefix.length(); i++){
            int index = prefix.charAt(i)-'a';
            if(curNode.next[index]==null)
                return false;
            curNode = curNode.next[index];
        }
        return true;
    }
}
```





# 排序

排序一般是基于数组的，练习题：[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)

我们常见的排序算法可以分为

* 基础排序：选择排序、冒泡排序、插入排序、希尔排序，其中插入排序很重要，希尔排序只需要知道思想；

* 归并排序和快速排序：非常重要，它们是理解「递归」的很好的学习材料；

* 堆排序暂时不涉及，放在优先队列进行介绍；

* 非比较排序：计数排序、基数排序、桶排序。它们不是绝大多数面试和笔试的考点。

他们的时间复杂度为：

| 算法     | 最好时间 | 最坏时间 | 平均时间        | 空间复杂度    | 原地   | 稳定性 |
| -------- | -------- | -------- | --------------- | ------------- | ------ | ------ |
| 选择排序 | O(n^2）  | O(n^2)   | O(n^2)          | O(1)          | 原地   | 不稳定 |
| 冒泡排序 | O(n）    | O(n^2)   | O(n^2)          | O(1)          | 原地   | 稳定   |
| 插入排序 | O(n）    | O(n^2)   | O(n^2)          | O(1)          | 原地   | 稳定   |
| 希尔排序 | O(nlogn) | O(n^2)   | O(nlogn)-O(n^2) | O(1)          | 原地   | 不稳定 |
| 归并排序 | O(n）    | O(nlogn) | O(nlogn)        | O(n)          | 非原地 | 稳定   |
| 快速排序 | O(n）    | O(n^2)   | O(nlogn)        | O(n)、O(logn) | 原地   | 不稳定 |
| 堆排序   |          |          |                 |               |        | 不稳定 |



归并排序：

* 归并排序的性能不受输入数据的影响，始终都是 O(nlogn) 的时间复杂度。但如果加了`if(nums[mid] > nums[mid+1])`的优化，对于完全有序数组就是O(n)复杂度
* 代价是需要额外的空间复制数组，空间复杂度O(n)
* 归并是非原地的、稳定的

快速排序：

* 快排版本比较多，但对于一般数据，这种分治、空间换时间的思想让他的平均时间复杂度为 O(nlogn)

    初始快排：对于近乎有序递归树高度变为n，O(n^2) 

    随机化快排：对于大量重复元素递归树高度变为n，O(n^2) 

    双路/三路快排：O(nlogn)，三路快排能够更好的解决大量重复元素，如果是元素完全相同的数组，三路快排时间复杂度为O(n)

* 快速排序的空间复杂度：最坏O(n)最好O(logn)   主要是递归栈的开销
* 快排是原地的、不稳定的



归并和快排的时间复杂度为什么是O(nlogn)？

[快速排序和归并排序的时间复杂度分析——通俗易懂 - 特务依昂 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tuyang1129/p/12857821.html)



排序算法的应用场景：

（1）从平均时间性能而言，快速排序最佳，其所需时间是最省，但快速排序在最坏的情况下的时间性能不如堆排序和归并排序。

（2）当空间大资源足，要求时间效率时，可采用归并排序。

（3）堆排序虽然较之快排慢一些，但特别适合海量数据的排序。如在100万个数据里面找出前1000大的数据。可以用建立一个小顶堆存储1000元素。

（4）当序列中的记录基本有序或n值较小，插入排序是最佳的排序方法。

（5）基数排序最适用于基数很大但关键字较小的序列。

稳定性：

* 稳定算法：插入，冒泡，归并，基数，计数。
* 不稳定算法：快速（快），希尔（些），选择（选），堆排（堆）。（可以用  **快些选一堆美女等你来玩**记忆，看别人博客学的）









## 基础排序

### 选择排序

在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。第一轮for循环遍历每个位置，内嵌第二轮for循环去未排序序列里寻找每个位置适合的元素

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=0; i<nums.length; i++){
            int minIndex = i;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]<nums[minIndex]) 
                    minIndex = j;
            }
            swap(nums,i,minIndex);
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



### 冒泡排序

n个数，需要比较n-1轮，每轮将最大（小）的数冒泡（交换）到后面，因为最后面的 i 个数已经排好序了，所以每轮要比较的次数在不断变少，为n-1-i

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=0; i<nums.length-1; i++){
            for(int j = 0; j<nums.length-1-i; j++)
                if(nums[j] > nums[j+1]) 
                    swap(nums,j+1,j);
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

优化：如果扫描一次剩下的元素发现没有元素需要交换，说明此时数组已经有序了，程序提前终止，那么对于完全有序的数组，它就成了O(n)复杂度。

代码里加上一个标志位 sorted 来解决，在外层for循环的条件上加上sorted，意为发生排序了才进行后面的循环。初始化时赋为true，以便进入循环，进行每层内循环前要先设为false，内循环里如果发生交换了，再设为true

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        boolean sorted = true;
        for(int i=0; i<nums.length-1 && sorted; i++){
            sorted = false;
            for(int j = 0; j<nums.length-1-i; j++)
                if(nums[j] > nums[j+1]) {
                    swap(nums,j+1,j);
                    sorted = true;
                }
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



### 插入排序

插入排序基本思想是把 nums[i] 插入有序数组 nums[0..i - 1]。有两种插入的方式：

（1）逐个交换：待插入元素逐个交换到前面，每次比较当前元素和前一个元素的大小，符合条件就交换，这种比较浪费时间，没写代码。

（2）先暂存再后移：先暂存待插入元素，然后将前面比暂存元素严格大的后移

![insertionSort](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/insertionSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif)

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        // 把 nums[i] 插入有序数组 nums[0..i - 1]，从nums[1]开始，nums[0]不用动
        for(int i=1; i<nums.length; i++){
            int temp = nums[i];  // 先保存nums[i]，通过索引j找到合适的位置再插入
            int j;				 // 索引j保存合适的位置，后面需要用到，不能放到for循环里初始化
            // 有索引j-1，j不能为0
            for(j=i; j>0 && nums[j-1]>temp; j--)  // 前面的元素比nums[i]大
                nums[j] = nums[j-1];              // 就将前面的元素后移
            nums[j] = temp;                       // 找到了合适的位置替换为nums[i]
        }
        return nums;
    }
}
```



**希尔排序**

希尔排序是 「**分组插入排序**」 或者 「**带间隔的插入排序**」。好处是：**让较小的元素一下子来到数组的前面**。

了解思想即可

**计数排序**

**基数排序**

**桶排序**



## 归并排序

归并排序与快速排序都是基于**分治思想**的排序算法。分治思想（分而治之）把一个规模较大的问题拆分成为若干个规模较小的相同类型的子问题，然后对这些子问题递归求解，等待每一个子问题完成以后，再得到原问题的解。分治算法可以并行执行，但是在基础算法领域，分治算法是以 **深度优先遍历** 的方式执行的。

动图演示：

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/mergeSort%E7%A4%BA%E6%84%8F%E5%9B%BE.gif" alt="mergeSort" style="zoom:80%;" />

归并数组：

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE.png" alt="image-20220213153723211" style="zoom:67%;" />

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        int[] temp = new int[nums.length];
        mergeSort(nums,0,nums.length-1,temp);
        return nums;
    }

    private void mergeSort(int[] nums, int left, int right, int[] temp){
        // if(right-left<=0) return;         // 只有1个元素或者没有元素，返回
        if(right-left<=15){                  // 优化一：小规模数组, 使用插入排序
            insertionSort(nums,left,right);
            return; // 总是忘记返回
        } 
        int mid = left + (right-left)/2;
        mergeSort(nums,left,mid,temp);
        mergeSort(nums,mid+1,right,temp);
        if(nums[mid] > nums[mid+1])         // 优化二：左半区大于右半区才需要合并
            merge(nums,left,mid,right,temp); 
    }

    private void merge(int[] nums, int left, int mid, int right, int[] temp){
        // 将nums中left开始的元素复制到temp中left开始的位置上，长度为r-l+1，这样就没有left的偏移量了
        // for (int i = left; i <= right; i++) temp[i] = nums[i];     
        System.arraycopy(nums,left,temp,left,right-left+1); // 复制的函数名容易写错，都是小写
        int i = left, j = mid+1;
        for(int k=left; k<=right; k++){
            if(i>mid){
                nums[k] = temp[j];
                j++;
            } else if(j>right){
                nums[k] = temp[i];
                i++;
            } else if(temp[i]<=temp[j]){
                nums[k] = temp[i];
                i++;
            } else{
                nums[k] = temp[j];
                j++;
            }
        }
    }

    private void insertionSort(int[] nums, int left, int right){
        for(int i = left+1; i<=right; i++){           // i的范围极容易写错
            int temp = nums[i];
            int j;
            for(j=i; j>left && nums[j-1]>temp; j--)   // j的范围极容易写错，不是j>0
                nums[j] = nums[j-1];            
            nums[j] = temp;
        }
    }
}
```



### 88. 合并两个有序数组  165

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。[88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```



**方法一：归并**

和归并操作的思想是一样的，用额外空间创建新数组，双指针遍历两个数组，注意题目nums1数组的特殊性，一个是越界时的判断，以及最后要把新数组复制到nums1里。代码略

时间复杂度：O(m+n)  空间复杂度：O(m+n)



**方法二：双指针逆序**

方法一之所以要使用额外数组，是担心将nums1前面的数覆盖了，观察nums1的特殊性，后面都是空的，所以可以设置3个双指针都从后面开始遍历

```Java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m-1, j=n-1;
        for(int k = nums1.length-1; k>=0; k--){
            if(i<0){
                nums1[k] = nums2[j];
                j--;
            } else if(j<0){
                break; // 我们是在nums1原地操作，nums1剩下的内容可以不动
            } else if(nums1[i] >= nums2[j]){
                nums1[k] = nums1[i];
                i--;
            } else{
                nums1[k] = nums2[j];
                j--;
            }
        }
    }
}
```

时间复杂度：O(m+n)  空间复杂度：O(1)



### 剑51. 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```
输入: [7,5,6,4]
输出: 5
```



**方法一：分治+归并**

分而治之，一边计算逆序对的总数，一边排序。

排序的作用：

- 排序以后消除逆序对，避免重复计算；
- 当前排序，为下一轮排序、为下一轮一下子数出逆序对的总数做好了基础。

合并两个有序数组时，每放回去一次右边的数temp[j]，左边从当前的i开始到mid，都与右边j所在的数构成逆序对

```java 
class Solution {
    public int reversePairs(int[] nums) {
        int[] copy = new int[nums.length]; // 复制一份数组，不改变原数组
        System.arraycopy(nums,0,copy,0,nums.length);
        int[] temp = new int[nums.length];
        return mergeSort(copy, 0, nums.length-1,temp);
    }

    private int mergeSort(int[] nums, int left, int right, int[] temp){
        if(right-left <= 0) return 0;
        int count = 0;
        int mid = left + (right-left)/2;
        count += mergeSort(nums, left, mid, temp);
        count += mergeSort(nums, mid+1, right, temp);
        if(nums[mid]>nums[mid+1]) 
            count += merge(nums, left, mid, right, temp);
        return count;
    }

    private int merge(int[] nums, int left, int mid, int right, int[] temp){
        System.arraycopy(nums,left,temp,left,right-left+1);
        int i = left, j = mid+1, count = 0;
        for(int k=left; k<=right; k++){
            if(i>mid){
                nums[k] = temp[j];
                j++;
            } else if(j>right){
                nums[k] = temp[i];
                i++;
            } else if(temp[i]<=temp[j]){
                nums[k] = temp[i];
                i++;
            } else{
                // 每计一次右边的数，左边从当前的i开始到mid，都与右边j所在的数构成逆序对
                count += (mid-i+1); 
                nums[k] = temp[j];
                j++;
            }
        }
        return count;
    }
}
```





## 快速排序

分治（减治）的思想

初始快排：对于近乎有序递归树高度变为n -> 随机化快排：对于大量重复元素递归树高度变为n ->  双路/三路快排

### 随机化快排

![image-20220215231243252](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%BF%AB%E6%8E%92%E6%9C%80%E5%88%9D%E7%89%88%E6%9C%AC%E5%8A%A9%E8%AE%B0%E5%9B%BE.png)

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right){
        // if(right-left <= 0) return;
        if(right-left <= 15) { // 优化一
            insertionSort(nums, left, right);
            return;
        }
        int pivotIndex = partition(nums,left,right);
        quickSort(nums,left,pivotIndex-1);  // 这里容易出错，上面是-1.下面是+1
        quickSort(nums,pivotIndex+1,right);
    }

    private int partition(int[] nums, int left, int right){
        int pivot = left + (new Random()).nextInt(right-left+1);  // 括号经常加错地方
        swap(nums,left,pivot);
        // 先写循环不变量：nums[left + 1..j] <= pivot, nums(j..i) > pivot
        int j = left; // 初始值定义不确定时，想想区间为空的情况，确保初始区间为空
        for(int i = left+1; i<=right; i++){ // 注意这里是<=right
            if(nums[i]<= nums[left]){
                j++;
                swap(nums,i,j);
            }
        }
        swap(nums,j,left);
        return j;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void insertionSort(int[] nums, int left, int right){
        for(int i = left+1; i<=right; i++){
            int temp = nums[i];
            int j;
            for(j=i; j>left && nums[j-1]>temp; j--) 
                nums[j] = nums[j-1];
            nums[j] = temp;
        }
    }
}
```

### 双路快排

面试时候一般写双路快排

![image-20220215232733122](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE2.png)

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right){
        // if(right-left <= 0) return;
        if(right-left <= 15) { // 优化一
            insertionSort(nums, left, right);
            return;
        }
        int pivotIndex = partition(nums,left,right);
        quickSort(nums,left,pivotIndex-1);
        quickSort(nums,pivotIndex+1,right);
    }

    private int partition(int[] nums, int left, int right){
        int pivot = left + (new Random()).nextInt(right-left+1);  // 随机化快排
        swap(nums,left,pivot);
        // 先写循环不变量：nums[left + 1..i) <= pivot, nums(j..right] > pivot
        int i=left+1, j = right; // 初始值要保证区间为空
        while(true){ // 两边判定都不能包含=，否则会把大量相同数据放置到一个半区
            while(i<=j && nums[i]<nums[left]) i++;
            while(i<=j && nums[j]>nums[left]) j--;
            if(i>j) break;
            swap(nums,i,j);
            i++;
            j--;
        }
        // nums[j]<=pivot，nums[i]>=pivot。退出循环有两种情况:(1)i和j重合，交换i，j都行
        // (2)j<i，只能交换j，因为nums[i]>=pivot，可能是个很大的数
        swap(nums,left,j);
        return j;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void insertionSort(int[] nums, int left, int right){
        for(int i = left+1; i<=right; i++){
            int temp = nums[i];
            int j;
            for(j=i; j>left && nums[j-1]>temp; j--) 
                nums[j] = nums[j-1];
            nums[j] = temp;
        }
    }
}
```



### 三路快排

三路快排省去了对重复元素的比较，对于大量重复元素，性能比双路快排要好

![image-20220215232900381](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8A%A9%E8%AE%B0%E5%9B%BE.png)

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }

    private void quickSort(int[] nums, int left, int right){
        // if(right-left <= 0) return;
        if(right-left <= 15) { // 优化一
            insertionSort(nums, left, right);
            return;
        }
        int pivot = left + (new Random()).nextInt(right-left+1);
        swap(nums,left,pivot);
        // 先写循环不变量：nums[letf+1,lt]<v, nums[lt+1,i-1]=v, nums[gt,right]>v
        int lt = left, i=left+1, gt=right+1; // 初始值要保证区间为空
        while(i<gt){
            if(nums[i]<nums[left]){
                lt++;
                swap(nums,lt,i);
                i++;
            } else if(nums[i]>nums[left]){
                gt--;
                swap(nums,gt,i);
            } else{
                i++;
            }
        }
        swap(nums,left,lt);
        quickSort(nums,left,lt-1); // 三路快排只需要对小于和大于pivot的部分递归
        quickSort(nums,gt,right);
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    private void insertionSort(int[] nums, int left, int right){
        for(int i = left+1; i<=right; i++){
            int temp = nums[i];
            int j;
            for(j=i; j>left && nums[j-1]>temp; j--) 
                nums[j] = nums[j-1];
            nums[j] = temp;
        }
    }
}
```



### 215. Top K问题  331

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)



**方法一：快排partition**

这题只是求第k大的元素，不用把整个数组都排序出来。快排的partition操作，是把一段数组分为小于pivot部分和大于pivot部分，我们只需要拿pivot所在的索引 j 和 k 比较即可。

```Java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int left = 0;
        int right = nums.length-1;
        int target = nums.length-k;   // 升序排列，所以第k大的元素索引是len-k
        while(true){
            if(right-left<=0) return nums[left]; // 越界判断，题目范围倒是不用这个判断，加上最好
            int pivotIndex = partition(nums,left,right);
            // pivotIndex等于target，找到目标值
            if(pivotIndex == target){
                return nums[pivotIndex];
            // 如果pivotIndex比target小，说明目标值一定在右半区，所以更新left
            } else if(pivotIndex < target){ 
                left = pivotIndex + 1;
            // 如果pivotIndex比target大，说明目标值一定在左半区，所以更新right
            } else if(pivotIndex > target){
                right = pivotIndex - 1;
            }
        }
    }

    // 随机化快排的partition操作
    private int partition(int[] nums, int left, int right){
        int randomIndex  = left + (new Random()).nextInt(right-left+1);
        swap(nums, randomIndex, left);
        int j = left;
        for(int i= left+1; i<=right; i++){
            if(nums[i] <= nums[left]){
                j++;
                swap(nums,i,j);
            }
        }
        swap(nums,left,j);
        return j;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

时间复杂度：O(N)，这里 N 是数组的长度。

> 快排的时间复杂度我觉得是T(n) = T(n/2) + n，首先不是一个完全的递归树，按照每次排序刚好定位到中间来想，递归树的下一层只有T(n/2)，不考虑另一半；其次，每一层递归树都要遍历对应的, "分而治之"的”分“后的数组长度，所以+n 这样来算用Master method，T(n) = aT(n/b) + f(n), f(n) = n,a=1,b=2, f(n) = Ω(n的 (以b为底a的对数 + x) 次方 )，x>0, 所以T(n) = O(f(n))=O(n)
>
> O(以n为首项，1/2为等比数列q的等比数列的和） = O（n）

空间复杂度：O(1)，在逐渐缩小搜索区间的过程中只使用到常数个变量。

>  说明：可能有一部分朋友看到这道题有「递归」的写法，但是本题解采用的是在 while (true) 循环中，通过 left 与 right 向中间靠拢的方式逐步缩小搜索区间，因此没有使用递归调用栈（也无须使用递归调用栈），因此空间复杂度是 O(1)



### 75. 颜色分类（荷兰国旗） 25

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。[75. 颜色分类 ](https://leetcode-cn.com/problems/sort-colors/)

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```



**方法一：三路快排partition**

参考三路快排的操作，将数组分为三个部分。三路快排是分为<v =v >v，此题是分为=0 =1 =2

```Java
class Solution {
    public void sortColors(int[] nums) {
        if(nums.length < 2) return;
        // [0,lt]=0, [lt+1,i)=1, [gt,right]=2
        int lt = -1, gt = nums.length, i = 0;
        while(i < gt){
            if(nums[i] == 0){
                lt++;
                swap(nums,lt,i);
                i++;
            } else if(nums[i] == 1){
                i++;
            } else if(nums[i] == 2){
                gt--;
                swap(nums,gt,i);
            }
        }
        return;
    }

    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

时间复杂度：O(N)，这里 N 是输入数组的长度      

空间复杂度：O(1)



## 堆排序 && 优先队列

暂时跳过

### 215. Top K问题

优先队列

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

时间复杂度：O(N logK)

虽然时间复杂度比快排partition高，但数据无法一次性读取时，优先队列是最优解



### 295. 数据流的中位数



### 347. 前 K 个高频元素





# 查找

## 二分查找

二分的思想会贯穿后面很多题型，例如回溯、dp等。二分思想的本质是减治，如果当前猜的数 `nums[mid]` 符合某个性质，我们还不能确定它一定就是我们要找的元素，必须向左边（或者向右边）继续看下去，才能确定 `nums[mid]` 是不是我们要找的元素。每一次排除掉一定不存在问题答案的区间，把 `left` 和 `right` 根据 `mid` 看到的值逐渐向中间靠拢，直到它们重合。



题型整理：

有序数组里二分求下标：704、34、35、4

非有序数组里二分：153、154、33、162

二分答案（在一个有范围的区间里搜索一个整数）：69、287





----------------------------------

以下是liweiwei的笔记，与目前自己整理的二分模板存在差别，需要仔细体会

怎么写「二分查找」，依然是得看问题问的是什么：

- 如果要找的元素性质简单，可以在循环体内决定，我写成 `while (left <= right)`，循环体内就可以返回
- 如果要找的元素性质稍微复杂，就需要要在退出循环体以后决定，我写成 `while (left < right)`，因为只要仔细的判断，完全可以清楚 `mid` 是否排除和下一轮向左边走还是向右边走。出现死循环的原因和解决办法我已经完全理解。我写的题解绝大多数都是这种写法，并且「力扣」上的问题绝大多数都是下面这类问题：

二分查找重点概括

写成 while(left < right) ，退出循环的时候有 left == right 成立，好处是：不用判断应该返回 left 还是 right；

区间 [left..right] 划分只有以下两种情况：

* 分成 [left..mid] 和 [mid + 1..right]，分别对应 right = mid 和 left = mid + 1；
* 分成 [left..mid - 1] 和 [mid..right]，分别对应 right = mid - 1 和 left = mid，这种情况下。需要将 int mid = (left + right) / 2 改成 int mid = (left + right + 1) / 2，否则会出现死循环，这一点不用记，出现死循环的时候，把 left 和 right 的值打印出来看一下就很清楚了；

退出循环 left == right，如果可以确定区间 [left..right] 一定有解，直接返回 left 就可以，否则还需要对 left 这个位置单独做一次判断；

始终保持不变的是：在区间 [left..right] 里查找目标元素。

------------------------------



### 704. 二分查找寻找一个数 108

### 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/)



**方法一：非递归**

循环不变量： 在`nums[left,right]`中查找。

```Java
int binarightySearightch(int[] nums, int tarightget) {
    int left = 0; 
    int right = nums.length - 1;  // 注意

    //循环不变量是在nums[left,right]中查找target
    while(left <= right) {        // 注意，left=right时区间仍不为空，nums[left]还需要判断
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1;       // 注意
        else
            right = mid - 1;      // 注意
    }
    return -1;       // 题型一：元素不在区间返回-1                     力扣704
    // return left;  // 题型二：元素不在区间返回按顺序插入的位置，即left   力扣35
}
```

其实对于35题来说，判断`nums[mid] == target`还可以省略，因为相等的情况会被放到else中，让right=mid-1，最后while循环结束后，left仍然会到mid的位置，return left仍然没有问题。即下面的代码35题也可以AC

```Java
int binarightySearightch(int[] nums, int tarightget) {
    int left = 0; 
    int right = nums.length - 1;  
    while(left <= right) {        
        int mid = left + (right - left) / 2;
        if (nums[mid] < target)
            left = mid + 1;      
        else
            right = mid - 1;      
    }
    return left;
}
```



改变循环不变量： 在`nums[left,right)`中查找。这里只是补充说明，面试没有特殊要求就用左闭右闭，否则徒增麻烦

```Java
int binarightySearightch(int[] nums, int tarightget) {
    int left = 0; 
    int right = nums.length;  // 注意，由于右边是开区间，所以要让r大一个

    //循环不变量是在nums[left,right)中查找target
    while(left < right) {         // 注意，由于右边是开区间，l=r已经为空，不能取=
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1;       // 左区间不变
        else
            right = mid;          // 注意，要搜索到mid-1这个数，因为右边是开区间，所以r要改成mid
    }
    return -1; 
}
```

注意：寻找一个数需要数组中无重复元素，且是有序数组



**方法二：递归**

思想是一样的，换个方式实现而已

```Java
class Solution {
    public int search(int[] nums, int target) {
        return search(nums,0, nums.length-1,target);
    }

    public int search(int[] nums, int l, int r, int target) {
        if (l>r) return -1;
        int mid = l + (r-l)/2;
        if (nums[mid]==target)
            return mid;
        else if (nums[mid]<target)
            return search(nums,mid+1,r,target);
        else 
            return search(nums,0,mid-1,target);
    }
}
```





### 34. 二分查找寻找左右侧边界 52

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```



**1. 寻找左侧边界**

寻找有重复元素的有序数组的target左侧边界，target不在数组中返回-1

还是原来的二分套路，当nums[mid]等于target时，让`right = mid - 1`，即不断更新右边界，向左收缩，因为mid已经确定是等于target了，所以我们要看他左边的数是不是等于target。

while循环终止时 left = right+1 , 由于区间是不断向左收缩的，最后的 right 已经到左边界的前一位了，因此返回 left ，或者返回  right +1。（头脑里想象：整个数组都是相同的数字，right不断向左二分移动，不断向左收缩，left不变，终止时 left = right+1，right在左边界前一位，返回左边界即返回left）

还需要考虑如果target 不在数组内的情况。上面逻辑返回的 left 不管target是否在数组内都是target按顺序应该插入的位置，那么如果 nums[left] 和 target 不等，则说明 target 不在区间内，即`if(nums[left] != target)`。但因为用到了数组值nums[left]的比较，所以**在这之前**需要对 left  进行检查，防止数组越界。left什么情况下会越界？由于寻找左侧边界的过程中，left只增不减，所以left最小就是0，不会再比0小了，左侧不会越界，但右侧可能会越界，需要判断`if (left >= nums.length)`，返回-1。

注意`if (left >= nums.length)`要放在`if(nums[left] != target)`之前判定，先保证不越界即语法没错，再判断逻辑

```java
public int LeftBound(int[] nums, int target){
    int left = 0;
    int right = nums.length - 1;
    // 循环不变量：在nums[l,r]中查找target目标值的左侧边界
    while (left <= right){
        int mid = left + (right-left)/2;
        if (nums[mid] == target)
            right = mid - 1; // 注意，寻找左边界的要点，不断更新右边界，向左收缩
        else if (nums[mid] < target)
            left = mid + 1;        
        else
            right = mid - 1;        
    }
    if (left >= nums.length || nums[left] != target)  // 注意顺序不能反，先判断越界再判断逻辑
        return -1;
    return left;
}
```

时间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度：O(1)



**2. 寻找右侧边界**

在`nums[l,r]`中查找target目标值的右侧边界

与左侧边界不同之处在于，当我们遇到目标值target时，向右进行偏移`left = mid + 1`.  终止时 left = right+1 ,由于区间是不断向右收缩的，最后的left已经到右边界的下一位了，因此返回right，或者返回 letf-1。（头脑里想象：整个数组都是相同的数字，left不断向右二分移动，不断向右收缩，right不变，终止时left = right+1，left在右边界下一位，返回右边界即返回right）

关于 target 是否在数组内的分析和左侧边界同理，rigth只有可能左侧出界，右侧不可能，判断完越界再判断target是否在数组里

```java
public int RightBound(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {    // 终止条件： left = right +1
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            left = mid + 1;  // 注意，寻找右边界的要点，不断更新左边界，向右收缩
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    if (right < 0 || nums[right] != target)   // 顺序不能反，先判断下标越界再判断是否在数组内
        return -1;
    return right; 
}
```



那么34题的解答方法为：

**方法一：分别找左右边界**

```Java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftbound = LeftBound(nums,target);
        int rightbound = RightBound(nums,target);
        return new int[]{leftbound,rightbound};
    }

    public int LeftBound(int[] nums, int target){
		...
    }

    public int RightBound(int[] nums, int target) {
		...
    }
}
```



**方法二：先找>=target的第一个 + 再找>target的第一个**

不过返回-1的逻辑就不能放在`LeftBound()`里了，`LeftBound()`里只能返回left，可以在主函数里设置

```Java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftbound = LeftBound(nums,target);
        int rightbound = LeftBound(nums,target+1)-1;
        if (leftbound >= nums.length || nums[leftbound] != target) 
            return new int[]{-1,-1};
        return new int[]{leftbound,rightbound};
    }
    public int LeftBound(int[] nums, int target){
		...
    	return left;
    }
}
```





### 4. 寻找两个正序数组的中位数 95

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请找出并返回这两个正序数组的中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

```java 
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }
            
            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}

```



### 153. 寻找旋转排序数组中的最小值  46

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]  若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。你必须设计一个时间复杂度为 O(log n) 的算法解决此问题

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)



**方法一：二分查找比较左边**

如果数组没有翻转，即 `nums[left] <= nums[right]`，则 `nums[left]` 就是最小值，直接返回。因为一旦有反转， `nums[left] 必定 > nums[right]`

如果数组翻转，需要找到数组中第二部分的第一个元素，首先二分得到mid

* 若 `nums[left] <= nums[mid]`，说明区间 `[left,mid]` 连续递增，则最小元素一定不在这个区间里，**可以直接排除**。因此，令 `left = mid+1`，在 `[mid+1,right]` 继续查找。
* 否则，说明区间 `[left,mid]` **不连续**，则最小元素一定在这个区间里。因此，令 `right = mid`，在 `[left,mid]` 继续查找（mid有可能是最小值，因此不能排除）

```Java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length-1;
        while(left<=right){
            if(nums[left] <= nums[right]) return nums[left];
            int mid = (left+right)/2;
            // 左半区有序，不会有最小值
            if(nums[left] <= nums[mid])  // 注意点1：包含等号
                left = mid+1;            // 注意点2：mid不可能为最小值索引
            // 左半区无序，必定有最小值
            else
                right = mid;             // 注意点3：mid可能为最小值索引
        }
        return -1;
    }
}
```

注意点1同33题的分析，由于mid计算整除向下取整，导致数组只有两个数时会判定错误，所以必须加上等号



**方法二：二分查找比较右边**

判断右边其实更简单点

```Java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length-1;
        while(left<=right){
            int mid = (left+right)/2;
            // 右半区无序，必定有最小值
            if(nums[mid] >= nums[right]) 
                left = mid+1;
            // 右半区有序，不会有最小值
            else
                right = mid; // mid可能为最小值索引
        }
        return nums[right];
    }
}
```





### 154. 寻找旋转排序数组中的最小值Ⅱ  12







### 33. 搜索旋转排序数组  166

整数数组 nums 按升序排列，数组中的值 互不相同 。在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```



**方法一：二分查找**

将题中的数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。找不到再去无序部分里找，将无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环。总之就是保证：永远在有序部分里二分查找，无序部分一直二分出有序的部分

```Java
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        if(len==0) return -1;
        int left = 0, right = len-1;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] == target) return mid;
            // [left,mid]有序
            if(nums[left] <= nums[mid]){    // 注意点1
                if(nums[left] <= target && target < nums[mid])   // 注意点2
                    right = mid-1; // target在左半区
                else 
                    left = mid+1;  // target在右半区
            } 
            // [mid,right]有序
            else{  
                if(nums[mid] < target && target <= nums[right]) 
                    left = mid+1;  // target在右半区
                else
                    right = mid-1; // target在左半区
            }
        } 
        return -1;
    }
}
```

其中有关等号的注意点：

注意点1：`if(nums[left] <= nums[mid])`此处必须要加上等号，才能保证左边是有序的，当数组里只有两个元素时，比如，nums=[3, 1], target=1, 由于整数除法的向下取整，导致 left = mid = 0，如果不加等号判定，那程序会认为 [mid, right] 即[0,1]有序，但实际上[3,1]是无序的。总结：由于整数除法的向下取整，要避免数组里只有两个元素的左半区判定问题。

注意点2：`target < nums[mid]`这里target没有必要加上等号，等于在前面就直接返回了，所以加上也不影响结果，逻辑严谨性上来说是不应该加的







### 162. 寻找峰值  50





### 69. x的平方根  93

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**方法一：二分查找**

```java
class Solution {
    public int mySqrt(int x) {
        if(x==0) return 0;
        int left=1,right=x;  // 也不用去管x/2，循环里可以解决

        while(left<=right){
            int mid = left+(right-left)/2; 
            if(mid == x/mid) // 防止整型溢出，改用除法
                return mid;
            else if(mid < x/mid)
                left = mid+1;
            else
                right = mid-1;
        }
        // right一定会停在mid*mid <= x的最大那个mid的位置，因为 mid*mid = x 的mid如果存在的话在上面就已经返回了，
        // 所以这里只需要返回right一定会停在mid就好了
        return right;
    }
}
```



### 287.  寻找重复数  22





## 双指针

双指针是解题中常用的思想，尤其是在数组中，能够解决很多问题

题型分类：

几数之和：167、15、16、18

应用问题：11、42（接雨水）

移动删除元素：283、27、26、80





### 167. 两数之和Ⅱ  13

给你一个下标**从 1 开始**的整数数组 numbers ，该数组已按非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

***有序双指针，无序哈希表，求两数和，时间复杂度都是o(n)***



**方法一：双指针（对撞指针）**

初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

```Java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i=0;
        int j=numbers.length-1;
        while(i<j){
            int sum = numbers[i] + numbers[j];
            if(sum < target){
                i++;
            } else if(sum > target){
                j--;
            } else{
                return new int[]{i+1,j+1}; // 下标从1开始
            }
        }
        return new int[]{-1,-1};
    }
}
```

时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。    空间复杂度：O(1)。



**方法二：二分搜索**

在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找。

代码略，不是最优解，了解思路即可

时间复杂度：O(nlogn)，其中 n 是数组的长度。需要遍历数组一次确定第一个数，时间复杂度是 O(n)，寻找第二个数使用二分查找，时间复杂度是 O(logn)，因此总时间复杂度是 O(nlogn)。    空间复杂度：O(1)



### 15. 三数之和  233

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组 [15. 三数之和](https://leetcode.cn/problems/3sum/)

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```



**方法一：双指针**

先将数组排序，用i遍历整个数组，设立left指针位于i下一位，right指针位于数组尾部，根据三数之和判定指针的移动。难点在于三处去重！

```Java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>(); // 后续用Arrays.asList，所以要用包装类
        Arrays.sort(nums);  // 先排序

        for(int i=0; i<nums.length; i++){
            if(nums[i]>0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if(i>0 && nums[i] == nums[i-1]) continue; // 去重，只能是i-1，i+1会越界
            int left = i+1, right = nums.length-1;    // 双指针
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum==0){
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left < right && nums[left] == nums[left+1]) left++;    // 去重
                    while(left < right && nums[right] == nums[right-1]) right--; // 去重
                    // 必须是先去重，再移动指针。保证当前位置已经if判定过，再跟相邻位置判断是否重复
                    // 先移动指针的话，移动后的那个位置可能还没判定就被 去重操作 移到下一个了
                    left++;
                    right--;
                }
                else if(sum<0) left++;
                else if(sum>0) right--;
            }
        }
        return res;
    }
}
```

时间复杂度：排序O(NlogN)+循环O(N^2) = O(N^2)

空间复杂度：排序需要使用O(logN)的空间。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums 的副本并进行排序，空间复杂度为 O(N)。




### 16. 最接近的三数之和 21

给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在恰好一个解。 [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/submissions/)

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```



**方法一：双指针**

思路：双指针，用一个变量result记录三数之和，如果新的三数之和离target更近，则更新result。由于本题只是返回和，所以不用考虑去重

```Java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int res = nums[0] + nums[1] + nums[2];
        for(int i=0; i<nums.length; i++){ 
            // 因为本题只要求返回三数之和即可，因此此处是否去重都可以
            if(i>0 && nums[i-1] == nums[i]) continue; //只为减少循环轮数，不能是i+1，会越界
            int left = i+1;
            int right = nums.length-1;
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                // 根据差值的绝对值来更新答案
                if(Math.abs(sum - target) < Math.abs(res - target)){
                    res = sum;
                }
                if(sum == target) return sum;
                else if(sum < target) left++;             
                else if(sum > target) right--;
            }
        }
        return res;
    }
}
```

时间复杂度：排序O(NlogN)+循环O(N^2) = O(N^2)

空间复杂度：排序需要使用O(logN)的空间。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums 的副本并进行排序，空间复杂度为 O(N)。



### 18. 四数之和 13

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

* 0 <= a, b, c, d < n
* a、b、c 和 d 互不相同
* nums[a] + nums[b] + nums[c] + nums[d] == target

你可以按 任意顺序 返回答案 

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```



方法一：双指针

先排序再双指针，注意四处去重！

```Java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();  // 要用包装类
        Arrays.sort(nums);  // 排序

        for(int i=0; i<nums.length; i++){
            if(i>0 && nums[i-1] == nums[i]) continue;        // 去重
            for(int j = i+1; j<nums.length; j++){
                if(j>i+1 && nums[j-1] == nums[j]) continue;  // 去重
                int left = j+1, right = nums.length-1;       // 双指针               
                while(left < right){
                    int sum = nums[i] + nums[j] + nums[left] + nums[right];
                    if(sum == target){
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while(left<right && nums[left+1]==nums[left]) left++;    // 去重
                        while(left<right && nums[right-1]==nums[right]) right--; // 去重
                        left++;
                        right--;
                    }
                    else if(sum < target) left++;
                    else if(sum > target) right--;
                }
            }
        }
        return res;
    }
}
```

时间复杂度：排序O(NlogN)+循环O(N^3) = O(N^3)

空间复杂度：排序需要使用O(logN)的空间。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了nums 的副本并进行排序，空间复杂度为 O(N)。





### 283. 移动零  39

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下**原地**对数组进行操作。[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

由于是原地操作，本题可以使用双指针解决

**方法一：双指针向前赋值非0元素**

我们创建两个指针 i 和 j，第一次遍历的时候指针 j 用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。第二次遍历的时候，起始位置就从 j 开始到结束，将剩下的这段区域内的元素全部置为0。

```Java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int j=0; // 额外指针
        // 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
        for(int i=0; i<nums.length; i++){
            if(nums[i] != 0){
                nums[j] = nums[i];
                j++; // 注意是赋值后+1
            }
        }
        for(int i=j; i<nums.length; i++){
            nums[i] = 0;
        }
    }
}
```

**方法二：双指针向后赋值0元素**

第一种方法是碰到非0元素就找到合适的位置（用 j 记录）覆盖掉原来的元素，相当于是向前赋值非0元素。还有一种是思想是碰到非0元素就和第一个0元素（还是用 j 记录）交换一下位置，相当于是将0元素不断向后移。

```Java
class Solution {
	public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
		int j = 0; // 额外指针
		for(int i=0;i<nums.length;i++) {
			//当前元素!=0，就把其交换到左边，等于0的交换到右边
			if(nums[i]!=0) {
				int tmp = nums[i];
				nums[i] = nums[j];
				nums[j++] = tmp;
			}
		}
	}
}
```

还有个优化是这里的交换没有必要真正的交换，很浪费时间，直接将第一个0元素位置赋值为当前的非0元素，然后非0元素那里赋值为0。注意防止非0元素的交换

```Java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int j = 0;
        for (int i = 0; i < length; i++) {
            if (nums[i] != 0) {  // 非0就右移j，所以除非都是非0，否则j总能指向第一个0
                if (i > j) {     // 防止都是非0的情况
                    nums[j] = nums[i];
                    nums[i] = 0;
                }
                j++;
            }
        }
    }
}
```





### 27.  移除元素  4

给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

**方法一：双指针**

```Java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums==null || nums.length==0) return 0;
        int j = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i] !=val ){
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
}
```





### 26. 删除有序数组中的重复项  26

给你一个 **升序排列** 的数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

解法：双指针

指针定义的指向不同，代码就不同，为了统一，建议将额外指针 j 指向待修改的元素，保持这个循环不变量，会更好解题。j<1时，直接覆盖并向右移，j>=1 时，就要比较当前遍历的元素和nums[j - 1] 处元素的大小了，谨记 j 始终指向待修改的位置。这里其实用增强for循环，能够更好的理解，数组中的元素反正是都要遍历一遍的，我们只需要关注 j 的位置就好

```Java
class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0; 
        for (int x : nums) {
            if (j < 1 || nums[j - 1] != x){
                nums[j] = x;
                j++;
            }
        }
        return j;
    }
}
```



### 80. 删除有序数组中的重复项Ⅱ  6

给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。[80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

为了扩展，直接写出使每个元素最多出现K次，和上题强调的一样，让 j 始终指向待修改的元素。j<k时，直接覆盖并向右移，j>=k 时，就要比较当前遍历的元素和nums[j - k] 处元素的大小了。这里其实用增强for循环，能够更好的理解，数组中的元素反正是都要遍历一遍的，我们只需要关注 j 的位置就好

```Java
class Solution {
    public int removeDuplicates(int[] nums) {   
        return process(nums, 2);
    }
    public int process(int[] nums, int k) {
        int j = 0; 
        for (int x : nums) {
            if (j < k || nums[j - k] != x){
                nums[j] = x;
                j++;
                // 或者nums[j++] = x;
            }
        }
        return j;
    }
}
```



### 11. 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

![image-20220525201934945](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%9B%BE%E8%A7%A3.png)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```



暴力法可以两轮for循环得到所有组合方式的面积，但复杂度较高。

**方法一：双指针+贪心**

首先让两个指针首先指向最两边的柱子，指针每一次移动，都意味着排除掉了一个柱子。

贪心思路：水的面积由 较短柱子的高度 和 柱子间距离 决定。现在指针移动意味着柱子间距离在减小，所以较短的那根柱子高度必须要增大，否则不会得到更大的面积，这就是贪心所在，即利用高度增加来弥补宽度减少的损失

所以**高度较矮的柱子不适合作为容器边界**，把它移走，看下一个柱子高度，直到两个指针重合

```Java
public int maxArea(int[] height) {
    int res = 0;
    int i = 0;
    int j = height.length - 1;
    while (i < j) {
        int area = (j - i) * Math.min(height[i], height[j]);
        res = Math.max(res, area);
        // 谁矮就移动谁
        if (height[i] < height[j]) {
            i++;
        } else {
            j--;
        }
    }
    return res;
}
```

时间复杂度：O*(*N)，双指针总计最多遍历整个数组一次。  空间复杂度：O(1)，只需要额外的常数级别的空间。

进一步的题目可以看看动态规划中的接雨水双指针解法





## 滑动窗口

滑动窗口的本质其实还是双指针，只不过是一个指针在前，一个在后，两个指针之间的元素符合题目的条件



想清楚「为什么可以使用滑动窗口」是更重要的；通常这样的原因基于题目中给出的关键信息，例如：「连续」「正整数」，并且题目 **只问最值**，并不要求得到的解，或者只要求写出一个解；



### 3. 无重复字符的最长子串  440

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。 [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```



**方法一：滑动窗口**

构造一个hashmap存储字符及其下标

* 首先，判断当前字符是否包含在map中，如果不包含，将该字符和下标添加到map，此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的 maxLen 比较，取最大值；

* 如果当前字符 ch 包含在 map中，此时有2类情况：

    *  当前字符包含在当前有效的子段中，如：abca，当我们遍历到第二个a，当前有效最长子段是 abc，我们又遍历到a，那么此时更新 left 为 map.get(a)+1=1，当前有效子段更新为 bca；
    * 当前字符不包含在当前最长有效子段中，如：abba，我们先添加a,b进map，此时left=0，我们再添加b，发现map中包含b，而且b包含在最长有效子段中，就是第一种情况，我们更新 left=map.get(b)+1=2，**此时子段更新为 b**，随后，我们遍历到a，发现a包含在map中，且map.get(a)=0，如果我们像第一种情况一样处理，就会发现 left=map.get(a)+1=1，实际上，left此时应该不变，left始终为2，子段变成 ba才对。

    为了处理以上2类情况，我们每次更新 left，left=Math.max(left , map.get(ch)+1)  。无论是否更新left，都要把hashmap里重复的字符更新为最新的索引

记住abca和abba这两个例子就能记住 left 的更新公式。总结：左指针遍历，右指针探测，加hash判重

```Java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0) return 0;
        HashMap<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        int left = 0;
        for(int i=0; i<s.length(); i++){
            if(map.containsKey(s.charAt(i))){
                left = Math.max(left, map.get(s.charAt(i))+1);
            }
            map.put(s.charAt(i),i);
            maxLen = Math.max(maxLen, i-left+1);
        }
        return maxLen;
    }
}
```

时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。

空间复杂度：O(∣Σ∣)，其中 Σ 表示字符集（即字符串中可以出现的字符）。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0,128) 内的字符，即 ∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 ∣Σ∣ 个，因此空间复杂度为 O(∣Σ∣)。

如果使用hashset，就得用两轮遍历，第二轮是从头开始移除set元素，直到end所在元素不重复，这种方法不如hashmap记住索引来的方便，更值得推荐

codetop评论：“字节今天考我这个，我就会一个滑动窗口，他让我用一次遍历过，我用的set 两次遍历，凉凉”，应该就是指的要用hashmap优化

```Java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max_len = 0, n = s.length();
        Set<Character> set = new HashSet<Character>();
        //2.定义窗口的首尾端（start，end），然后滑动窗口
        int start = 0;
        // int start = -1;
        for(int end = 0; end < n; end++){

            //3.更新需要维护的变量（max_len和HashSet）
            while(set.contains(s.charAt(end))){
                set.remove(s.charAt(start)); // 从头开始移除set元素，直到end所在元素不重复
                start++;
            }
            set.add(s.charAt(end));
            max_len = Math.max(max_len, end - start + 1);
        }
        return max_len;
    }
}
```

Follow-up：如果允许重复一次字符呢——微软-苏州-Lead面（2020.11.24） codetop评论区

[928 · 最多有两个不同字符的最长子串 - LintCode](https://www.lintcode.com/problem/928/description)

关联题目：340、395



### 340. 至多包含 K 个不同字符的最长子串 10

### 395. 至少有 K 个重复字符的最长子串 10





### 209. 和至少为 K 的最短子数组  39

给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```



**方法一：滑动窗口**

定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和。每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。

```Java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        if(nums.length == 0) return 0;
        int res = Integer.MAX_VALUE;
        int start = 0, end = 0;
        int sum = 0;
        while(end < nums.length){
            sum += nums[end];
            while(sum >= target){
                res = Math.min(res, end-start+1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return res == Integer.MAX_VALUE ? 0 : res; // 防止res没变过
    }
}
```

时间复杂度：O(n)，其中 n 是数组的长度。指针 start 和 end 最多各移动 n 次。主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是O(n)

空间复杂度：O(1)

follow-up：

（1）字节将target变为target的整数倍

（2）数组中有负数怎么办  [LeetCode 209. 长度最小的子数组（附：有负数时的解法） - 掘金 (juejin.cn)](https://juejin.cn/post/7091587949246021668/)



### 862. 和至少为 K 的最短子数组（有负数）  14

给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的子数组 ，返回 -1 。子数组 是数组中 连续 的一部分。[862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)

```
输入：nums = [2,-1,2], k = 3
输出：3
```



方法一：前缀和 + 单调栈+二分查找

有负数的情况，就不能用简单的滑动窗口来解决





### 560. 和为K的子数组  35

### 剑指 Offer 57 - II. 和为s的连续正数序列  9





### 76. 最小覆盖子串  72

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。如果 s 中存在这样的子串，我们保证它是唯一的答案。[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```



**方法一：滑动窗口**

用 left, right 表示滑动窗口的左边界和右边界，通过改变 left, right 来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，当这个窗口包含的元素满足条件，即包含字符串T的所有元素，记录下这个滑动窗口的长度 right- left + 1，这些长度中的最小值就是要求的结果。具体步骤如下：思考时用纸笔画画会更好

* 步骤一：不断增加 right 使滑动窗口增大，直到窗口包含了 t 的所有元素
* 步骤二：不断增加 left 使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值
* 步骤三：让 left 再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从**步骤一**开始执行，寻找新的满足条件的滑动窗口，如此反复，直到 right 超出了字符串S范围。

面临的问题：如何判断滑动窗口包含了T的所有元素？

我们用一个字典 need 来表示当前滑动窗口中需要的各元素的数量，一开始滑动窗口为空，用T中各元素来初始化这个need，当滑动窗口扩展或者收缩的时候，去维护这个need字典，例如当滑动窗口包含某个元素，我们就让need中这个元素的数量减1，代表所需元素减少了1个；当滑动窗口移除某个元素，就让need中这个元素的数量加1。那么如何判断滑动窗口包含了T的所有元素？结论就是当need中所有元素的数量都小于等于0时，表示当前滑动窗口不再需要任何元素。

记住一点：need始终记录着当前滑动窗口下，我们还需要的元素数量，我们在改变 left, right 时，需同步维护need。

优化：如果每次判断滑动窗口是否包含了 t 的所有元素，都去遍历need看是否所有元素数量都小于等于0，这个会耗费 O(k) 的时间复杂度，k代表字典长度，最坏情况下，k可能等于len(S)。其实这个是可以避免的，我们可以维护一个额外的变量 count 来记录所需元素的总数量，当我们碰到一个所需元素c，不仅need[c]的数量减少1，同时 count 也要减少1，这样我们通过 count 就可以知道是否满足条件，而无需遍历字典了。

![image-20220601220714230](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/76%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2-%E5%9B%BE%E8%A7%A3.png)

> 图源：[简简单单，非常容易理解的滑动窗口思想 - 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/)

一维数组版：

```java
class Solution {
    public String minWindow(String s, String t) {
        // 利用字符串t创建need数组
        int[] need = new int[128];
        for(int i=0; i<t.length(); i++){
            need[t.charAt(i)]++;
        }
        // size: 窗口的长度  start: 更新滑动窗口时记录起始位置，方便最后找子串用
        // count: 当次遍历中还需要几个字符才能够满足包含t中所有字符的条件，初始值为t的长度
        int left=0, right=0, size=Integer.MAX_VALUE, start=0, count=t.length();
        while(right < s.length()){
            char c = s.charAt(right);
            if(need[c] > 0) 
                count--; // t中包含当前遍历到的这个c字符，更新目前所需要的count数大小，应该减少一个
            need[c]--;   // 不管是否在t中，need数组中对应的计数都-1
            if(count == 0){ // count为0时，当前窗口包含了所有t的字符，步骤一完成，准备右移left
                while(left < right && need[s.charAt(left)] < 0){
                    need[s.charAt(left)]++; // 从窗口移出去了，计数+1
                    left++;                 // 步骤二：右移left，注意要先计数+1再left右移
                }
                if(right-left+1 < size){ // size更新才更新start,需要写进if里，不要用Math.min
                    size = right-left+1;
                    start = left;
                }
                // 步骤三：由于跳出来上面的while，此时再让left左移，不满足条件，进入下一轮右移right
                need[s.charAt(left)]++;
                left++;   // 注意要先计数+1再left右移
                count++;
            }
            right++;      // 步骤一
        }
        return size == Integer.MAX_VALUE ? "" : s.substring(start, start + size);
    }
}
```

时间复杂度是O(n)，空间复杂度为O(k)，k为S和T中的字符集合



map版：来源官方题解评论区关于labuladong的评论，思路是一样的。没细看

```Java
class Solution {
    public String minWindow(String s, String t) {
        //1.维护两个map记录窗口中的符合条件的字符以及need的字符
        Map<Character,Integer> window = new HashMap<>();
        Map<Character,Integer> need = new HashMap<>();//need中存储的是需要的字符以及需要的对应的数量
        for(char c : t.toCharArray())
            need.put(c,need.getOrDefault(c,0)+1);
        int left = 0,right = 0;//双指针
        int count = 0;//count记录当前窗口中符合need要求的字符的数量,当count == need.size()时即可shrik窗口
        int start = 0;//start表示符合最优解的substring的起始位序
        int len = Integer.MAX_VALUE;//len用来记录最终窗口的长度，并且以len作比较，淘汰选出最小的substring的len

        //一次遍历找“可行解”
        while(right < s.length()){
            //更新窗口
            char c = s.charAt(right);
            right++;//窗口扩大
            // window.put(c,window.getOrDefault(c,0)+1);其实并不需要将s中所有的都加入windowsmap，只需要将need中的加入即可
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    count++;
                }
            }
            //System.out.println****Debug位置
            //shrink左边界，找符合条件的最优解
            while(count == need.size()){
                if(right - left < len){//不断“打擂”找满足条件的len最短值,并记录最短的子串的起始位序start
                    len = right - left;
                    start = left;
                }
                //更新窗口——这段代码逻辑几乎完全同上面的更新窗口
                char d = s.charAt(left);
                left++;//窗口缩小
                if(need.containsKey(d)){
                    //window.put(d,window.get(d)-1);——bug：若一进去就将window对应的键值缩小，就永远不会满足下面的if，while也会一直执行，知道left越界，因此，尽管和上面对窗口的处理几乎一样，但是这个处理的顺序还是很关键的！要细心！
                    if(need.get(d).equals(window.get(d))){
                        count--;
                    }
                    window.put(d,window.get(d)-1);
                    
                }
            }
        }
        return len == Integer.MAX_VALUE ? "" : s.substring(start,start+len);
    }
}
```

也是map版：

```Java
class Solution {
    public String minWindow(String s, String t) {
        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();
        HashMap<Character,Integer> ht = new HashMap<Character,Integer>();
        for(int i = 0;i < t.length();i ++){
            ht.put(t.charAt(i),ht.getOrDefault(t.charAt(i), 0) + 1);
        }
        String ans = "";
        int len = Integer.MAX_VALUE, cnt = 0;  //有多少个元素符合
        for(int i = 0,j = 0;i < s.length();i ++)
        {
            hs.put(s.charAt(i), hs.getOrDefault(s.charAt(i), 0) + 1);
            if(ht.containsKey(s.charAt(i)) && hs.get(s.charAt(i)) <= ht.get(s.charAt(i))) cnt ++;
            while(j < i && (!ht.containsKey(s.charAt(j)) || hs.get(s.charAt(j)) > ht.get(s.charAt(j))))
            {
                int count = hs.get(s.charAt(j)) - 1;
                hs.put(s.charAt(j), count);
                j ++;
            }
            if(cnt == t.length() && i - j + 1 < len){
                len = i - j + 1;
                ans = s.substring(j,i + 1);
            }
        }
        return ans;
    }
}
```

> 来源：[最小覆盖子串 | 图解滑动窗口 | 最通俗易懂的讲解【c++/java版本】 - 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/solution/leetcode-76-zui-xiao-fu-gai-zi-chuan-cja-lmqz/)





## BFS





## DFS

### xxx. 汉诺塔问题

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。[面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

对于三个柱子A、B、C，A上有n个盘子，

* n = 1 时，直接把盘子从 A 移到 C；
* n > 1 时，
    * 先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
    * 再将最大的盘子从 A 移到 C；
    * 再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）

```Java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlant(A.size(),A,B,C);
    }

    //size 需要移动的盘子的数量、start 起始的柱子、other 辅助柱子、target 目标柱子
    public void movePlant(int size, List<Integer> start,List<Integer> other,List<Integer> target){
        //当只剩一个盘子时，直接将它从第一个柱子移动到第三个柱子
        if(size == 1){
            target.add(start.remove(start.size()-1));
            return;
        }
        //首先将 n-1 个盘子，从第一个柱子移动到第二个柱子
        movePlant(size-1,start,target,other);
        //然后将最后一个盘子移动到第三个柱子上
        target.add(start.remove(start.size()-1));
        //最后将第二个柱子上的 n-1 个盘子，移动到第三个柱子上
        movePlant(size-1,other,start,target);
    }
}
```





### 200. 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

![image-20220426231056043](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E5%9B%BE%E8%A7%A3.png)

本题属于网格类搜索问题，常用的方法都是DFS和BFS，同类型的还可以看回溯小节-79单词搜索

方法一：DFS

目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。设目前索引指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。从 (i,  j) 向此点的上下左右 (i+1, j)，(i-1, j)，(i, j+1)，(i, j-1) 做深度搜索。遍历遇到 1 即遇到土地，土地肯定在一个岛上，计数 +1。

注意：每次遍历需要把遍历过的1重新记为0，如果不把与它和同在一个岛的土地变成 0，则DFS遍历到它们时，会对一个岛重复计数。所以每次遍历都要将当前的 1 变 0（沉岛思想），当前坐标的上下左右依次递归，同处一个岛的 1 都变 0。

终止条件：

* (i, j) 越过矩阵边界;

* grid[i] [j] == 0，代表此方块已经被遍历过。

```Java
class Solution {
    public int numIslands(char[][] grid) {
        int res = 0;
        for(int i=0; i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == '1'){
                    dfs(grid,i,j);
                    res++;
                }
            }
        }
        return res;
    }

    private void dfs(char[][] grid, int i, int j){
        // 递归终止条件：越界、重复
        if(i<0||j <0 || i>=grid.length || j>=grid[0].length || grid[i][j] == '0'){
            return;
        }
        grid[i][j] = '0';     // 沉岛
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```



不过从工业界角度想，最好能够克隆一份grid，直接修改原始的数组不太好，面试看有没有机会提到吧，不是重点

```Java
int[][] copy = new int[m][n];
for(int i = 0;i < m;i++) {
    for(int j = 0;j < n;j++) {
        copy[i][j] = grid[i][j];
    }
}
```



方法二：BFS





### 695. 岛屿的最大面积

给你一个大小为 m x n 的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

![image-20220427102539142](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-%E5%9B%BE%E8%A7%A3.png)

**解法一：DFS**

解法同上一题，但每次遍历时，给为1的计数。一开始做这道题时，想到了思路，但是没写出来，没写出`num += dfs(...)`这种结构，还是写的太少了。

```Java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0; 
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {  // 注意改成了整型数组
                    res = Math.max(res, dfs(i, j, grid));
                }
            }
        } 
        return res;
    }

    private int dfs(int i, int j, int[][] grid) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) { 
            return 0;
        } 
        grid[i][j] = 0;  // 沉岛
        int num = 1;     // 默认num为1，进入后判断如果不是岛屿，则直接返回0
        num += dfs(i + 1, j, grid);
        num += dfs(i - 1, j, grid);
        num += dfs(i, j + 1, grid);
        num += dfs(i, j - 1, grid);
        return num;
        
    }
}
```









# 回溯

（二刷的时候整理好代码的变量名、方法名规范）

回溯算法是一种遍历算法，以 **深度优先遍历** 的方式尝试所有的可能性。有些教程上也叫**暴力搜索**。回溯算法是 **有方向地** 搜索，区别于多层循环实现的暴力法。

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案。

由于回溯和深度优先搜索有着千丝万缕的联系，因此也介绍下深度优先搜索

深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；具体实现起来，ArrayList、LinkedList等都可以实现

回溯算法与深度优先遍历都有不撞南墙不回头的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而深度优先遍历强调一种遍历的思想，不回退，与之对应的遍历思想是广度优先遍历。至于广度优先遍历为什么没有成为强大的搜索算法，后面会提。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。



一些精彩的描述：（整理差不多了之后，自己总结下）

回溯：在包含问题所有解的空间树中，用DFS的方式，从根节点出发，搜索整棵解空间树。

搜索至任何一个节点时，总是会先判断当前节点是否可以通往最后的合法解。如果不可以，则结束对「以当前节点为根节点的子树」的搜索，向父节点回溯，回到之前的状态，搜索下一个分支。否则，进入该子树，继续以DFS的方式搜索。

空间树中的节点是动态的，即，当前有哪些选项可选择，是根据上一步的选择得出的，所以做回溯时，要把状态还原成进入当前节点之前的状态。

确定出问题的解空间树，它是隐式的，不是显式的一棵树。不熟练的就画图看看。

然后，明确每个节点的扩展搜索规则。然后进行DFS搜索，并注意剪枝，避免无效的搜索。



> 另一段描述：
>
> 回溯算法是一种遍历算法，以 **深度优先遍历** 的方式尝试所有的可能性。有些教程上也叫**暴力搜索**。回溯算法是 **有方向地** 搜索，区别于多层循环实现的暴力法。
>
> 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
>
> * 找到一个可能存在的正确的答案；
> * 在尝试了所有可能的分步方法后宣告该问题没有答案。
>
> 由于回溯和深度优先搜索有着千丝万缕的联系，因此也介绍下深度优先搜索
>
> 深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。
>
> 回溯算法与深度优先遍历都有不撞南墙不回头的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而深度优先遍历强调一种遍历的思想，不回退，与之对应的遍历思想是广度优先遍历。至于广度优先遍历为什么没有成为强大的搜索算法，后面会提。
>
> 搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。



回溯的三个要素：选择（选项）、约束条件、目标。

我们关心当下有什么选择，作了一个选择之后，会怎么限制下一个选择。所以，不仅要关注选择（选项），还要关注约束条件。前者展开出一棵解的空间树，后者用来剪枝，剪去不能产生正确解的分支，避免无效搜索。第三个要素：目标（结束条件），明确了目标，就知道何时去将解加入解集。并且让你知道：搜索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。



回溯问题类型以及经典题型

| 类型       | 题目                                                         |
| ---------- | ------------------------------------------------------------ |
| 子集、组合 | [子集](https://leetcode-cn.com/problems/subsets/)、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)、[组合](https://leetcode-cn.com/problems/combinations/)、[组合总和](https://leetcode-cn.com/problems/combination-sum/)、[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |
| 全排列     | [全排列](https://leetcode-cn.com/problems/permutations/)、[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)、[字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)、[字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/) |
| 搜索       | [单词搜索](https://leetcode-cn.com/problems/word-search/)、[N皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)、[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/)、[解数独](https://leetcode-cn.com/problems/sudoku-solver/) |

有空做一下dp70题爬楼梯里的扩展一



### 78. 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。 [78. 子集](https://leetcode-cn.com/problems/subsets/)

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从begin开始，而不是从0开始！**而且子递归给`i+1`

如下图所示，程序执行的顺序为红色数字，子集先取1，再取2，再取3，形成123，然后去掉3，往上回溯，此时也没啥选择，只能继续回溯，去掉2，这时候可以有新选择了，就是取3，形成13，接着再往上回溯，不取1了，取2，再取3，形成23。接着网上回溯，不取2，只取3。注意这个只是顺序，每一过程中的子集都得添加到结果集中

如何判断不继续向下选择，而是向上回溯呢？也就是递归的终止条件，其实就是`begin>= nums.length` 

> 什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为排列是有序的，{1, 2} 和{2, 1}是两个排列。后序会讲

![78子集-图解](E:/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98.assets/78%E5%AD%90%E9%9B%86-%E5%9B%BE%E8%A7%A3-16621139839701.png)

代码：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>(); //用ArrayList速度会快一点
    public List<List<Integer>> subsets(int[] nums) {
        backTracking(0,nums);
        return res;
    }

    public void backTracking(int begin, int[] nums){
        // 不能是res.add(path)，要添加path的拷贝。
        // 并且这句必须要放在return语句之前，这样才能在递归返回之前把子集添加进结果中
        res.add(new LinkedList<>(path));  
        // if(begin >= nums.length) return;  // 不加递归终止条件也可以，因为for循环会递归完
        for(int i=begin; i<nums.length; i++){
            path.addLast(nums[i]);    // path.add(nums[i])也可以
            backTracking(i+1, nums);  // 自己写写成了begin+1，以后注意
            path.removeLast();        // 用ArrayList就是path.remove(path.size()-1)
        }
    } 
}
```

注意点：

* 需要非常注意的是 要使用res.add(new LinkedList<>(path))这样保存结果，而不能是res.add(path)，后者的结果为空**，因为变量 `path` 所指向的列表 **在深度优先遍历的过程中只有一份** ，深度优先遍历完成以后，回到了根结点，成为空列表。在 Java 中，参数传递是 **值传递**，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 `res` 变量，但实际上指向的是同一块内存地址，这块内存地址最后都变成 [ ] 了，所以打印出来的也都是空，所以要弄一份当前的拷贝，放入 res，这样后续对 path 的操作，就不会影响已经放入 res 的内容
* `if(begin >= nums.length) return;`这句递归终止条件不加也可以，因为假设begin=length了，for循环进不去，或者说刚进去发现不满足条件就退出了



### 90. 子集Ⅱ

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

与上一题区别就是集合里有重复元素了，这就导致了求取的子集要去重。首先要对数组进行排序，然后就是**同一树层上的“使用过”**的元素要去掉，如下图所示。而**同一树枝上的都是一个组合里的元素，不用去重**

> 理解“树层去重”和“树枝去重”非常重要。后期要讲解的排列问题里去重也是这个套路

同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！

![90.子集II.png](E:/%E5%9B%BE%E7%89%87/%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98.assets/1604912138-sosMZx-90.%E5%AD%90%E9%9B%86II.png)

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backTracking(0, nums);
        return res;
    }

    public void backTracking(int begin, int[] nums){
        res.add(new LinkedList<Integer>(path));
        for(int i = begin; i<nums.length; i++){
            // 跳过当前树层相同的元素，注意要保证i != begin，因为i=begin时，nums[begin-1]不合法
            if(i != begin && nums[i] == nums[i-1]) continue;
            path.add(nums[i]);
            backTracking(i+1, nums);
            path.removeLast();
        }
    }
}
```





### 77. 组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。你可以按 **任何顺序** 返回答案。      [77. 组合](https://leetcode-cn.com/problems/combinations/)

**回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了**

![image-20220407101907621](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/77%E7%BB%84%E5%90%88-%E5%9B%BE%E8%A7%A3.png)

> 图源：[回溯算法 + 剪枝](https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/)



叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 path，它是一个列表，特别地，path 是一个栈；

每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start ，表示在区间 [begin, n] 里选出若干个数的组合；

**回溯递归三部曲：**

* 递归函数的返回值以及参数：返回值为空，题目要求的两个参数传入，并将两个结果集（一个最终结果，一个临时结果）作为参数传入，或者设为全局变量（很多题目的递归函数参数不是一开始就能定下来的，先写着）

    ```Java
    public void backTracking(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path)
    ```

* 回溯函数终止条件：path这个数组的大小如果达到k，就到达叶子节点了

    ```Java
    if(path.size()==k){  
        ......  
        return;
    }
    ```

* 单层搜索的过程，由于元素是不能重复的，因此选完一个元素，就得从剩下的元素里选择，所以递归时需要`backTracking(i+1)`

    ```java
    for (int i = begin; i <= n; i++) {
        path.addLast(i);   // 处理节点
        backTracking(n, k, i + 1, path, res); // 递归：backTracking
        path.removeLast(); // 回溯，撤销处理的节点
    }
    ```



整体代码如下

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的最终集合
        Deque<Integer> path = new LinkedList<>();     // 存放符合条件结果的临时集合，队列或数组都可以
        if(k<=0 || k>n) return res;
        backTracking(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void backTracking(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            backTracking(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```

**辅助解题**

在解题时候可以在回溯周围加入打印信息，给一个测试用例，观察递归写的是否正确，这点非常重要！！自己写递归经常容易出问题

```Java
public class Combinations {
    public List<List<Integer>> combine(int n, int k) {
		......
    }

    private void backTracking(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i <= n; i++) {
            path.addLast(i);
            System.out.println("递归之前 => " + path);
            backTracking(n, k, i + 1, path, res);
            path.removeLast();
            System.out.println("递归之后 => " + path);
        }
    }

    public static void main(String[] args) {
        Combinations solution = new Combinations();
        int n = 5;
        int k = 3;
        List<List<Integer>> res = solution.combine(n, k);
        System.out.println(res);
    }
}
```

> 递归之前 => [1]
> 递归之前 => [1, 2]
> 递归之前 => [1, 2, 3]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 4]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 5]
> 递归之后 => [1, 2]
> 递归之后 => [1]
>
> ......

**剪枝优化**

上面的题解中，可以进行优化。分析搜索起点的上界进行剪枝处理。

分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 `path` 的长度相关。我们举几个例子分析：

例如：`n = 6 ，k = 4`。

path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 44，最后一个被选的组合是 [4, 5, 6]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 55，最后一个被选的组合是 [5, 6]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 66，最后一个被选的组合是 [6]；

再如：n = 15 ，k = 4。
path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 1313，最后一个被选的是 [13, 14, 15]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 1414，最后一个被选的是 [14, 15]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 1515，最后一个被选的是 [15]；

可以归纳出：

**搜索起点的上界 + 接下来要选择的元素个数 - 1 = n**

得到搜索起点的上界 = n - (k - path.size()) + 1，所以，我们的剪枝过程就是：把 `i <= n` 改成 `i <= n - (k - path.size()) + 1` ：

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的集合
        Deque<Integer> path = new LinkedList<>();     // 用来存放符合条件结果
        if(k<=0 || k>n) return res;
        dfs(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void dfs(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n - (k - path.size()) + 1; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            dfs(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```



很多剪枝优化想出来其实不容易，只能多做题练习了







### 39. 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]

示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]

这道题和 [77. 组合](https://leetcode-cn.com/problems/combinations/) 的差别在于：

- 组合总和的元素个数没有数量要求
- 元素可无限重复选取

![image-20220411102216417](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E5%9B%BE%E8%A7%A3.png)

>  （图源：[「手画图解」怎么分析回溯问题？](https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/)）

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

还是熟悉的递归方式

**回溯递归三部曲**

- 递归函数参数

首先是题目中给出的参数，集合candidates, 和目标值target，以及两个结果集

此外还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。

**本题还需要begin来控制for循环的起始位置，对于组合问题，什么时候需要begin呢？**

我举过例子，如果是**一个集合来求组合的话，就需要begin**，例如：[77.组合](https://programmercarl.com/0077.组合.html)，[216.组合总和III ](https://programmercarl.com/0216.组合总和III.html)。

如果是**多个集合取组合，各个集合之间相互不影响，那么就不用begin**，例如：[17.电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)

注意以上只是说**求组合的情况**，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍

```Java
public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin)
```

- 递归终止条件

终止只有两种情况，sum大于target和sum等于target。sum等于target的时候，需要收集结果

```Java
if (sum > target) {
    return;
}

if(sum == target){
    res.add(new LinkedList<>(path));
    return;
}
```

- 单层搜索的逻辑

单层for循环依然是从startIndex开始，搜索candidates集合。

注意本题和上一题最大的差别在于，本题元素为可重复选取的，所以递归时不用`backTracking(i+1)`

```Java
for(int i=begin; i< candidates.length; i++){
    sum += candidates[i];
    path.addLast(candidates[i]);
    bfs(candidates, target, res, path, sum, i); // 本题元素为可重复选取的，所以下一个begin还是i
    sum -= candidates[i];  // 回溯
    path.removeLast();     // 回溯
}
```

所以整体代码为：

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin){
        if (sum > target) {
            return;
        }
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i); 
            sum -= candidates[i];  // 回溯
            path.removeLast();     // 回溯
        }
    }
}
```

递归的for循环也可以写为：

```Java
for(int i=begin; i< candidates.length; i++){
    path.addLast(candidates[i]);
    // 这种其实就是永远在形参里传递sum，没进递归终止条件才更新sum，所以不用像上面显式更新num后面也不用回溯，但不利于理解，上面的写法更好理解一点
    bfs(candidates, target, res, path, sum+candidates[i], i);
    path.removeLast();
}
```



**辅助解题**

同样的，在递归前后加上打印信息，此处略



**剪枝优化**

在基本的递归写完后，可以进行进一步的优化。

对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。那么可以在for循环的搜索范围上做做文章了。

**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历**。

注意，这是组合问题，可以这样操作，如果是排序就另说了

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        Arrays.sort(candidates); // 先进行排序
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            // 如果 sum + candidates[i] > target 就终止此次递归，回退到上一轮递归
            if (sum + candidates[i] > target) break;
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```





### 40. 组合总和Ⅱ

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。**注意：**解集不能包含重复的组合。  [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]

示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]

这道题目和 [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) 有如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，而上一题是无重复元素的数组candidates

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。即难点在于去重，**所谓去重，其实就是使用过的元素不能重复选取。** 

以candidates = [2,5,2,1,2], target = 5 为例， 所求解集为: [  [1,2,2],  [5] ]

![image-20220411101837423](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1-%E5%9B%BE%E8%A7%A3.png)

>  图源：[手画图解 | 长文漫谈回溯 | 40. 组合总和 II ](https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/)

如果是把所有组合求出来，再用set或者map去重，这么做很容易超时！所以要在搜索的过程中就去掉重复组合。如上图所示，选取1后，剩下的三个2只用选第一个即可，其他的2选取了也没意义，属于同一个树层的重复选取，相比于上一题只需改动三点：

* 先排序，使得重复的数字相邻，方便去重。（上一题是 作为剪枝优化方法）
* for循环加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
* 每个数字只能选用1次，1个元素选完只能从剩下的元素里选择，因此需要给子递归传`i+1`。这一点和 77题.组合 类似



**递归三部曲**

由于和上一题高度类似，此处不详细写，流程参照上一题。注意点已经写在了注释中

```Java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        // 改动1：先进行排序，使得重复的数字相邻，方便去重
        Arrays.sort(candidates); 
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            if (sum + candidates[i] > target) break;
            // 改动2：加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
            // 注意数组越界问题，i是从begin开始的，begin每次递归都在变，所以要保证i-1>=begin，而不是i-1>=0
            // 自己第一次写的时候，写成了i-1>begin，忽略了等于的情况，事实上等于也是可以的，自己理一下就行
            if (i-1>=begin && candidates[i - 1] == candidates[i]) continue;
            sum += candidates[i];
            path.addLast(candidates[i]);
            // 改动3：每个数字只能选用1次，1个元素选完只能从剩下的元素里选择，因此需要给子递归传`i+1`
            bfs(candidates, target, res, path, sum, i+1);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```











下面是此类型的实际应用题，其递归的for循环往往有自己的实际length，然后从0开始遍历，其中需要一个索引唯一指针 begin

### 17. 电话号码的字母组合

和上面的回溯思路基本相同，难点在于字符串的一些列处理，比如使用StringBuilder，将数字组成的字符串，对应到字符组成的字符串   [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-%E5%9B%BE%E8%A7%A3.png)

> 图源：[「手画图解」两种解法：DFS回溯、BFS。我理解的回溯 - 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/)

```Java
class Solution {
    List<String> res = new LinkedList<>();  // 结果集
    StringBuilder temp = new StringBuilder(); //每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuildr

    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return res;
        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backTracking(digits, numString, 0); //迭代处理
        return res;
    }

    public void backTracking(String digits, String[] numString, int begin){
        if(begin == digits.length()){
            res.add(temp.toString());
            return;
        }
        // 将digits的“23” 转为 numString中对应的字符串，注意 '2' 转为 整型2 只需要 '2'-'0' 即可
        String str = numString[digits.charAt(begin) - '0'];

        for(int i=0; i<str.length(); i++){
            temp.append(str.charAt(i)); // 添加元素
            backTracking(digits,numString,begin+1);  // 递归
            temp.deleteCharAt(temp.length() - 1); // 删除元素
        }
    }
}
```

用93的Deque<String>改写看看，不用StringBuilder，addLast或者removeLast即可，不知道可不可行



### 93. 复原IP地址

前面的题目判断回溯的条件相对来说比较简单，即数目达标或者和达标，这道题的返回条件比较复杂，或者说返回情况比较多，再加上字符串的处理，整体难度不小。基本的回溯思路还是相同的  [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/93%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-%E5%9B%BE%E8%A7%A31.png)

**回溯三要素**

尝试用回溯三要素思路线分析：

* 回溯要素一：选择

上图是本题回溯的基本思路，第一步可以选 "2" 作为第一个片段，选 "25" 作为第一个片段，选 "255" 作为第一个片段，能切三种不同的长度，切第二个片段时，又面临三种选择。这会向下分支，形成一棵树，我们用 DFS 去遍历所有选择，必要时提前回溯。

* 回溯要素二：约束条件

1. 一个片段的长度是 1~3
2. 片段的值范围是 0~255
3. 不能是 "0x"、"0xx" 形式，即长度大于1时，必须首位不为0

用这些约束进行充分地剪枝，去掉一些选择，避免搜索「不会产生正确答案」的分支

* 回溯要素三：目标

本题回溯的目标是生成 4 个有效片段，并且要耗尽 IP 的字符。

目标决定了什么时候**捕获答案**，什么时候砍掉死支，当目标满足时，说明生成了一个有效组合，加入解集，结束当前递归，继续探索别的分支。如果满4个有效片段，但没耗尽字符，不是想要的解，不继续往下递归，提前回溯。因此分析目标的时候也能推出约束条件：

4. 满4段，未耗尽所有字符



下图是一个有效的组合的样子。start 指针越界，代表耗尽了所有字符，且满 4 个片段。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/93%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-%E5%9B%BE%E8%A7%A3.png)

> 图源：[『手画图解』DFS回溯中的细节 | 93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/)



**回溯递归三部曲**

* 递归函数的返回值以及参数：返回值为空，传入题目的String，再传入两个参数，并将两个结果集设为全局变量

    ```Java
    // start是字符串s的遍历指针，num用来记录当前ip段的数量
    public void backTracking(String s, int begin, int num){}
    ```

* 回溯函数终止条件：目标达成，片段满4段，耗尽所有字符

    ```Java
    // 目标：片段满4段，耗尽所有字符
    if(num ==4 && begin == s.length()){
        res.add(String.join(".", temp));           // 字符串拼接内置方法，否则会很麻烦
        return;
    }
    ```

* 单层搜索的过程：搭配诸多约束条件

    ```java
    for(int len=1; len<=3; len++){              // 约束条件1：枚举出选择，三种切割长度
        if(begin+len-1 >= s.length()) return;   // Java语法约束：加上切的长度就数组越界，不能切
        if(len>1 && s.charAt(begin)=='0') return;  // 约束条件3：长度大于1时，必须首位不为0，
        String str = s.substring(begin, begin + len);  // 当前选择切出的片段
        // 约束条件2：片段的值范围是 0~255
        if(Integer.parseInt(str)<0 || Integer.parseInt(str)>255) return; 
        temp.addLast(str);
        num++;
        backTracking(s,begin+len,num);     // 从len长度后开始下一次递归，此前没见过
        num--;
        temp.removeLast();
    }
    ```



整体代码：

```Java
class Solution {
    List<String> res = new LinkedList<>();
    Deque<String> temp = new LinkedList<>();
    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12 || s.length() < 4) return res; // 初始判断
        backTracking(s,0,0);
        return res;
    }

    // start是字符串s的遍历指针，num用来记录当前ip段的数量
    public void backTracking(String s, int begin, int num){
        // 目标：片段满4段，耗尽所有字符
        if(num ==4 && begin == s.length()){
            res.add(String.join(".", temp));       // 字符串拼接内置方法，否则会很麻烦
            return;
        }
        if(num ==4 && begin < s.length()) return; // 约束条件4：满4段，未耗尽所有字符，直接返回

        for(int len=1; len<=3; len++){            // 约束条件1：枚举出选择，三种切割长度
            if(begin+len-1 >= s.length()) return; // 语法约束：加上切的长度就数组越界，不能切
            if(len>1 && s.charAt(begin)=='0') return;  // 约束条件3：长度大于1时必须首位不为0
            String str = s.substring(begin, begin + len);  // 当前选择切出的片段
            // 约束条件2：片段的值范围是 0~255
            if(Integer.parseInt(str)<0 || Integer.parseInt(str)>255) return; 
            temp.addLast(str);
            num++;
            backTracking(s,begin+len,num);   // 从len长度后开始下一次递归，此前没见过
            num--;
            temp.removeLast();
        }
    }
}
```

其中，关于字符串有如下想法：

* 从解题的角度想，`Deque<String>`比StringBuilder方便，addLast或者removeLast即可，StringBuilder删减还得注意下标
* `String.join()`用于拼接很方便
* `Integer.parseInt()`转为整型很方便，如果不允许用，则可以用下面的代码进行转换，并进行判断

```Java
private boolean judgeIpSegment(String s, int left, int right) {
    int len = right - left + 1;
    if (len > 1 && s.charAt(left) == '0') {
        return false;
    }

    int res = 0;
    while (left <= right) {
        res = res * 10 + s.charAt(left) - '0';
        left++;
    }

    return res >= 0 && res <= 255;
}
```





### 22. 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。[22. 括号生成 ](https://leetcode-cn.com/problems/generate-parentheses/)

输入：n = 3  输出：["((()))","(()())","(())()","()(())","()()()"]

**回溯三要素**

* 回溯要素一：选择

    在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树

* 回溯要素二：约束条件

    什么情况下可以选左括号，什么情况下可以选右括号？

    只要`(`有剩，就可以选`(`，当剩下的`)`比`(`多（相等不行）时，才可以选`)`，否则，`)`不能选，选了就非法。因为剩下的`)`比`(`少，即，使用的`)`比`(`多，不能成双成对。

* 回溯要素三：目标

    构建出一个用尽 n 对括号的合法括号串。意味着，当构建的长度达到 2*n，就可以结束递归（不用继续选了）。

```Java
class Solution {
    List<String> res = new LinkedList<>();
    StringBuilder path = new StringBuilder();
    public List<String> generateParenthesis(int n) {
        backTracking(n,n,n);
        return res;
    }

    // leftRemain：左括号剩下的个数   rightRemain：右括号剩下的个数
    public void backTracking(int n, int leftRemain, int rightRemain){
        // 目标
        if(path.length() == 2*n){
            res.add(path.toString());
            return;
        }
        // 左括号有剩的，就可以选左括号
        if(leftRemain > 0) {
            path.append("(");
            backTracking(n, leftRemain-1, rightRemain);
            path.deleteCharAt(path.length() - 1);
        }
        // 右括号剩的大于左括号剩的，才可以选右括号
        if(rightRemain > leftRemain) {
            path.append(")");
            backTracking(n, leftRemain, rightRemain-1);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```





### 46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。[46. 全排列](https://leetcode-cn.com/problems/permutations/)

示例 1：输入：nums = [1,2,3]   输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



解法就是按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。这样的思路，可以用一个树形结构表示。

![46全排列-图解](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/46%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%BE%E8%A7%A3.png)

> 图源：[「代码随想录」带你学透回溯算法！46. 全排列](https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/)



**回溯递归三部曲**

- 递归函数参数

    由于全排列每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。所以它和前面子集、组合类问题最大的不同就是：for循环里不用添加begin这个开始索引了。

    但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示，细节放在后面聊。将辅助的集合和数组都定义为全局变量：

    ```Java
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    
    public void backTracking(int[] nums){}
    ```

- 递归终止条件

    从图解里可以看出叶子节点，就是收割结果的地方。那么什么时候，算是到达叶子节点呢？

    当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

    ```Java
    if(path.size() == nums.length){
        res.add(new LinkedList<>(path));
        return;
    }
    ```

- 单层搜索的逻辑

    前面提过全排列每次都要从头开始搜索，所以它和前面子集、组合类问题最大的不同就是：for循环里不用添加begin这个开始索引了。但排列问题需要一个used数组，标记已经选择的元素，记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。

    ![微信截图_20200514183911.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/46%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%BE%E8%A7%A31)

    > 图源：[「手画图解」怎么写出回溯算法 | 46.全排列问题](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)

    如上图所示，第一个取1的树枝里，是如何保证后续的数据不再取1的？在第一层的for循环里，i=0的时候，取了1，然后进递归，第二层的for循环也是从0开始，还是遍历3次，但当 i=0 想添加1时，有一个辅助数组判定，这个1已经用过了，不要再用了，因此到 i=1，即添加2.

    即这是在每个树枝上对使用过的元素进行判定（在下一题会涉及到树层上）

    ```Java
    for(int i=0; i<nums.length; i++){
        if(used[i] == true) continue;  // 如果元素使用过，跳过这一轮循环
    
        used[i] = true;
        path.addLast(nums[i]);
        backTracking(nums);
        path.removeLast();
        used[i] = false;
    }
    ```



完整的代码为：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];  // 自己写的时候还写成了boolean[] used = ...，离谱
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=0; i<nums.length; i++){
            if(used[i] == true) continue;  // 如果元素使用过，跳过这一轮循环
            
            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



大家此时可以感受出排列问题的不同：

- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了



### 47. 全排列 II

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。  示例 ：输入：nums = [1,1,2]  输出：[[1,1,2], [1,2,1], [2,1,1]]     [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

和46的区别在与**给定一个可包含重复数字的序列**，要返回**所有不重复的全排列**。这里又涉及到去重了。

之前也讲过类似的题型，注意**去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

这里的去重一共有两个地方：

* 和上一题一样的，在每个树枝上确保前面被选过的元素不要被再选，如下图的红色圆圈路径

    ```Java
    if (used[i] == true) continue;
    ```

* 本题特殊的，集合重复元素不再重选，确保树层上相同的元素不要被再选。如何确保？用如下的代码

    ```Java
    if(i-1>=0 && nums[i] == nums[i-1] && used[i-1] == false) continue;
    ```

判定当前的nums[i] == nums[i-1] 很好理解，元素重复。为什么是used[i-1] == false ? 

nums[i] == nums[i-1] 会遇到两种情况：

（1）used[i-1] == false，比如第二个树枝里的红色三角形，这是在选第二个1，和第一个1相同，但第一个1没被上层选过（上层只选过一个2），那按照递归的顺序，他肯定被递归过了，所以本次的1（即第二个1）就不能再选，属于树层上的重复，需要舍弃

（2）used[i-1] == true，如下图中的绿色圆，比如第一个树枝，选第二个1的时候，和第一个1相同，但是第一个1在上一层被选过了（上层选的就是第1个1），那按照上一句代码里的逻辑，它会被跳过，即第一个1没机会被递归，那就得让第2个1被递归

所以这个used[i-1] == false到底是什么？答案是判定当前这个重复元素的前一个元素（nums[i-1]），在上层有没有被选过。

如果被选过，那前一个元素（nums[i-1]）按照第一个判定条件，没机会递归，所以让当前元素（nums[i]）递归，

如果没被选过，那前一个元素（nums[i-1]）按照第一个判定条件，已经递归过了，当前元素（nums[i]）舍弃

![微信截图_20200514183911.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/47%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1-%E5%9B%BE%E8%A7%A3.png)



整体代码如下：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];  // 默认都是false
        Arrays.sort(nums);  // 排序
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=0; i<nums.length; i++){   
            //如果同⼀树⽀nums[i]使⽤过则跳过
            if (used[i] == true) continue;
            // nums[i-1] == nums[i]说明是重复元素
            // used[i - 1] 等于 false 说明 nums[i-1]在上层被选过，已经递归过了，nums[i]就不用递归了，舍弃
            if(i-1>=0 && nums[i] == nums[i-1] && used[i-1] == false) continue;

            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



### 79. 单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

基本思想和前面的差不多，但由于题型场景特殊，代码能不能写出来不好说。。注意点都写在下面了，结合图解看懂应该是不难，自己写就费劲了

以"SEE"为例，首先要选起点：遍历矩阵，找到起点S。起点可能不止一个，基于其中一个S，看看能否找出剩下的"EE"路径。下一个字符E有四个可选点：当前点的上、下、左、右。逐个尝试每一种选择。基于当前选择，为下一个字符选点，又有四种选择。每到一个点做的事情是一样的。DFS 往下选点，构建路径。当发现某个选择不对，不用继续选下去了，结束当前递归，考察别的选择。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E5%9B%BE%E8%A7%A3.png)

约束条件：

1. 当前的点，越出矩阵边界。
2. 当前的点，之前访问过，不满足「同一个单元格内的字母不允许被重复使用」。
3. 当前的点，不是目标点，比如你想找 E，却来到了 D。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E5%9B%BE%E8%A7%A31.png)

> 图源：[「手画图解」回溯思路的形成与细节 | 79.单词搜索](https://leetcode-cn.com/problems/word-search/solution/shou-hua-tu-jie-79-dan-ci-sou-suo-dfs-si-lu-de-cha/)

```Java
class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        boolean[][] used = new boolean[m][n];
        // 遍历每个格子，每个格子都可能是起点
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(backTracking(board,i,j,0,word,used)) return true;
            }
        }
        return false;
    }

    // backTracking()的作用：当前点[row,col]能否为剩下的字符找到路径，能就继续递归，不能就结束递归，直到最后递归终止才回到for循环
    // row：当前遍历的行位置 col：当前遍历的列位置 i：当前遍历到的word位置
    // 即记录两个位置，一个是网格内的字母位置，一个是word里的字母位置
    public boolean backTracking(char[][] board, int row, int col, int i, String word, boolean[][] used){
        // 目标：全部字符匹配
        // 注意这里必须是i == word.length()才能全部匹配完，如果是 i == word.length()-1，那么最后一个字符还没有判定
        // 并且这里只是递归终止条件，这个结束是在主函数里进行下一个for循环，其并不能作为当前字符匹配成功的条件，这个在下面
        if(i == word.length()) return true;
        // 约束1：当前节点不在网格内，越界
        if(row<0 || row >= board.length || col <0 || col>=board[0].length) return false;
        // 约束2：重复访问
        if(used[row][col] == true) return false;
        // 约束3：字符不匹配
        if(board[row][col] != word.charAt(i)) return false;

        // 当前字符匹配 做访问标记
        used[row][col] = true;
        // 当前点[row,col]往四个方向尝试匹配下一个字符
        boolean canFindRest = 
            backTracking(board, row - 1, col, i + 1, word, used) ||
            backTracking(board, row + 1, col, i + 1, word, used) ||
            backTracking(board, row, col - 1, i + 1, word, used) ||
            backTracking(board, row, col + 1, i + 1, word, used);
        // 当前点[row,col]可以为剩下的字符找到路径，继续递归
        if (canFindRest == true) return true; 
        // 先回溯修改当前不能访问的点 但是接下来的方向可以访问它，然后再返回false
        used[row][col] = false;
        // 当前点[row,col]不可以为剩下的字符找到路径
        return false;
    }
}
```













### 51. N皇后















35：26

37：30











# 动态规划

动态规划（Dynamic programming, DP）：将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案

一般会存在最优子结构，即通过求子问题的最优解，可以获得原问题的最优解。



动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、dp(i)(j)(k)......

动态规划做题步骤：

* 明确 dp(i) 应该表示什么；
* 根据 dp(i) 和 dp(i-1) 或者其他变量的关系得出状态转移方程；
* 确定初始条件，如 dp(0)等。



dp数组初始化长度为n和n+1，主要是看dp[0]和dp[n]用不用到，待补充



一维：70、198、42、121、122、343、300、53

二维：152、647、5、516、1143、背包问题、322

多维：123



【玩转算法面试】提到的可练习题目：力扣120、279、91、62、63、213、337、309、376



## 一维dp

### 剑10. 斐波那契数列  33

我们从斐波那契数列问题引入，写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

（以下解答忽略题目中的取模1000000007）

该问题不难用递归解决，即我们认为已经知道了 f(n-1) 和 f(n-2) 的答案，如何求 f(n)。



**方法一：递归（暴力搜索）**

```Java
class Solution {
    // 超时
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        return fib(n-1)+fib(n-2);
    }
}
```

时间复杂度：O(2^N^)，空间复杂度O(N)算上递归栈

递归的时间复杂度为指数次方，完全不符合要求。究其原因，其递归树中包含特别多的重复计算，如下图所示：红框是重复计算，蓝框也是

![image-20220614212719156](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E5%89%91%E6%8C%8710%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E5%9B%BE%E8%A7%A3.png)



**方法二：记忆化递归（记忆化搜索）**

同样是自上而下解决问题，怎样避免重复计算，答案是空间换时间的思想，我们构建一个数组，存放每次F(n)的数值，递归过程中，只有没被计算过的值才计算，计算过的值，直接索引数组即可。

**缺点：** 记忆化存储需要使用 O(N)的额外空间。

```Java
class Solution {
    public int fib(int n) {
        int[] memo = new int[n+1]; // 需要存储 n+1 个数
        Arrays.fill(memo,-1);      // 初始化数组时，记得不要初始化为以后可能用上的值
        return fib(n,memo);
    }

    public int fib(int n, int[] memo) {
        if(n==0) return 0;
        if(n==1) return 1;
        if(memo[n]==-1){
            memo[n] = fib(n-1,memo) + fib(n-2,memo);
            memo[n] %= 1000000007;  // 题目要求。只注重逻辑上的话可以省略取模
        }        
        return memo[n];
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)



**方法三：动态规划**

动态规划是自下而上的解决问题，既然知道每个值是怎么得来的，那自然可以用循环，从下而上，计算出每个值是多少，这里可以像记忆化递归一样构建一个长度为n的数组，但空间复杂度为 O(N)。

```Java
class Solution {
    public int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
            dp[i] %= 1000000007;
        }
        return dp[n];
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)

由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可 

最好能画出下面的图，否则循环条件和返回值容易出错，自己手写几次就知道了。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E5%89%91%E6%8C%8710%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E5%9B%BE%E8%A7%A31.png" alt="Snipaste_2022-06-14_21-23-09" style="zoom:80%;" />

```Java
class Solution {
    public int fib(int n) {
        int a=0,b=1,sum;
        for(int i=0; i<n; i++){
            sum = (a + b) % 1000000007;  // 题目要求。只注重逻辑上的话可以省略取模
            a = b;
            b = sum;
        }
        return a; // 注意不是返回sum，sum是下一轮的值
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)

**总结**

通过上面的分析，能够看出递归问题存在着重叠的子问题，有两种解决办法：

* 记忆化递归--自顶向下的解决问题
* 动态规划-自底向上的解决问题



### 0070. 爬楼梯  104

与上面斐波那契类似的，还有一道经典爬楼梯。

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？提示：`1 <= n <= 45`。    [70. 爬楼梯 - 力扣](https://leetcode-cn.com/problems/climbing-stairs/)

**方法一：动态规划**

本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和：

* 爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶
* 爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶

1. 确定dp数组以及下标的含义

dp[i]： 爬到第i层楼梯，有dp[i]种方法

2. 确定递推公式

dp[n] = dp[n-1] + dp[n-2]

3. 初始化

初始化时，讨论dp[0]没有意义，因为n为正整数，所以初始化 dp[1]=1，dp[2]=2。后续循环 i 从3开始

（关于初始值这里，有人认为初始化dp[0]也行，由dp[1]=1，dp[2]=2和递推公式推出dp[0]=1，然后循环里从2开始，个人感觉这样不符合dp[i]的定义）

```Java
class Solution {
    public int climbStairs(int n) {
        if(n<=1) return n; // 下面初始化了dp[2]，所以这里保证n>=2
        int[] dp = new int[n + 1];
        dp[1] = 1; 
        dp[2] = 2;
        for(int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

用了额外的数组，但这也是最标准的动态规划答案，其中涉及到了状态转移方程

对于此题可以用之前斐波那契数列的动态规划解法，使用三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可。这是「滚动数组思想」。对于for循环的起始终点，自己多画图举例，记住下面的图

![Snipaste_2022-06-15_00-36-02](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/70%E7%88%AC%E6%A5%BC%E6%A2%AF-%E5%9B%BE%E8%A7%A3.png)

```Java
class Solution {
    public int climbStairs(int n) {
        int a=1, b=1, sum;
        for(int i=0; i<n; i++){
            sum = a+b;
            a = b;
            b = sum;
        }
        return a; // 注意返回的是a
    }
}
```

上述的时间复杂度均为O(n)

由于现在的内卷，面试官有时候也要会O(logn)的解法，这里用到了几种数学方法--矩阵快速幂、特征方程，暂时略过，摆烂



本题扩展一：百度二面，要求输出每条路径。这个应该是考察回溯了。参考：[lc70.爬楼梯【自用笔记】 - 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/solution/lc-by-austism-s-ssri/)

本题扩展二：不能爬到7及7的倍数——2021.3 字节跳动-教育-后端-一面

本题扩展三：如果每次可以最多可以爬m阶，有多少种爬法？--【完全背包问题，代码随想录，牛客上有原题】



### 0343. 整数拆分/剪绳子  14

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。返回你可以获得的最大乘积 。`2 <= n <= 58` [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/) 、[剑指 Offer 14- I. 剪绳子](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```



**方法一：暴力搜索**

n=10，它可以拆分为1和9，我们可以对9进行递归，又可以拆分为2和8，对8进行递归……

对于数字 n，可以拆分为 i 和 n-i，i 的范围从 1 到 n-1。

遍历所有的 i，对于 n-i，它**可以选择拆分或不拆分**（不拆分也是一种情况！！！），如果拆分就递归。

![343](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-%E5%9B%BE%E8%A7%A3.png)

因此可以写出如下代码：

```Java
// 暴力解法
public int integerBreak(int n) {
    if (n == 2) return 1;
    int res = -1;
	//for循环起始终止条件，自己举例子画画图
    for (int i = 1; i <= n - 1; i++) {
        // 这里需要注意的是，拆分和不拆分都是情况之一，拆分就是三部分起步了，不拆分就是两部分
        // 上一轮的res就是不拆分情况下的最大值
        res = Math.max(res, Math.max(i * (n - i), i * integerBreak1(n - i)));
    }
    return res;
}
```

由图中所示，此方法存在大量重复递归，因此肯定超时，不满足要求。



**方法二：记忆化搜索**

根据斐波那契题的思考，我们采用空间换时间的思想，用一个数组记录每次拆分的乘积最大值，如果碰到数组里的值不是初始化时的值，说明他被计算过了。不难写出下面的代码

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        return integerBreakHelper(n,dp);
    }

    public int integerBreakHelper(int n, int[] dp) {
        if(n==2) return 1;
        if(dp[n] != 0) return dp[n];
        int res = -1;
        for(int i=1; i<n; i++){
            // n可以拆分为 i 和 n-i，n-i可以选择不拆分或继续拆分
            // 上一轮的res就是不拆分情况下的最大值
            res = Math.max(res, Math.max(i*(n-i), i*integerBreakHelper(n-i,dp)));
        }
        dp[n] = res;
        return res;
    }
}
```

这依然是一个自顶向下的过程



**方法三：动态规划**

其实，记忆化搜索已经满足的题目的要求。但是对于这样的一个`递归`代码，我们更习惯转化为`递推`，将`自顶向下`的思路转换为`自底向上`，这也是记忆化搜索和DP之间的区别所在。

对于的正整数 n，当 n ≥ 2 时，可以拆分成至少两个正整数的和。令 i 是拆分出的第一个正整数，则剩下的部分是 n−i。第一个正整数 i 可以不继续拆分，或者继续拆分成至少两个正整数的和（一个问题可以分解为相似的子问题因此想到动态规划）假设对正整数 i 拆分出的第一个正整数是 j ，那么剩下的就是 i-j，

动态规划算法分析

1. 确定dp数组以及下标的含义：dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积

2. 确定状态转移方程

​		当 i ≥ 2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下3种方案：

​		（1）将 i 拆分成 j 和 i-j ， 且 i−j <font color=red>不再拆分</font>成多个正整数，此时的乘积是 j×(i−j) ；

​		（2）将 i 拆分成 j 和 i−j ，且 i−j <font color=red>继续拆分</font>成多个正整数，此时的乘积是 j×dp[i−j] ;

​		（3）不拆分，那么上一轮的乘积最大值也是本轮的乘积最大值

​		因此当 j 固定时，能够得出递推公式，有 dp[i]=max(dp[i], max(j×(i−j),j×dp[i−j]))

3. 初始化状态

    0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。与语法初始化相同，可以不写。2只有一种拆分方式，乘积为1，所以dp[2] = 1

4. 遍历顺序

    由状态转移方程知道dp[i] 是从 j×(i−j)和j×dp[i−j] 且j 的取值范围是 1 到 i−1 ，需要遍历所有的 j 得到dp[i]所以从前往后遍历。

5. 返回值

    最终得到dp[n]的值即为将正整数n拆分成至少两个正整数的和之后，这些正整数的最大乘积。

```Java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            // j取不到i，j=i时，i-j就为0了，不符合正整数的要求。虽然哪怕取到i也可以ac
            for(int j=1; j<i; j++){ 
                // 上一轮的dp[i]就是不拆分情况下的最大值，拆分情况下，再比一个最大值
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```

时间复杂度：O(N^2^)，空间复杂度O(N)



**方法四：贪心**

本题还有一种贪心解法，其是基于数学因式分解的推导，也就是分别分析分解因子里有 1、2、3、4、5、6等因子时，乘积的大小。分解到后面就不用继续了，因为都可以转换成前面的因子，比如7可以分解为2×2×3，仍然是2和3的因子，8可以分解为2×3×3，仍然是2和3的因子……。其实所有的因子最后都分解为2和3的因子，那么应该多分出2还是3呢？

得出的结论是：在 n>4时，应尽可能多分解3，当n<=4时，直接计算即可

```Java
public class Solution {
    public int integerBreak(int n) {
        if (n <= 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        // 接下来就是 n >= 5 的时候的逻辑了
        int res = 1;
        while (n > 4) {
            res *= 3;
            n -= 3;
        }
        res *= n;
        return res;
    }
}
```

时间复杂度O(N)，循环执行的次数是 N/3，不计系数，所以为O(N)，空间复杂度O(1)



### 0198. 打家劫舍  48

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



**方法一：动态规划**

我们不难分析出这道题具有重叠子问题和最优子结构的情况。所以可以使用动态规划的方法来解决。

假设有10间房屋，现在我正在对第5间进行决策，那么我的决策思路就是判断 **偷前三家+第五家赚，还是偷前四家更赚**，不要去想前三家或者前四家怎么偷，就好像不要陷入递归。总结为一句话就是，**是否选择偷当前房屋取决于： 是偷当前房屋收益高，还是偷前一家房屋收益高?**

动态规划算法分析

* 1. 确定dp数组以及下标的含义

    * dp[i] 表示前 i 间房屋能偷窃到的最高总金额

* 2. 确定递推公式

    * 当来到第i间房的时候，只有两种选择：

        * 偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋（这个时候不要想第i-1怎么办，我们只分析第i间房），偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和即：dp[i]=dp[i-2]+nums[i-1]
        * 不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额即：dp[i] = dp[i-1]

    * 因为题目要最大值所以直接取两者最大值即：

        ```
        dp[i]=max(dp[i−2]+nums[i-1] , dp[i−1]) // 注意第i间房屋的金额在数组里是i-1
        ```

* 3. dp数组初始化：dp[1] = nums[0];    不用单独初始化dp[2]，其值 = max(nums[0], nums[1])，也符合公式

* 4. 确定遍历顺序：从前往后遍历

* 5. 返回值：dp[n]

```Java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len+1];
        dp[1] = nums[0];
        for(int i=2; i<=len; i++){
            dp[i] = Math.max(dp[i-2]+nums[i-1], dp[i-1]);
        }
        return dp[len];
    }
}
```

时间复杂度：O(N)，空间复杂度O(N)

优化，因为dp[i]只跟dp[i−1]、dp[i−2]有关，所以也是可以只保留这两个数，不用dp数组。不过这两个数要从0开始。同时注意nums从0开始，而不是像上面dp[i]和nums[i-1]有关

```Java
class Solution {
    public int rob(int[] nums) {
        // cur用于记录dp[i]，pre用于记录dp[i-1]，temp用于记录dp[i-2]，自己写写画画
        int pre =0, cur=0, temp=0;
        for(int i=0; i<nums.length; i++){
            temp = pre; 
            pre = cur;
            cur = Math.max(pre, temp + nums[i]);
        }
        return cur;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



本题扩展一：打印路径

开辟第二个数组维度，用来记录从哪一个 i 转移过来的

```Java
    public static int rob(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[len+1][2];  // 核心点在于使用dp[][1]记录是从哪一个i转移过来的
        dp[1][0] = nums[0];
        dp[1][1] = 0;
        for(int i=2; i<=len; i++){
            if(dp[i-2][0]+nums[i-1] > dp[i-1][0]){
                dp[i][0] = dp[i-2][0]+nums[i-1];
                dp[i][1] = i-2;
            } else{
                dp[i][0] = dp[i-1][0];
                dp[i][1] = i-1;
            }
        }
        LinkedList<Integer> res = new LinkedList<>();
        int j = len;
        while(j>=1){
            // 如果金额不相等，说明发生了转移，打印j，并找到j是从哪转移过来的，并赋值；继续寻找下一个
            // 并且由于数组第二维里是后面的值记录从前面转过来的，只能从后往前遍历，最后可以反转一下list
            if(dp[j][0] != dp[j-1][0]){
                res.add(j);
                j = dp[j][1];
            } else{
                j--;
            }
        }
        Collections.reverse(res);
        System.out.println(res.toString());
        return dp[len][0];
    }
```

本题扩展二：所有房间是一个闭合环形，即第一个房间和最后一个房间视为相邻，能偷的最多金额。==牛客NC177==

无非就是再分为两大种情况，偷第一家不偷最后一家，与，不偷第一家偷最后一家，所以可以进行两次dp，注意两种初始化和for循环的终止条件

```Java
public int rob(int[] nums) {
    int len = nums.length;
    int[] dp = new int[len+1];
    int res; // 最后结果

    // 选择偷第一家不偷最后一家
    dp[1] = nums[0];
    for(int i=2; i<len; i++){ // 注意这里i不取len，表示不偷最后一家
        dp[i] = Math.max(dp[i-2]+nums[i-1], dp[i-1]);
    }
    res = dp[len-1];  // 将第一种结果保存下来
    Arrays.fill(dp,0);
    // 选择不偷第一家偷最后一家
    dp[1] = 0;
    for(int i=2; i<=len; i++){ // 注意这里i不取len，表示不偷最后一家
        dp[i] = Math.max(dp[i-2]+nums[i-1], dp[i-1]);
    }
    res = Math.max(res, dp[len]); // 结果取最大值
    return res;
}
```

本题扩展三：房间呈二叉树状。==牛客NC178==



### 0121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```



**方法一：暴力解法**

**思路**：枚举所有发生一次交易的股价差。时间复杂度：O(N^2)  此处略过



**方法二：动态规划**+贪心

dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化并且股票只能买卖一次，所以要记录股票的最低价格，记股票价格的最低点为minprice，这里也是贪心所在，则状态方程为：

dp [i] = max ( dp[i-1],  prices[i] - minprice )

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int[] dp = new int[prices.length];  // dp[i] 表示前 i 天的最大利润
        // 这里的初始化其实没必要，dp[0]没意义，因为不能第一天买入第一天卖出，dp[1]才有意义
        dp[0] = 0;  
        for(int i=1; i<prices.length; i++){
            minPrice = Math.min(minPrice, prices[i]);      // 记录股票最低点
            dp[i] = Math.max(dp[i-1], prices[i]-minPrice); // 更新最大利润
        }
        return dp[dp.length-1];
    }
}
```

空间优化，仅用一个变量保存最大利润，这个反而更好理解

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length ==0) return 0;
        int minPrice = prices[0];
        int maxProfit = 0;
        for(int i=1; i<prices.length; i++){
            minPrice = Math.min(minPrice, prices[i]);
            maxProfit = Math.max(maxProfit, prices[i]-minPrice);
        }
        return maxProfit;
    }
}
```

时间复杂度：O(N)

这道题dp还有其他的写法，但贪心+dp反而是最好理解的



### 0122. 买卖股票的最佳时机Ⅱ

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```



[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

与上一道题唯一的区别就是本题不限制买卖次数，卖完了还可以再买



**方法一：贪心**

最好理解的依然是贪心，遍历整个股票交易日价格列表 `price`，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。即因为不限制交易次数，不用像上题一样维护最小值，而是做出判断，是否上涨，上涨就把利润加到总利润中（注意题目是可以一天内卖买的）。这个动态规划就没太大关系了

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length==0) return 0;
        int maxProfit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]) 
                maxProfit += prices[i] - prices[i-1];
        }
        return maxProfit;
    }
}
```



### 0042. 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子下雨之后能接多少雨水。[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

![image-20220525211354394](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%9B%BE%E8%A7%A3.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```



本题的核心思路是：对于位置 i，能装的水为等于 i 两边最大高度的较小值减去当前高度的值。看下图就知道了，这样就可以按照每一列来求得接雨水的总量

![image-20220525212631938](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%9B%BE%E8%A7%A31.png)

> 图源：[图解接雨水：动态规划和双指针思路](https://leetcode.cn/problems/trapping-rain-water/solution/tu-jie-jie-yu-shui-dong-tai-gui-hua-he-shuang-zhi-/)



**方法一：暴力求解**

```Java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        for(int i=1; i<height.length-1; i++){   // 最左右两侧不用计算，水量为0
            int leftMax=0, rightMax=0;
            for(int j=i; j>=0; j--)             // 查找i的左边最大值
                leftMax = Math.max(leftMax, height[j]);
            for(int j=i; j<height.length; j++)  // 查找i的右边最大值
                rightMax = Math.max(rightMax, height[j]);
            res += Math.min(leftMax,rightMax)-height[i]; // 加上i列能装的雨水
        }
        return res;
    }
}
```

时间复杂度： O(n^2^)。数组中每个元素都需要向左向右扫描。    空间复杂度 O(1) 的额外空间。



**方法二：记忆化搜索（动态规划）**

暴力求解时每个i都需要向左向右扫描，那我们先把结果缓存下来就可以，不用每次都扫描。我们开两个数组 rightMax 和 leftMax 充当备忘录，leftMax[i] 表示位置 i 左边最高的柱子高度，rightMax[i] 表示位置 i 右边最高的柱子高度。预先把这两个数组计算好，避免重复计算

```Java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        int len = height.length;
        int[] leftMax = new int[len];
        int[] rightMax = new int[len];

        leftMax[0] = height[0];
        for(int i=1; i<len; i++)     // 记录i的左边最大值
            leftMax[i] = Math.max(height[i],leftMax[i-1]);
        
        rightMax[len-1] = height[len-1];
        for(int i=len-2; i>=0; i--)  // 记录i的右边最大值
            rightMax[i] = Math.max(height[i],rightMax[i+1]); 
        
        for(int i=1; i<len-1; i++)  // 最左右两侧不用计算，水量为0
            res += Math.min(leftMax[i],rightMax[i])-height[i];
        return res;
    }
}
```

时间复杂度：O(n)       空间复杂度：O(n)，使用了额外的 O(n) 空间用来放置2个数组。



**方法三：双指针**

不想用额外的空间，一次完成遍历，需要用到双指针。这题的双指针解法，建议先去双指针笔记部分看一下第11题，盛最多水的容器。方法二的一次遍历使用了一个指针，即 i，是按照一列一列的顺序去计算该列能盛的雨水。现在在一次遍历里使用两个指针，left从前遍历，right从后遍历，去计算 left 和 right 两个指针所在列能盛的雨水。但这里不能像方法二一样还是去找 left 和 right 各自左右两边的最大值，那这个双指针没有意义，不能在一次遍历里完成，而且没有必要这样做。下面是双指针法的重点：

定义 leftMax 为 left 指针左边的最大柱子高度，rightMax 为 right 指针右边的最大柱子高度，去比较 leftMax 和 rightMax 即可：

* 如果 leftMax 小，就计算 left 列能盛的雨水。**rightMax 可能不是 left 指针右边所有柱子里最大的，但无所谓，反正 leftMax 比右边其中一个柱子小了，由于短板效应，left 列的雨水只和 leftMax 有关**，其值 = leftMax - height[left]，计算完后右移左指针。如下图所示，如果 leftMax < rightMax，那么 left 所在列能盛的水就只和 leftMax 有关

    ![image-20220526004940929](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%9B%BE%E8%A7%A32.png)

* 如果 rightMax 小，那计算 right 列能盛的雨水，由于短板效应，right 列的雨水 = rightMax - height[ right ]，计算完后左移右指针

整体流程如图所示：

![628f3de89f543](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%9B%BE%E8%A7%A33.gif)

在移动中计算leftMax和rightMax时 ，如果是递增情况，max即当前列的高度，总雨水量便不会增加，不过也无所谓，代码里无非就是 res += 0

```Java
class Solution {
    public int trap(int[] height) {
        int res = 0;
        int len = height.length;
        int left = 0;
        int right = len-1;
        int leftMax = height[0];
        int rightMax = height[len-1];

        while(left <= right){
            // 先更新左右边界
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if(leftMax < rightMax){
                res += leftMax - height[left];
                left++;
            } else{
                res += rightMax - height[right];
                right--;
            }
        }
        return res;
    }
}
```

时间复杂度：O(n)  空间复杂度：O(1)







### 0300. 最长递增子序列LIS  132

给你一个整数数组 nums ，找到其中最长严格递增子序列（longest-increasing-subsequence）的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```
输入：nums = [10,9,2,5,3,7,101,18]  
输出：4  
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```



**方法一：暴力解法**

使用「回溯搜索算法」或者「位运算」的技巧，可以得到输入数组的所有子序列，时间复杂度为 O(2^N)。再对这些子串再依次判定是否为「严格上升」，时间复杂度 为O(N)，所以总的时间复杂度为：O(N⋅2^N )。

> 如果题目只问最优解，而没有问具体解，可以考虑使用动态规划，而不应该使用回溯算法（暴力搜索）搜索所有具体解。



**方法二：动态规划** ==牛客NC163==

首先考虑题目问什么，就尝试把什么定义成状态。题目问最长上升子序列的长度，其实可以把「子序列的长度」定义成状态，但是发现「状态转移」不好做。可以将状态定义为「以 nums[i] 结尾 的「上升子序列」的长度」。

1. 定义状态：

dp[i] 表示：以 nums[i] 结尾 的「上升子序列」的长度（不一定是最长！！！）。注意：**这个定义中 nums[i] 必须被选取**，且必须是这个子序列的最后一个元素；

2. 状态转移方程：

如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。**只要 nums[i] 严格大于在它位置之前的某个数nums[j]（可以用第二轮循环遍历），那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列，而且只可能是这个数结尾的上升子序列长度+1。**

所以 `dp[i] = max( dp[i] , dp[j] + 1)`

3. 初始化：

dp[i] = 1，每个字符都是长度为1，显然是长度为 1 的上升子序列。

4. 输出：

不能返回最后一个状态值，最后一个状态值只表示以 nums[len - 1] 结尾的「上升子序列」的长度，不一定是整个数组的LIS

5. 空间优化：

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。

清楚这个流程后，可以写写画画一个简单的用例，大概理解思路，再写代码

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        // dp[i]表示以nums[i]结尾的上升子序列的长度，不一定是最长！！！
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        int res = 1;
        // 第一轮循环遍历数组每个元素
        for(int i=0; i<nums.length; i++){
            // 第二轮循环遍历当前元素与之前元素的大小关系，符合条件考虑更新dp[i]
            for(int j = 0; j<i; j++){
                if(nums[j] < nums[i])
                    dp[i] = Math.max(dp[i], 1+dp[j]);
            }
            // 更新res，让其始终为最大的dp[i]
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

复杂度分析：

时间复杂度：O(N^2)，这里 N 是数组的长度，我们写了两个 for 循环，每个 for 循环的时间复杂度都是线性的；

空间复杂度：O(N)，要使用和输入数组长度相等的状态数组，因此空间复杂度是 O(N)。



**方法三：贪心策略+二分查找（也要求掌握）**  ==牛客NC164==

方法二一个很显著的缺点就是第二轮循环时要让当前元素跟在它之前每个数都进行比较。最好能不要这样，让当前元素尽可能的少比较。

我们可以分析出：已经得到的上升子序列的结尾的数**越小**，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列。即同样是长度为2的子序列，[2,3] 就比 [2,5] 好。因为后面如果有4的话，[2,3]组成[2,3,4]长度就是3了，但是[2,5]因为不满足条件，就没法组队了。

因此我们组成子序列的时候，不仅要让这个序列尽可能的长，而且要让子序列中的**上升的时候尽可能的缓慢**，[2,3]就比[2,5]上升的缓慢，这样就有机会能拼接出更长的上升子序列，这就是我们的贪心策略。

因此，我们需要用一个数组来保存 **所有** 上升子序列结尾的最小值，注意，这跟题目中的LCS完全不是一回事

1. 定义新状态（特别重要）

`tail[i]` 表示： **所有**长度为 `i + 1` 的上升子序列结尾的最小值。下标和长度有数值为 `1` 的偏差；

比如，示例 `[10, 9, 2, 5, 3, 7, 18, 4, 4]`，**所有**长度为 1 的上升子序列中，结尾最小的元素是2，因此`tail[0] = 2`，长度为 2 的**所有**上升子序列中，结尾最小的是子序列 `[2, 3]` ，因此 `tail[1] = 3`；

2. 状态转移方程：

既然是上升，那这个数组是严格递增的。因为是严格递增的，数组中最后一个值`tail[max]`就是最大值。遍历到新的元素时，有两种情况：

* 新元素比 tail[max] 大，那么很明显，这个数组的长度就要+1，即上升子序列长度+1，并且将新元素添加到数组的末尾。
    * 比如： 原来是 [10, 9, 2] ，长度为1的LCS结尾最小的值变化为10 -> 9 -> 2，所以2遍历完时，tail[0] = 2，现在遍历到[10, 9, 2, 5] 中的 5 时，5 比 2 大了，那么tail数组长度就得+1，并且这个新元素加进来，tail数组现在为 [ 2 , 5]，注意<font color=red>tail里并不是上升子序列，只是对应结尾的最小值</font>
* 新元素比 tail[max] 小，那么显然新元素更适合作为上升子序列的结尾，因此我们需要看之前所有长度的上升子序列，<font color=red>找到第一个结尾比新元素大的上升子序列，将其替换为新元素。</font>说白了就是在tail数组中，寻找第一个比新元素大的数字，然后替换掉它，这里使用二分法。这里是最难理解的！！！多举一些例子
    * 比如[10, 9, 2, 5, 3]中，5之后遍历到3，3没有5大，显然3比5更适合作为结尾，现在所有长度为1的上升子序列中，结尾最小的元素是2，2不比新元素大，pass；所有长度为2的上升子序列中，结尾最小的元素是5，5比3大了，所以将5改为3，即现在所有长度为2的上升子序列中，结尾最小的元素是3，tail = [2 , 3]
    * 将这个示例遍历完：下一个新元素是7，7比3大，所以tail长度+1，tail此时为 [2, 3, 7]；下一个新元素是18，tail更新为[2, 3, 7, 18]。
    * 下一个新元素是 4，4比18小了，显然4比18更适合作为结尾，现在所有长度为1的上升子序列中，结尾最小的元素是2，2不比新元素大，pass；所有长度为2的上升子序列中，结尾最小的元素是3，3不比新元素大，pass；所有长度为3的上升子序列中，结尾最小的元素是7，7比4大了，所以将7改为4，即现在所有长度为3的上升子序列中，结尾最小的元素是4，tail = [2 , 3 , 4]。所有长度为4的上升子序列中，结尾最小的元素是依然是18，元素4并不会影响长度为4的上升子序列，tail仍然 = [2 , 3 , 4, 18]。<font color=red>这里再次强调，`tail[i]` 表示： **所有**长度为 `i + 1` 的上升子序列结尾的最小值，tail数组本身并不是原数组里的上升子序列</font>
* 新元素和 tail[max] 相等，由于题目要求严格上升，什么都不做，因为以新元素结尾的最短的「上升子序列」已经存在；比如下一个新元素还是4，4在原数组中能够成新的严格上升子序列嘛，并不能，所以它没啥影响。但是为了简化代码，我们可以把这种情况放到`新元素比 tail[max] 小`这种情况中去，因为left还是会根据二分定位到相同的left，并替换相同值。即二分这段逻辑对`新元素比 tail[max] 小或者相等`是都适用的

3. 初始化：

遍历第 1 个数 nums[0]，直接放在有序数组 tail 的开头 tail[0] = nums[0]。

4. 输出：

有序数组 tail 的长度，就是所求的「最长上升子序列」的长度。

5. 空间优化：

无法优化空间。

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        // tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几
        int[] tail = new int[nums.length];
        tail[0] = nums[0];  // 初始化，nums[0]直接放在有序数组tail的开头
        int end = 0;        // end表示有序数组tail的最后一个已经赋值元素的索引
        for(int i=0; i<nums.length; i++){ // 从0或者1开始都行
            // 情况1：新元素比tail数组末尾元素大
            if(nums[i] > tail[end]){
                end++;
                tail[end] = nums[i];
            // 情况2：新元素小于或者等于tail数组末尾元素，二分法
            } else {
                int left = 0, right = end; // 注意二分里这个end就是索引，不是长度，所以不用-1
                while(left <= right){
                    int mid = left+(right-left)/2;
                    if(tail[mid]<nums[i]) 
                        left = mid + 1;
                    else 
                        right = mid-1;
                }
                // 二分结束之后，left就是要更新的地方，参考二分里35题，其实tail[mid]==nums[i]也是可能的，但不用单独判断，也归到else里让right-1，最后while循环结束时，left会加回到mid
                tail[left] = nums[i];            
            } 
        }
        // 此时 end 是有序数组 tail 最后一个有效元素的索引，题目要求返回的是长度，因此 +1 后返回
        end++;
        return end;
    }
}
```

时间复杂度：O(NlogN)，空间复杂度O(N)



二分部分写完整的话，就是下面这样

```Java
int left = 0, right=end;
while(left <= right){
    int mid = left + (right-left)/2;
    if(tail[mid] == nums[i]) {
        left = mid;
        break;
    }                      
    if(tail[mid] < nums[i])
        left = mid+1;       
    else 
        right = mid-1; 
}
tail[left] = nums[i];
```

新元素和 tail[max] 相等的情况如果单独拿出来写，就是下面的结构

```Java
for(int i=0; i<nums.length; i++){
    if(nums[i] > tail[end]){ // 情况1
        ...     
    } else if(nums[i] < tail[end]){ // 情况2
		...
        }
        tail[left] = nums[i];  
    } else{ // 情况3：新元素和tail数组末尾元素相等，pass
        continue;
    }
}
```



**扩展问题，打印最长的LIS，如果有多个答案，输出字典序最小的那个**  ==牛客NC91==

（打印可能有很多方式，可能是打印字典序最小的最长LIS，可能是打印所有最长LIS）

保留前面的 tail[i] 数组，其仍然是**所有**长度为 `i + 1` 的上升子序列结尾的最小值。tail数组的长度，即代码中的end能让我们知道要输出的LIS长度是多少，但是怎么知道哪些子序列的长度等于这个值呢。所以需要额外再记录一个数组，maxLen[i]，他表示的是 以 nums[i] 为结尾的最长子序列的长度。这个数组不难维护，其实就是每次更新tail的时候，把end赋给maxLen[i]即可，或者是二分完了把left赋给maxLen，因为left就是tail要更新的地方。

```Java
// 情况1：新元素比tail数组末尾元素大
if(nums[i] > tail[end]){
    end++;
    tail[end] = nums[i];
    maxLen[i] = end+1;  // end是索引，长度要+1
    // 情况2：新元素小于或者等于tail数组末尾元素，二分法
} else {
    int left = 0, right = end; 
    while(left <= right){
        int mid = left+(right-left)/2;
        if(tail[mid]<nums[i]) 
            left = mid + 1;
        else 
            right = mid-1;
    }
    tail[left] = nums[i];  
    maxLen[i] = left+1;  // left是索引，长度要+1
} 
```

用一个示例来更好的理解：

示例 `[10, 9, 2, 5, 3, 7, 6, 19, 18, 4]` ，相比之前加了一个6和19，构造相同长度的情况

不难推出tail数组为 [2，3，4，18]，maxLen数组为 [1，1，1，2，2，3，3，4，4，3]

（1）输出字典序最小：现在tail数组的长度，即代码中的end就是我们要输出的LIS长度（在本例中为4），通过maxLen数组，我们知道了nums[6] （即19）和 nums[7]（即18）结尾的子序列，就是我们要输出的LIS，他们都是长度为4的，怎么写这个代码呢？可以从nums后面往前面遍历，在这个遍历过程中，如果maxLen数组有一个值等于4，那么此时的nums[i]就是这个LIS的末尾值。而且由于 maxLen保存的已经是最长的子序列了，所以，第一次碰到的就是字典序最小的情况，比如示例中，倒序遍历，第一次碰到maxLen=4是18这个元素，它一定比19小，因为如果它不比19小，maxLen就不是4了，而是5，所以能够确定最后输出序列的最后一位就是1。接下来类似，最后一位我们已经解决了，是18，我们要解决的就是倒数第二位，也就是 maxLen=3，从刚才的18开始继续从后向前遍历，看看maxLen数组有哪一个值等于3，仍然是第一次碰到等于3的就是字典序最小的，比如示例中7结尾和6结尾maxLen都是3，但6是maxLen中第一次等于3的，它一定比7字典序小，否则它的maxLen就是4了。以此类推，可以写出下面的代码

```java
for (int i = nums.length - 1; i >= 0; i--) {
    if (maxLen[i] == end) { // 不能用tail.length,我们初始化是按nums长度来的
        res[end - 1] = nums[i];
        end--;
    }
}
```

结合起来，打印最小字典序的LIS代码为：

```Java
public class Solution {
    public int[] LIS (int[] arr) {
        if(arr.length == 0) return new int[0];
        int len = arr.length;
        int[] tail = new int[len];   // 长度为i的LIS的末尾元素
        int[] maxLen = new int[len]; // 末尾是arr[i]的LIS长度
        tail[0] = arr[0];
        maxLen[0] = 1;
        int end=0;
        for(int i=1; i<len; i++){
            if(arr[i] > tail[end]){
                end++;
                tail[end] = arr[i];
                maxLen[i] = end+1;
            } else {
                int left = 0, right = end;
                while(left <= right){
                    int mid = left + (right-left)/2;
                    if(tail[mid] < arr[i])
                        left = mid+1;
                    else 
                        right = mid-1;
                }
                tail[left] = arr[i];
                maxLen[i] = left+1;
            }
        }
        int[] res = new int[end+1];
        for(int i=len-1; i>=0; i--){
            if(maxLen[i] == end+1){
                res[end] = arr[i];
                end--;
            }
        }
        return res;
    }
}
```

注意上面最好不要按照三种情况去写，即把tail[len]等于nums[i]单独拿出来写个continue，在这种情况下，不仅仅是算最大长度，还要算具体序列，所以等于的情况也会对maxLen有影响，之前在牛客上提交按照等于单独拿出来写个continue，有一个case没通过，[1,3,8,6,5,2,5]，在遍历最后一个5之前，tail是[1,2,5] maxLen是[1,2,3,3,3,2]，如果把等于单独拿出来写个continue，tail数组没影响，但maxLen最后一位就不对了。现在写的时候虽然是懂的，不知道以后再看这段话能不能体会到，如果不能，就按照笔记来就行，不要把等于单独拿出来写，例如下面这样

```Java
for(int i=0; i<nums.length; i++){
    if(nums[i] > tail[end]){ // 情况1
        ...     
    } else if(nums[i] < tail[end]){ // 情况2
		...
        }
        tail[left] = nums[i];  
    } else{ // 情况3：新元素和tail数组末尾元素相等，pass
        continue;
    }
}
```



如果是输出全部序列呢？

如果是输出最大字典序呢？再结合codetop评论研究一下



### 0053. 最大子数组和  212

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个**连续**部分。[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```



**方法一：动态规划**

有最优要求，而且题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

1. 定义状态

`dp[i]`：表示以 `nums[i]` **结尾** 的 **连续** 子数组的最大和。

2. 状态转移方程

这样定义状态的**重点在于 `nums[i]` 一定会被选取**，以 `nums[i]` 结尾的连续子数组与以 `nums[i - 1]` 结尾的连续子数组只相差一个元素 `nums[i]` ，不难得出：`dp[i] = Math.max(nums[i], dp[i-1]+nums[i])`，其实也就是两个选择，如果 dp[i-1]+nums[i] < nums[i]，还不如重新以 nums[i]  作为数组开头，否则就把 nums[i] 添加进最大和的数组。需要时刻铭记状态 dp[i] 必须是以`nums[i]` **结尾** 的子数组最大和

这里极容易想错为`dp[i] = Math.max(dp[i-1], dp[i-1]+nums[i])`。这是不对的，这种是简单的把数组前面的所有数字都算进去，举反例很容易

3. 初始化

dp[0]为nums[0]

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0; // 按照题目范围其实可以不加
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = Integer.MIN_VALUE;
        for(int i=1; i<nums.length; i++){
            // 自己写容易写成dp[i-1],dp[i-1]+nums[i]
            dp[i] = Math.max(nums[i], dp[i-1]+nums[i]);
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

4. 空间优化

使用「滚动变量」的方式将代码进行优化。用一个变量pre保存dp[i-1]的值

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        int pre = nums[0]; 
        int res = Integer.MIN_VALUE;
        for(int i=1; i<nums.length; i++){
            pre = Math.max(nums[i], pre+nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}
```

**时间复杂度**：O(N)，这里 N 是输入数组的长度。空间复杂度O(1)，未优化就是O(n)



**方法二：贪心算法**

如果 -2, 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：**当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”**，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。

```java 
class Solution {
    public int maxSubArray(int[] nums) {
        int sum = 0;
        int res = nums[0];
        for(int i=0; i<nums.length; i++){
            sum += nums[i];
            res = Math.max(res,sum); // 取区间累计的最大值
            if(sum < 0){
                sum = 0;             // 重置最大子序起始位置，因为和为负数一定是拉低总和
            }
        }
        return res;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



本题扩展一：打印最大和的连续子数组

使用dp数组版本：dp[i]的定义不变，nums[i]仍然是必取的，那核心点就在于要判断dp[i-1]是否为正数

* 如果是正数，不管nums[i]正负，因为反正它要取，这是我们dp的定义决定的，继续当前序列，更新长度

    ```
    dp[i] = dp[i-1] + nums[i];
    len++;
    ```

* 如果是负数，直接以nums[i]为起点，更新起点和长度

    ```
    dp[i] = nums[i];
    start = i;  // 更新起点
    len = 1;    // 更新长度
    ```

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        int[] dp = new int[nums.length];  // 记录nums[i]结尾的最大和
        dp[0] = nums[0];
        int res = Integer.MIN_VALUE;      // 记录整体最大和
        int maxStart = 0, maxLen = 1;     // 记录最大连续子序列的起点和长度
        int start =0, len = 1;            // 记录连续子序列的起点和长度

        for(int i=1; i<nums.length; i++){
            // 由于要判断是继续当前序列，还是另起新序列，所以必须要分情况讨论
            if(dp[i-1]>0){  // 继续当前序列
                dp[i] = dp[i-1] + nums[i];
                len++;      // 更新长度
            } else{         // 另起新序列
                dp[i] = nums[i];
                start = i;  // 更新起点
                len = 1;    // 更新长度
            }
            
            if(dp[i]>res){  // 更新最大和时，也要更新对应的起点和长度
                maxStart = start;
                maxLen = len;
                res = dp[i];
            }
        }
        System.out.println(maxLen);  //打印最大和子序列的长度
        System.out.println(Arrays.toString(Arrays.copyOfRange(nums, maxStart, maxStart+maxLen)));                  //打印最大和子序列
        return res;
    }
}
```

空间优化版本的打印，此处省略，照着上面优化参考就行













## 二维dp

### 0152. 乘积最大子数组  45

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。测试用例的答案是一个 32位 整数。子数组 是数组的连续子序列。[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/)

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```



**方法一：动态规划**

数组的动态规划问题、子序列、连续子序列的一个常见的状态定义是：以**下标 i 结尾**的连续子序列的乘积的最大值。最后把整个 dp 数组遍历一遍求最大值即可。因此状态转移方程是：

```
dp[i] = max(dp[i - 1] * nums[i], nums[i])
```

说明：牢记状态的定义，一定以下标 i 结尾，即：乘积**数组中 nums[i] 必须被选取**。但本题中如果 dp[i - 1] 是负数，乘上 nums[i] 还是负数，倒不如另起炉灶。

**如果 nums[i] 是负数该怎么办呢？dp[i - 1] 是正数的时候，越乘越小，dp[i - 1] 是负数的时候，越乘越大，于是我们可能就需要记录一下负数的那个最小数。**（由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值）

**遇到这样的问题，其实就在提示我们状态不够用了。因此，需要在原来的一维 dp 后面新增一个状态。**

针对这道题，第 2 维状态只需要两个：

用 0 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最小值；

用 1 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最大值。

当 nums[i] = 0 的时候包含在上面二者之中，无需单独讨论。

所以状态为：

dp[i] [1] 表示：以 nums[i] 结尾的连续子序列的乘积的最大值；

dp[i] [0] 表示：以 nums[i] 结尾的连续子序列的乘积的最小值。

（其实用两个一维数组也行，语义还会更清晰一些）

![img](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/152%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-%E5%9B%BE%E8%A7%A3.png)

```Java
class Solution {
    public int maxProduct(int[] nums) {
        if(nums.length == 0) return 0;
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0]; // 记录最小值
        dp[0][1] = nums[0]; // 记录最大值
        int res = dp[0][1];
        for(int i=1; i<nums.length; i++){
            if(nums[i] >= 0){
                dp[i][0] = Math.min(nums[i], dp[i-1][0]*nums[i]);
                dp[i][1] = Math.max(nums[i], dp[i-1][1]*nums[i]);
            } else{
                dp[i][0] = Math.min(nums[i], dp[i-1][1]*nums[i]);
                dp[i][1] = Math.max(nums[i], dp[i-1][0]*nums[i]);
            }
            res = Math.max(res,dp[i][1]);
        }
        return res;
    }
}
```

时间复杂度：O(N)，空间复杂度O(n)



空间优化，用变量交替滚动代替数组

```Java
class Solution {
    public int maxProduct(int[] nums) {
        int preMax = nums[0];
        int preMin = nums[0];
        int curMax, curMin;
        int res = nums[0];
        for(int i=1; i<nums.length; i++){
            if(nums[i]>0){
                curMax = Math.max(nums[i], preMax*nums[i]);
                curMin = Math.min(nums[i], preMin*nums[i]);
            } else{
                curMax = Math.max(nums[i], preMin*nums[i]);
                curMin = Math.min(nums[i], preMax*nums[i]);
            }
            res = Math.max(res, curMax);
            preMax = curMax;
            preMin = curMin;
        }
        return res;
    }
}
```

时间复杂度：O(N)，空间复杂度O(1)



本题扩展一：打印这个乘积最大的子数组

首先看一下53题打印的逻辑，设立当前起点、长度，需要判断何时继续序列，何时把当前节点作为起点

这就要清楚for循环里判断逻辑的本质，在对数组遍历，在经过每个元素的时候，有以下四种情况：

- 如果该元素为正数：
    - 如果到上一个元素为止的最大乘积也是正数，那么直接乘上就好了，同样的最大乘积也会变得更大，继续序列。（前面要么没有负数，要么偶数个负数，最大子数组就是从头到该元素）
    - 如果到上一个元素为止的最大乘积是负数，那么最大乘积就会变成该元素本身，且连续性被断掉，更新起点（最大子数组就是本身）
- 如果该元素为负数：
    - 如果到上一个元素为止的最大乘积是正数，那么最大乘积就会不变，且连续性被断掉，更新起点（最大子数组就是本身）
    - 如果到上一个元素为止的最大乘积也是负数，那么直接乘上就好了，同样的最大乘积也会变得更大，继续序列。（前面有奇数个负数，最大子数组是从头到该元素）

因此可以写出：

```Java

```





### 0647. 回文子串

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```
输入：s = "abc"  输出：3
解释：三个回文子串: "a", "b", "c"

输入：s = "aaa"  输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```



**方法一：暴力**

两层for循环，遍历区间起始位置和终止位置，然后判断这个区间是不是回文。时间复杂度：O(n^3^)



**方法二：动态规划**

动规五部曲：

1）确定dp数组（dp table）以及下标的含义

布尔类型的dp[i] [j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i] [j]为true，否则为false。

2）确定递推公式

在确定递推公式时，就要分析如下几种情况。整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

* 当s[i]与s[j]不相等，那没啥好说的了，dp[i] [j]一定是false。

* 当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

    - 1. 下标 i 与 j 相同，同一个字符例如a，当然是回文子串

    - 2. 下标 i 与 j 相差为1（如aa）或2（如aba）也是回文子串

    - 3. 下标 i 与 j 相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看 i 到 j 区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。

以上三种情况分析完了，那么递归公式如下：res是记录个数

```Java
if (s[i] == s[j]) {
    if (j - i < 3) { // 情况一 和 情况二
        dp[i][j] = true;
    } else { // 情况三
        dp[i][j] = dp[i+1][j-1];
    }
}
```

注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i] [j]初始化的时候，就初始为false。

3）dp数组初始化

dp[i] [j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。所以dp[i] [j]初始化为false。

4）确定遍历顺序

首先从递推公式中可以看出，情况三是根据dp[i + 1] [j - 1]是否为true，在对dp[i] [j]进行赋值true的。

dp[i + 1] [j - 1] 在 dp[i] [j]的左下角

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  height=400>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE1.png" height=400>
</div>

所以在遍历时要保证从左到右遍历，即 j 要++，不能让 j --，因为右边的dp[i] [j]需要用到左边的值，最好也保证从下往上的顺序（自己写的时候从上往下也可以，但从下往上显然更符合逻辑，反正只要保证从左往右即可）这样保证dp[i + 1] [j - 1]都是经过计算的。

有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1] [j - 1]都是经过计算的。

**注意因为dp[i] [j]的定义，所以j一定是大于等于i的，那么在填充dp[i] [j]的时候一定是只填充右上半部分**。所以第一层for循环写 i 是最直观的

```Java
class Solution {
    public int countSubstrings(String s) {
        int res = 0, len = s.length();
        if(s==null || len < 1) return 0;
        boolean[][] dp = new boolean[len][len];
        for(int i=len-1; i>=0; i--){
            for(int j=i; j<len; j++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j-i < 3) 
                        dp[i][j] = true;
                    else 
                        dp[i][j] = dp[i+1][j-1];
                    }
                if(dp[i][j]) 
                    res++;
                }            
        }
        return res;
    }
}
```

关于遍历顺序，两层for循环换为下面的同样适合，即从左往右，从上往下，不过多纠结了，知道意思即可

```Java
for(int j=0; j<len; j++)
    for(int i=0; i<=j; i++)
```

关于if判断，自然也可以简洁写，但没必要，分开写其实更直观易懂

```Java
if (s[i] == s[j] && (j - i <= 1 || dp[i + 1][j - 1])) {
    res++;
    dp[i][j] = true;
}
```

时间复杂度：O(N^2^)，空间复杂度O(N^2^)



**方法三：中心扩散/双指针法**

动态规划的空间复杂度是偏高的，我们再看一下双指针法。首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。**在遍历中心点的时候，要注意中心点有两种情况**。

一个元素可以作为中心点（aba），两个元素也可以作为中心点（abba）。那么有人问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。

我们可以设计一个方法，兼容以上两种情况：

如果传入重合的下标，进行中心扩散，此时得到的回文子串的长度是奇数；
如果传入相邻的下标，进行中心扩散，此时得到的回文子串的长度是偶数。

**这两种情况可以放在一起计算，但分别计算思路更清晰容易理解，我倾向于分别计算**，放在一起计算代码稍微有些复杂，代码如下：

```Java
class Solution {
    public int countSubstrings(String s) {
        int res=0, len = s.length();
        for(int i=0; i<len; i++){
            res += extend(s,i,i,len);
            res += extend(s,i,i+1,len);
        }
        return res;
    }

    public int extend(String s, int i, int j, int len){
        int res = 0;
        while(i>=0 && j<len && s.charAt(i)==s.charAt(j)){
            i--;
            j++;
            res++;
        }
        return res;
    }
}
```

放在一起计算的代码，只是贴在这里，关于中心点的计算稍微复杂了一些

```Java
class Solution {
    public int countSubstrings(String s) {
        int len, ans = 0;
        if (s == null || (len = s.length()) < 1) return 0;
        //总共有2 * len - 1个中心点
        for (int i = 0; i < 2 * len - 1; i++) {
            //通过遍历每个回文中心，向两边扩散，并判断是否回文字串
            //有两种情况，left == right，right = left + 1，这两种回文中心是不一样的
            int left = i / 2, right = left + i % 2;
            while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
                //如果当前是一个回文串，则记录数量
                ans++;
                left--;
                right++;
            }
        }
        return ans;
    }
}
```

时间复杂度：O(N^2^)，空间复杂度O(1)



**方法四：Manacher算法**

 马拉车: 知道它时间复杂度是O(n)，空间复杂度也是O(n)即可，面试非要你默出来的话，可能是想为难你



5. 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```
输入：s = "babad"  输出："bab"
解释："aba" 同样是符合题意的答案

输入：s = "cbbd"  输出："bb"
```



**方法一：动态规划**

就是上一题把计数换成记最大长度，额外记录一个起始坐标，更新最大长度时更新起始坐标，不多解释了

```Java
class Solution {
    public String longestPalindrome(String s) {
        int maxLen = 0, len = s.length(), begin=0;
        if(s==null || len < 1) return "";
        boolean[][] dp = new boolean[len][len];
        for(int i=len-1; i>=0; i--){
            for(int j=i; j<len; j++){
                if(s.charAt(i) == s.charAt(j)){
                    if(j-i < 3) 
                        dp[i][j] = true;
                    else 
                        dp[i][j] = dp[i+1][j-1];
                    }
                if(dp[i][j]) 
                    if(j-i+1 > maxLen){
                        begin = i;
                        maxLen = j-i+1;
                    }
                }            
        }
        return s.substring(begin,begin+maxLen);
    }
}
```

时间复杂度：O(N^2^)，空间复杂度O(N^2^)



**方法二：中心扩散/双指针法**

和上一题的解法也类似，由于我们要同时返回最大长度和起始坐标，所以这里返回一个长度为2的数组

```Java
class Solution {
    public String longestPalindrome(String s) {
        int maxLen=0, len = s.length();
        int[] res = new int[2];   // res数组保存最终结果
        for(int i=0; i<len; i++){
            int[] even = extend(s,i,i,len);
            int[] odd = extend(s,i,i+1,len);
            int[] max = even[0]>odd[0] ? even : odd;  // max数组保存每轮遍历i的临时结果
            if(max[0]>maxLen){   // 更新res
                res = max;
                maxLen = max[0];
            }
        }
        return s.substring(res[1], res[1] + res[0]);
    }

    public int[] extend(String s, int i, int j, int len){
        int res = 0;
        while(i>=0 && j<len && s.charAt(i)==s.charAt(j)){
            i--;
            j++;
            res++;
        }
        return new int[]{(j-1)-(i+1)+1, i+1};// 返回最大长度和起始索引，注意循环里i和j多走了一步
    }
}
```

时间复杂度：O(N^2^)，空间复杂度O(1)



### 0516. 最长回文子序列

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

```
输入：s = "bbbab"   输出：4
解释：一个可能的最长回文子序列为 "bbbb"
```



与上面两题的差别在于，是子序列，即可以不连续









### 1143. 最长公共子序列  LCS

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列（longest-common-subsequence）的长度。如果不存在 公共子序列 ，返回 0 。 [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)   ==牛客NC165==

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```



**方法一：动态规划**

求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[ 0:i ] 中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i] [j] ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。

1. 状态定义

比如对于本题而言，可以定义 dp[i] [j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列的长度。 

注：text1[0:i-1] 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含。之所以 dp[i] [j] 的定义不是 text1[0:i] 和 text2[0:j] ，是为了方便当 i = 0 或者 j = 0 的时候，dp[i] [j]表示的为空字符串和另外一个字符串的匹配，这样 dp[i] [j] 可以初始化为 0.

2. 状态转移方程

知道状态定义之后，我们开始写状态转移方程。

* 当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i] [j] = dp[i - 1] [j - 1] + 1；
    * 举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度，结果为0 + 1 = 1。
* 当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，最长公共子序列长度无法延长，那么此时的状态 dp[i] [j] 应该是 dp[i - 1] [j] 和 dp[i] [j - 1] 的最大值。
    * 举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于下面两种情况的最大值
    *  ① ace 和 b 的最长公共子序列长度0  
    * ② ac 和 bc 的最长公共子序列长度1，即 1。

综上状态转移方程为：

```Java
if(text1[i - 1] == text2[j - 1])
    dp[i][j] = dp[i - 1][j - 1] + 1
else 
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```

即有三个方向可以推出dp[i] [j]，以`text1 = "abcde", text2 = "ace" `为例画出dp图：

<div align="center">
   <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%9B%BE%E8%A7%A3.png"  height=300>
    <img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%9B%BE%E8%A7%A31.png" height=500>
</div>

3. 状态的初始化

初始化就是要看当 i = 0 与 j = 0 时， dp[i] [j] 应该取值为多少。

当 i = 0 时，dp[0] [j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0.
当 j = 0 时，dp[i] [0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
综上，当 i = 0 或者 j = 0 时，dp[i] [j] 初始化为 0.

4. 遍历方向与范围

由于 dp[i] [j] 依赖与 dp[i - 1] [j - 1] , dp[i - 1] [j], dp[i] [j - 1]，所以 i 和 j 的遍历顺序肯定是从小到大的。
另外，由于当 i 和 j 取值为 0 的时候，dp[i] [j] = 0，而 dp 数组本身初始化就是为 0，所以，直接让 i 和 j 从 1 开始遍历。遍历的结束应该是字符串的长度为 len(text1) 和 len(text2)。

5. 最终返回结果

由于 dp[i] [j] 的含义是 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。我们最终希望求的是 text1 和 text2 的最长公共子序列。所以需要返回的结果是 i = len(text1) 并且 j = len(text2) 时的 dp[len(text1)] [len(text2)]。

```Java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        // dp[i] [j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列
        // 两个维度容量+1，方便i,j从1开始遍历，dp[0][j]和dp[i][0]默认都为0，不用初始化
        int[][] dp = new int[m+1][n+1];
        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

时间复杂度：O(mn)，空间复杂度：O(mn)



**扩展问题：打印LCS，没有LCS就输出"-1" ** ==牛客NC92==

方法一：来自NC92的讨论区，上面的dp存放的是长度，现在直接让它存放LCS内容，剩余的逻辑都是一样的，简单粗暴，就是感觉这个内存容易超限制，不过牛客能全AC

```Java
public String LCS (String s1, String s2) {
    int m=s1.length(),n=s2.length();
    String[][]dp=new String[m+1][n+1];// s1的第i个元素和s2的第j个元素时公共子序列的内容
    for(int i=0;i<=m;i++){
        for(int j=0;j<=n;j++){
            if(i==0||j==0) dp[i][j]="";
            else if(s1.charAt(i-1)==s2.charAt(j-1)){//如果相同的话
                // dp[i][j]=dp[i-1][j-1]+1;
                dp[i][j]=dp[i-1][j-1]+s1.charAt(i-1);
            }
            else {
                // dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                dp[i][j]=dp[i-1][j].length()>dp[i][j-1].length()?dp[i-1][j]:dp[i][j-1];
            }
        }
    }
    if(dp[m][n]=="") return "-1";
    return dp[m][n];
}
```

方法二：下面的逻辑好像说得通，是第一次写的，但做NC92时没能通过所有case，7个过了5个，也有人说牛客的case有bug。

从上面的dp图能够看出，真正让LCS长度增加的，其实就是第一种情况，即`text1[i - 1] == text2[j - 1]`，所以我们要找的LCS序列，就隐藏在这些时候，现在我们已经得到了整个dp数组，我们可以从右下角往左上角推，只有当右下角的数同时大于左侧和上面的数，才是LCS长度增加的情况，其实就是下面这条语句

```
if (dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1])
```

满足这个条件，就把当前的 i 位于text1中的字符存下来，最后反转字符串，就能得到LCS

```Java
StringBuilder sb = new StringBuilder();
for(int i=m; i>0; i--){
    for(int j=n; j>0; j--){
        if (dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1]){
            sb.append(s1.charAt(i-1));
        }
    }
}
return sb.reverse().toString();
```

但其实这样还不够，因为还没有考虑其他子串的影响，以牛客NC92示例来说，text1 = "B1D23A456A" , text2 = "1A2C3D4B56"，dp列出来就是下面的样子，红色圆和直线就是理想的LCS为“123456”。但三处蓝色对角线，也满足上面 if 的判断，所以就会让LCS输出为“B1D23A456”。其实这样是不对的，因为在dp的遍历过程中，子串“B1D23A”和"1A"也有共同子串，这就对我们最终的目标产生了干扰

![image](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E5%9B%BE%E8%A7%A32.png)

解决办法就是额外维护一个计数变量count，其初始值为最大LCS长度dp[m] [n]，在原来的判断上再添加一层，只有当count == dp[i] [j] 时，才是有效的LCS，添加进字符串，同时把count-1，即保证dp数组遍历的时候，是在整个近乎对角线上进行遍历，这样就不会受其他子串的影响

```Java
StringBuilder sb = new StringBuilder();
int count = dp[m][n];
for(int i=m; i>0; i--){
    for(int j=n; j>0; j--){
        if (dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1]){
            if(dp[i][j] == count){
                sb.append(s1.charAt(i-1));
                count--;
            }                       
        }
    }
}
return sb.reverse().toString();
```

牛客NC92还要求如果LCS为空，则返回"-1"，所以整体代码为

```Java
public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m+1][n+1]; // dp[i][j]是s1中[0,i-1]、s2[0,j-1]的LCS长度
        for(int i=1; i<=m; i++){
            for(int j=1; j<=n; j++){
                if(s1.charAt(i-1) == s2.charAt(j-1))
                    dp[i][j] = dp[i-1][j-1]+1;
                else 
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        StringBuilder sb = new StringBuilder();
        int count = dp[m][n];
        for(int i=m; i>0; i--){
            for(int j=n; j>0; j--){
                if (dp[i][j] > dp[i-1][j] && dp[i][j] > dp[i][j-1]){
                    if(dp[i][j] == count){
                        sb.append(s1.charAt(i-1));
                        count--;
                    }                       
                }
            }
        }
        return (sb.length() == 0) ? "-1" : sb.reverse().toString();
    }
}
```

方法三：不知道能不能称为第三种方法，虽然代码形式不同，但逻辑和方法二差不多，也是从右下角往左上角遍历，但比较的还是字符串，如果字符相等，就计入最后结果，并向左上角移动，否则，当上部的值大于左边则向上移动，否则向左移动。

```Java
//找出一个最长的公共子序列
StringBuilder res = new StringBuilder();
int len1 = m;
int len2 = n;
while(len1 > 0 && len2 > 0){
    if(s1.charAt(len1 - 1) == s2.charAt(len2 - 1)){
        res.append(s1.charAt(len1 - 1));
        len1--;
        len2--;
    } else {
        if(dp[len1 - 1][len2] > dp[len1][len2 - 1]){
            len1--;
        } else {
            len2--;
        }
    }
}
return (res.length() == 0) ? "-1" : res.reverse().toString();
```





### 0062. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？[62. 不同路径](https://leetcode.cn/problems/unique-paths/)



动态规划

我们令 dp[i] [j] 是从左上角走到 (i, j) 的路径数量。由于我们每一步只能从向下或者向右移动一步，因此要想走到 (i,j)，如果向下走一步，那么会从(i−1,j) 走过来；如果向右走一步，那么会从 (i,j−1) 走过来。因此我们可以写出动态规划转移方程。动态方程：dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]

![img](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E5%9B%BE%E8%A7%A3.png)

注意，对于第一行 dp[0] [j]，或者第一列 dp[i] [0]，由于都是在边界，所以只能为 1

```Java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < n; i++) dp[0][i] = 1;
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];  
    }
}
```

时间复杂度：O(m * n)  空间复杂度：O(m * n)

优化：因为我们每次只需要 dp[i-1] [j],dp[i] [j-1]，所以我们只要记录这两个数



### 0063. 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。[63. 不同路径 II ](https://leetcode.cn/problems/unique-paths-ii/)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

动态规划

* 如果网格 (i, j)上有障碍物，则 dp[i] [j] 值为 0，表示走到该格子的方法数为 0；
* 否则网格 (i, j) 可以从网格 (i - 1, j) 或者 网格 (i, j - 1) 走过来，因此走到该格子的方法数为走到网格 (i - 1, j)和网格 (i, j - 1) 的方法数之和，即 dp[i, j] = dp[i - 1, j] + dp[i, j - 1]

```Java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return 0;
        }
        
        // 定义 dp 数组并初始化第 1 行和第 1 列。
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }

        // 根据状态转移方程 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] 进行递推。
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 0) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```







### 0072. 编辑距离



### xxxx.背包问题

考题频率貌似不是很高，除了322 518，第一轮暂时不看，



### 0322. 零钱兑换



### 0518. 零钱兑换Ⅱ





## 多维dp

### 0123. 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)



**方法一：动态规划**

这题就得用真正的dp了，刷第二轮的时候注意写一下































































# 贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。

贪心算法更多考察平时对贪心策略的积累，其区分度不大，能想出贪心策略就会，否则就不会，不像其他算法有很多优化的空间，因此在面试时比较少见，笔试里占的篇幅也不大，可能5题里有1题，所以平常可以稍微多练习下贪心策略，多看点题目。整个校招的过程不应该将此作为核心重点。 

贪心算法的在笔试时的解题套路：

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明（笔试压根没这个时间，而且也太难了，全是数学证明）





# 大数据题目







# 其他





## 快速幂

### 50. Pow(x,n)



## 进制相关问题

[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

[415. 字符串相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-strings/)

[字节高频题---36进制加法 - 代码先锋网 (codeleading.com)](https://www.codeleading.com/article/24885751549/)







## 前缀和

 





## 比较器

### 179. 最大数  42

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。[179. 最大数 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-number/)

```
输入：nums = [3,30,34,5,9]
输出："9534330"
```



**方法一：自定义比较器**

重新定义排序规则：(a,b) -> (b+a).compareTo(a+b)

```Java
class Solution {
    public String largestNumber(int[] nums) {
        if (nums == null || nums.length == 0) return "";
        int len = nums.length;
        StringBuilder res = new StringBuilder();
        // 将整数数组转为字符串数组
        String[] strs = new String[len];
        for(int i=0; i<len; i++) strs[i] = String.valueOf(nums[i]);        
        // 重新定义排序规则：(a,b) -> (b+a).compareTo(a+b)
        // 比如["10","2"]，并不是比"10"和"2"谁大谁小，而是比"102"和"210"谁大谁小，大的放前面
        Arrays.sort(strs, (a,b) -> (b+a).compareTo(a+b));
        // 字符串数组都是0的情况下，只输出一个0
        if (strs[0].equals("0")) return "0";
        // 排完序之后将字符串数组依次放入结果res中
        for(int i=0; i<len; i++) res.append(strs[i]);
        return res.toString();
    }
}
```





### 剑45. 把数组排成最小的数  17

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。[剑指 Offer 45. 把数组排成最小的数 - 力扣（LeetCode）](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```
输入: [3,30,34,5,9]
输出: "3033459"
```



**方法一：自定义比较器**

重新定义排序规则：(a,b) -> (a+b).compareTo(b+a)

```Java
class Solution {
    public String minNumber(int[] nums) {
        if (nums == null || nums.length == 0) return "";
        int len = nums.length;
        StringBuilder res = new StringBuilder();
        // 将整数数组转为字符串数组
        String[] strs = new String[len];
        for(int i=0; i<len; i++) strs[i] = String.valueOf(nums[i]);        
        // 重新定义排序规则：(a,b) -> (a+b).compareTo(b+a)
        // 比如["10","2"]，并不是比"10"和"2"谁大谁小，而是比"102"和"210"谁大谁小，大的放前面
        Arrays.sort(strs, (a,b) -> (a+b).compareTo(b+a));
        // 该题不用排除首字符为0的情况 if (strs[0].equals("0")) return "0";
        // 排完序之后将字符串数组依次放入结果res中
        for(int i=0; i<len; i++) res.append(strs[i]);
        return res.toString();
    }
}
```



## 其他题目，暂时未分类

==无序数组中找到所有比左边大比右边小的元素（遍历两次）==





### 54. 螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```



方法一：遍历

首先设定上下左右边界，其次向右移动到最右，此时第一行因为已经使用过了，可以将其从图中删去，体现在代码中就是重新定义上边界。即让 up = up+1。判断若重新定义后，上下边界交错，表明螺旋矩阵遍历结束，跳出循环，返回答案。

若上下边界不交错，则遍历还未结束，接着向下向左向上移动，操作过程与第一，二步同理。例如向下移动时，最后一列已经用完了，需要重新定义右边界，即让 right = right-1

定义边界的顺序，上右下左，和题目要求的顺时针要求一样

不断循环以上步骤，直到某两条边界交错，跳出循环，返回答案

```Java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        LinkedList<Integer> res = new LinkedList<>();
        if(matrix.length == 0) return res;
        int up = 0, down = matrix.length-1, left = 0, right = matrix[0].length-1;
        while(true){
            for(int col = left; col<=right; col++) res.add(matrix[up][col]);
            if(++up > down) break;      // 重新定义上边界
            for(int row = up; row <= down; row++) res.add(matrix[row][right]);
            if(--right < left) break;   // 重新定义右边界
            for(int col = right; col>=left; col--) res.add(matrix[down][col]);
            if(--down < up) break;      // 重新定义下边界
            for(int row = down; row >= up; row--) res.add(matrix[row][left]);
            if(++left > right) break;   // 重新定义左边界
        }
        return res;
    }
}
```

其中，每一轮重新定义边界的前加加可能不太好理解，以先定义上边界为例，其实是下面代码，即我们希望先++或--，再比较

```java
for(int col = left; col<=right; col++) res.add(matrix[up][col]);
up = up+1;
if(up > down) break;
```



