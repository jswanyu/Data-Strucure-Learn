tips

* 明确变量的含义、抓住循环不变量、小数据量调试、大数据量调试

* length——数组的属性；length()——String的方法；size()——集合的方法；第二和第三底层都是数组的length属性。注意集合一般只有size()

* 字符转为整型，只需要减去'0'。'2' 转为 整型2 只需要 '2'-'0' 即可

* Integer.parseInt() 查一下具体用法，常用于字符整数转为整型

* String.join() 查一下具体用法  字符串拼接很好用

* 回溯问题中各个集合类型的addLast和removeLast要熟练掌握

* 字符串比较不用==，而是用equals

* 唯一可以直接在类内部的代码是声明和静态初始值设定项。常用的数组填充方法`Arrays.fill()`必须用在代码块中。类定义完初始化数组可以，但不能理解调用`Arrays.fill()`

    ```Java
    class Solution {
        int[] memo = new int[n+1];
        Arrays.fill(memo,-1); //no!!!
    }
    ```

* 交换a和b，有两种方法：

    ```Java
    // 法一：
    int temp = a;
    a = b
    b = temp;
    
    // 法二：
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    ```

    



# ACM模式

## 常用方法

Java 输入输出的几个常用方法

| 创建 Scanner 对象  | Scanner in = new Scanner(System.in);                         |                                                              |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| next()             | 读取空格之前的字符串，读取完后光标放在数据后空格前。下次读取时会自动跳过空格 | 比如，"hello world"，第一次只能读取到hello，第二次才能读取到world |
| nextInt()          | 读取空格之前的整型，读取完后光标放在数据后空格前。下次读取时会自动跳过空格 |                                                              |
| nextLine()         | 读取整行的数据包括单词间的空格，读取完后光标放在下一行开头   |                                                              |
| hasNext()          | 判断输入里是否有字符串                                       |                                                              |
| hasNextInt()       | 判断输入里是否有整型                                         |                                                              |
| hasNextLine()      | 判断输入里是否有下一行                                       |                                                              |
| print              | 打印内容，输出光标定位在所显示的最后一个字符之后             |                                                              |
| println            | 打印内容，并在结尾加上换行符，将输出光标定位在下一行的开始   |                                                              |
| Integer.parseInt() | 返回的是基本类型int                                          |                                                              |
| Integer.valueOf    | 返回的是包装类Integer                                        |                                                              |

其他数据类型也是类似的，如Short、Long、Float、Double等



## （1）空格分隔的两个正整数

输入包括两个正整数a，b(1 <= a, b <= 10^9)，输入数据包括多组。输出a+b的结果

输入

```java
1 5
10 20
```

输出

```java
6
30
```

代码

```Java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in = new  Scanner(System.in);
        while(in.hasNextInt()){ //hasNextInt()判断输入的是否是整数，有就读取，没有就不读 
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(a+b);
        }
    }
}
```

注意 hasNextInt() 只能保证输入数字之间用空格或者回车分隔，如果是其他符号就退出循环了



如果ab的范围是0<*a*,*b*<2×10^10，就得定义成长整型Long

```Java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner in = new  Scanner(System.in);
        while(in.hasNextLong()){
            Long a = in.nextLong();
            Long b = in.nextLong();
            System.out.println(a+b);
        }
    }
}
```



## （2）第一行为组数 接空格分隔的两个正整数

输入第一行包括一个数据组数t(1 <= t <= 100)，接下来每行包括两个正整数a,b(1 <= a, b <= 1000)，输出a+b的结果。

即除了第一行，一共有t行的数据，每行2个正整数

输入

```
2
1 5
10 20
```

输出

```
6
30
```

代码

```Java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        int t = in.nextInt();
        for(int i=0; i<t; i++){
            int a = in.nextInt();
            int b = in.nextInt();
            System.out.println(a + b);
        }
    }
}
```





## （3）每行第一个为个数 按空格分割整数 为0结束

输入数据包括多组。每组数据一行,每行的第一个整数为整数的个数n(1 <= n <= 100), n为0的时候结束输入。接下来n个正整数,即需要求和的每个正整数。输出每组数据输出求和的结果

输入

```
4 1 2 3 4
5 1 2 3 4 5
0
```

输出

```
10
15
```

代码

```Java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNextInt()){
            int n = in.nextInt();      // 每一行先读第一个数确定n
            if(n==0) break;
            int sum = 0;
            for(int i=0; i<n; i++){    // 再for循环
                sum += in.nextInt();
            }
            System.out.println(sum);
        }
    }
}
```



## （4）多组空格分隔的正整数

输入数据有多组, 每行表示一组输入数据。每行不定有n个整数，空格隔开。(1 <= n <= 100)。输出每组数据输出求和的结果

输入

```
1 2 3
4 5
0 0 0 0 0
```

输出

```
6
9
0
```

代码

```Java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String[] s = in.nextLine().split(" ");
            int sum = 0;
            for (int i = 0; i < s.length; i++) {
                sum += Integer.parseInt(s[i]);
            }
            System.out.println(sum);
        }
    }
}
```



## （5）第一行为个数 第二行字符串

输入有两行，第一行n，第二行是n个字符串，字符串之间用空格隔开，输出一行排序后的字符串，空格隔开，无结尾空格

输入

```
5
c d a bb e
```

输出

```
a bb c d e
```

代码

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // int n = in.nextInt();  // 此行加不加都行，后续用不到n
        in.nextLine();  // 让光标到下一行
        while (in.hasNext()) { 
            String[] s = in.nextLine().split(" ");
            Arrays.sort(s);
            for (int i = 0; i < s.length; i++) {
                System.out.print(s[i] + " ");
            }
            
        }
    }
}
```



## （6）多行空格分开的字符串

多个测试用例，每个测试用例一行。每行通过空格隔开，有n个字符，n＜100。对于每组测试用例，输出一行排序过的字符串，每个字符串通过空格隔开

输入

```
a c bb
f dddd
nowcoder
```

输出

```
a bb c
dddd f
nowcoder
```

代码

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) { 
            String[] s = in.nextLine().split(" ");
            Arrays.sort(s);
            for (int i = 0; i < s.length; i++) {
                System.out.print(s[i] + " ");
            }
            System.out.println();
        }
    }
}
```



## （7）多行逗号分开的字符串

多个测试用例，每个测试用例一行。每行通过,隔开，有n个字符，n＜100。输出：对于每组用例输出一行排序后的字符串，用','隔开，无结尾空格

输入

```
a,c,bb
f,dddd
nowcoder
```

输出

```
a,bb,c
dddd,f
nowcoder
```

代码

```Java
import java.util.Scanner;
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) { 
            String[] s = in.nextLine().split(",");
            Arrays.sort(s);
            for (int i = 0; i < s.length-1; i++) {
                System.out.print(s[i] + ",");
            }
            System.out.print(s[s.length-1]);
            System.out.println();
            // 或者合并写为：System.out.println(s[s.length-1]);
        }
    }
}
```





# 数据结构

## 字符串

String类的常用方法有哪些，后面整理一下

length() ：返回字符串长度

charAt() ：返回指定索引处的字符

substring() ：截取字符串

trim() ：去除字符串两端空白

split() ：分割字符串，返回一个分割后的字符串数组。

replace() ：字符串替换

indexOf() ：返回指定字符的索引。

toLowerCase() ：将字符串转成小写字母。

toUpperCase() ：将字符串转成大写字符。





## 数组

数组很少单独考察，一般是作为其他知识点考察的载体

Java自带了一些数组的方法，需要记住以便有时候用到<font color=red>后续记录一下，在这写点代码</font>

| 方法                                         | 功能                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| Arrays.sort(int[ ] a)                        | 对一个数组的所有元素进行排序，并且是按从小到大的顺序。无返回值，直接对a进行排序。降序需要传入自定义的Comparator |
| Arrays.asList()                              | 将一个数组转换为一个List集合。**传递的数组必须是对象数组，而不是基本类型。** |
| Arrays.toString(int[ ] a)                    | 将数组a转换成String类型输出                                  |
| Arrays.copyOfRange(T[ ] a, int from, int to) | 复制数组，左闭右开，生成一个新的数组                         |



所有数组做题为了规范化，首先要注意排除数组为空和长度为0的情况

```Java
if(nums == null || nums.length == 0)
```





## 链表

**链表节点的定义**

```Java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```



**链表操作的复杂度**

普通单向链表增删改查各个操作的时间复杂度均为O(n)，只有对链表头节点操作才为O(1)



**链表的调试**

定义链表结点时，加上由数组构造方式，与打印内容

```Java
class ListNode {
    public int val;
    public ListNode next;
    public ListNode() {}
    public ListNode(int val) { this.val = val; }
    public ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    public ListNode(int[] nums) {
        if (nums == null || nums.length == 0) {
            throw new IllegalArgumentException("arr can not be empty");
        }
        this.val = nums[0];
        ListNode cur = this;
        for (int i = 1; i < nums.length; i++) {
            cur.next = new ListNode(nums[i]);
            cur = cur.next;
        }
    }

    @Override
    public String toString() {
        StringBuilder s = new StringBuilder();
        ListNode cur = this;
        while (cur != null) {
            s.append(cur.val);
            s.append(" -> ");
            cur = cur.next;
        }
        s.append("NULL");
        return s.toString();
    }
}
```

测试主函数

```Java
public static void main(String[] args) {
    int[] arr = new int[]{1,2,3,4,5};
    ListNode head = new ListNode(arr);
    System.out.println(head);
}
```

```
输出：
1 -> 2 -> 3 -> 4 -> 5 -> NULL
```



**链表题技巧**

1. 舍得用指针变量，千万别想着节省变量，否则容易被逻辑绕晕

2. 添加虚拟头节点，不用单独考虑头节点的特殊情况。切记虚拟头节点不是必须的，只是为了减少单独考虑头节点的代码，让所有逻辑统一起来。比如删除结点，如果是删除头节点，也很简单，让head = head.next，再返回head即可。不过这是单独的if判断

    一般题目都会传入head，那可以用下面这行代码创建虚拟头节点。也要注意有没有这样的构造函数

    ```Java
    ListNode dummyHead = new ListNode(-1,head);
    ```

3. 一定要多画图，搞清楚链表指向，有多个指针的时候也要搞清楚哪个指针先保留，因为链表中经常出现你不保留，后面的操作就让next指向别的地方了，再想用next就不是指向原本我们希望的位置了。多画图，代码写完了自己画图逻辑上理一遍。画图时将旧的next指针擦掉，影响观感。

4. 和上一点类似，想强调的是我们经常需要迭代遍历链表中的节点，那么**需要有个节点保存好头节点**，尤其是涉及到拆分、合并链表等操作，一般建议单独定义指针cur去遍历，而不是让head去遍历，除非有虚拟头节点或者其他类似情况能够保存好头节点。比如328奇偶链表里，一定要有个节点保存偶链表的头节点











### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**方法一：迭代法/双指针法**

设立三个指针pre，cur，temp用来记录当前节点及周围信息。pre准备指向cur的前一个节点，temp准备指向cur的下一个节点。随后遍历链表，先用temp记录cur的下一个元素，以防丢失信息，再让cur的next指向pre，此时完成当前元素的反转，随后遍历下一个节点，让pre指向cur，再让cur指向之前记录的temp

```Java
class Solution {
    public ListNode reverseList(ListNode head) {
        //单链表为空或只有一个节点，直接返回原单链表
        if (head == null || head.next == null) return head; 
        ListNode pre = null;
        ListNode cur = head;
        // 注意！下面这些话是完全多余并且会引发报错的，初始化时没用的节点都是指向null，后续的循环中会将其利用起来，不用在初始化的时候定义指向，而且null的next会报空指针异常
        // pre.next = cur;  
        // cur.next = temp;
        while (cur!=null){          
            ListNode temp = cur.next;
            cur.next = pre;  //反转，null<-1->2->3，这里有一次错写成 pre = cur.next，很离谱
            pre = cur;       
            cur = temp;      
        }
        return pre;  // 这里经常写错，while终止是cur=null时，需要返回cur的前一位pre
    }
}
```

时间复杂度：O(n)，因为是遍历了一遍链表，空间复杂度：O(1)，用了三个指针



**方法二：递归**（同样需要掌握，很多面试也会问递归法）

本题也可以使用递归法，递归在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 。

递归解题首先要做的是明确递推公式的含义，如下图所示，在这里对于结点1来说，它只需要知道它之后的所有节点反转之后的结果就可以了，也就是说递推公式reverseList的含义是：把拿到的链表进行反转，然后返回新的头结点。注意这里传入递归函数的是head.next，返回的是新的头节点 newHead

![image-20220428124004906](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png)

> 图源：[一步一步教你如何用递归思想反转链表](https://leetcode-cn.com/problems/reverse-linked-list/solution/yi-bu-yi-bu-jiao-ni-ru-he-yong-di-gui-si-67c3/)

如上图所示，null->1->2->3->4 可以拆为null->1  2->3->4，此时1的next还是指向2的，现在反转后部分即newHead为头的链表为 2<-3<-4，那么现在只要让2指向1即可完成本轮递归。怎么得到2呢，现在1是head，前面提到1的next还是指向2的，所以2就是head.next，那么让head.next.next = head就能让2指向1，再让1的next不要指向2了，而是指向null，即head.next = null，后续的递归里再准备指向前一个节点

递归反转链表什么时候停止呢？在head为null（**链表为空**）或head下一个结点为null时（**链表只有一个节点**）停止，因为在这两种情况下，反转后的结果就是它自己。

```Java
public ListNode reverseList(ListNode head) {
	//单链表为空或只有一个节点，直接返回原单链表
    if (head==null || head.next ==null) return head;
    ListNode newHead = reverseList(head.next);
    head.next.next = head; //反转在这步实现
    head.next = null;
    return newHead;
}
```



本题扩展：字节火山面试题，写出来后让分析有环的链表运行结果，关键点：1.是否会死循环（不会） 2.返回结果（环内翻转，环外未翻转）





### 92. 反转链表Ⅱ

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)



**方法一：双指针法**

1、我们定义两个指针，分别称之为 g(guard 守卫) 和 p(point)。首先根据方法的参数 left 确定 g 和 p 的位置。将 g 移动到第一个要反转的节点的前面，将 p 移动到第一个要反转的节点的位置上。
2、将 p 后面的元素删除，然后添加到 g 的后面。也即头插法。
3、根据 left 和 right 重复步骤2
4、返回 dummyHead.next

我们以 left =2，right=4为例

![image-20220429163638907](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E2%85%A1-%E5%9B%BE%E8%A7%A3.png)

> 图源：[Java-双指针-头插法 - 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/java-shuang-zhi-zhen-tou-cha-fa-by-mu-yi-cheng-zho/)

```Java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        // 不设置虚拟头节点会比较麻烦
        ListNode dummyHead = new ListNode(-1,head);
        ListNode g = dummyHead;
        ListNode p = dummyHead.next;
        // 将g、p根据left移到相应的位置，边界条件自己画一画
        for(int i=0; i<left-1; i++){
            g = g.next;
            p = p.next;
        }
        // 头插法插入节点，边界条件自己画一画
        for(int i=0; i<right-left; i++){
            // 头插法的过程自己找中间过程的一个情况画一画，不要找初始的情况，很容易犯错误
            // 比如画1->3->2->4->5的情况
            ListNode delNode = p.next;
            p.next = delNode.next;
            delNode.next = g.next;
            g.next = delNode;
        }
        // 返回真正的头节点
        return dummyHead.next;
    }
}
```



**方法二：递归法**





### 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即只能进行节点交换）。[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```



**方法一：迭代**

画画草稿就知道了，跟反转链表蛮像的，注意使用虚拟头节点

![image-20220504230246503](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A3.png)

```Java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead = new ListNode(-1,head);
        ListNode pre = dummyHead;
        while(pre.next != null && pre.next.next != null){
            // 保存下一组结点的头
            ListNode temp = head.next.next;
            // 交换当前组
            pre.next = head.next;
            head.next.next = head;
            head.next = temp;
            // 更新pre与head
            pre = head;
            head = head.next;
        }
        return dummyHead.next;
    }
}
```

时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。空间复杂度：O(1)



**方法二：递归**

递归的逻辑反而更好理解一些，如下图所示，假设链表是 1->2->3->4->5->6，现在无非就是想让1指向后面2后面的部分，再让2指向1。2后面的部分可以交给递归

![image-20220504231200855](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A31.png)

```Java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null) return head;
        ListNode temp = head.next;          // 假设链表是 1->2->3->4,这句就先保存节点2
        head.next = swapPairs(temp.next);   // 1指向2后面的部分，递归
        temp.next = head;                   // 将2节点指向1
        return temp;
    }
}
```

时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。

空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。



### 25. K个一组翻转链表

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)



方法一：迭代

过程看图示和代码注释很清楚，不难理解，有很多细节需要注意

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/25K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png" alt="image-20220501171008166"  />

> 图源：[图解k个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/)

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummyHead = new ListNode(-1,head);  // 虚拟头节点
        ListNode pre = dummyHead;               // pre每次都指向待翻转的链表头结点的上一个节点
        ListNode end = dummyHead;               // end同上，后面再用for循环遍历k个元素

        // end.next==null，停止翻转
        while(end.next != null){
// 每轮循环都用for循环找到end所在位置，注意要判断end是否等于空，如果为空，end.next会报空指针异常
// 这里自己写的时候写成了&& end.next != null，这里不要想太多逻辑，只是为了防止语法错误，只要end!=null就够了，那样的话end.next就不会报空指针异常
            for(int i=0; i<k && end != null; i++) end = end.next;  
            if(end == null) break;   // 如果end==null，即待翻转的链表的节点数小于k，不执行翻转。
            // 先记录下end.next，再断开，这样才能翻转这一部分，同时也方便后面接上链表
            ListNode temp = end.next;
            end.next = null;
            ListNode start=pre.next;  // start指向每次待翻转链表的头节点
            // pre是每次待翻转链表头结点的上一个节点，因此让其的next指向翻转后的头
            pre.next=reverse(start);  
            start.next=temp;          // start此时指向末尾了，把它和之前保存的temp连起来
            pre=start;                // 更新pre，每次都指向待翻转链表头结点的上一个节点
            end=start;                // 更新end，同上，后面再用for循环遍历k个元素
        }   
        return dummyHead.next;        // 返回真正的头节点
    }

    public ListNode reverse(ListNode head) {
        //单链表为空或只有一个节点，直接返回原单链表
        if (head == null || head.next == null) return head; 
        ListNode pre = null;   
        ListNode cur = head;   
        ListNode temp = null;  
        while (cur != null){
            temp = cur.next;   
            cur.next=pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```



方法二：递归

做的时候一定要画图！！！

1、找到待翻转的k个节点（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。
2、对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。
3、对下一轮 k 个节点也进行翻转操作。
4、将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/25K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.png" alt="123" style="zoom:150%;" />

> 图源：[递归java - K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/di-gui-java-by-reedfan-2/)

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        ListNode tail = head;
        for(int i=0; i<k; i++){
            if(tail == null) return head;        // 剩余数量小于k的话，则不需要反转。
            tail = tail.next;
        }
        ListNode newHead = reverse(head, tail); // 反转前 k 个元素，其头节点为newHead
        // 上一轮的尾节点就是head，将其指向下一轮的头节点，即递归返回的newHead
        head.next = reverseKGroup(tail, k);     
        return newHead;                         // 返回翻转后的头节点
    }

    // 左开右闭
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode pre = null;
        ListNode temp = null;
        while (head != tail) {
            temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }
}
```





本题扩展：剩下的不足K个也要翻转

其实就是在递归方法中，对`if(tail == null)`的处理语句做出修改

```Java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || head.next == null) return head;
        ListNode tail = head;
        for(int i=0; i<k; i++){
            if(tail == null) return reverse(head,tail);   // 剩余数量小于k的话，也需要反转。
            tail = tail.next;
        }
        ListNode newHead = reverse(head, tail); // 反转前 k 个元素，其头节点为newHead
        // 上一轮的尾节点就是head，将其指向下一轮的头节点，即递归返回的newHead
        head.next = reverseKGroup(tail, k);     
        return newHead;                         // 返回翻转后的头节点
    }

    // 左开右闭
    private ListNode reverse(ListNode head, ListNode tail) {
        ListNode pre = null;
        ListNode temp = null;
        while (head != tail) {
            temp = head.next;
            head.next = pre;
            pre = head;
            head = temp;
        }
        return pre;
    }
}
```





### 21. 合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```



方法一：迭代

维护一个 `prev` 指针，我们需要做的是调整它的 `next` 指针。当 l1 和 l2 都不是空链表时，如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。

在循环终止的时候， l1 和 l2 至多有一个是非空的。只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。

动图只展示部分过程

![626f9c0527e5a](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.gif)

> 图源：[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/)

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode preHead = new ListNode(-1);
        ListNode pre = preHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else {
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next; // 不管哪种情况，pre都要往后移一位
        }
        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        pre.next = list1 ==null ? list2 : list1;
        return preHead.next;
    }
}
```



**方法二：递归**

判断 `l1` 和 `l2` 头结点哪个更小，然后较小结点的 `next` 指针指向**其余结点的合并结果。（调用递归）**

终止条件：当两个链表都为空时，表示我们对链表已合并完成。

![626f962568804](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[一看就会，一写就废？详解递归 - 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next,list2); // 1小就合并1后面的和整个2
            return list1;
            }
        else {
            list2.next = mergeTwoLists(list1,list2.next); // 2小就合并2后面的和整个1
            return list2;
        }
    }
}
```



本题扩展：合并后去重

迭代法我自己的去重思路是最好有个额外指针再保存一下pre的前一个元素，如果pre和pre的下一个元素重复，就利用pre前一个把pre删除。没用代码验证，感觉比较麻烦

这里写一下递归的代码，递归的思路也很简单，首先将2个list本身去重，然后只有可能list1和list2中的元素重复，递归时候单独列出来，直接让list1去指向（让list2也行，都可以）两个list.next的递归

```Java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 去重1 两个list本身去重，直接跳到最后一个
        while (list1 != null && list1.next != null && list1.val == list1.next.val)
            list1 = list1.next;
        while (list2 != null && list2.next != null && list2.val == list2.next.val)
            list2 = list2.next;
        // 下面整体逻辑同递归
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next,list2); 
            return list1;
            }
        else if(list1.val > list2.val){
            list2.next = mergeTwoLists(list1,list2.next);
            return list2;
        }
        else { // 去重2 list1.val = list2.val
            list1.next = mergeTwoLists(list1.next, list2.next);
            return list1;
        }
    }
}
```





### 23. 合并K个升序链表

这题和21高度相似，但涉及到一些排序算法，等排序整理完了再来做这道题





### 148. 排序链表

同上





### 141. 环形链表

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。如果链表中存在环 ，则返回 true 。 否则，返回 false 。[141. 环形链表 - 力扣](https://leetcode-cn.com/problems/linked-list-cycle/)



**方法一：哈希表**

使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

```Java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

时间复杂度：O(N)，但是需要用到额外空间，即空间复杂度为O(N)



**方法二：双指针**

定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，快慢指针都在位置 head。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

```Java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null)
            return false;
        ListNode slow = head;
        ListNode fast = head;
        while(true){
            if(fast == null || fast.next == null) return false;  // 快指针走到头了，链表无环
            fast = fast.next.next; 
            slow = slow.next;     
            if(fast == slow)  return true; // 相遇说明有环
        }
    }
}
```

时间复杂度：O(N)，空间复杂度：O(1)

注意由于快慢指针都在位置 head，while条件不能用while(fast == slow)





### 142. 环形链表Ⅱ

给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)



**方法一：双指针**

和141一样仍然是快慢指针，难点在于如何找到环形入口

这道题需要数学公式推导+逻辑结合：

设环形入口前有a个节点，环形中有b个节点，初始化时快慢指针都指向head，快指针走了f步，慢指针走了s步，如果是环形链表就一定会相遇，此时，f=2s，同时因为相遇，也能得到：f=s+nb，相减得到: s = nb。即第一次相遇时得到了s = nb，**注意这并不是现有逻辑的认知，而是推导出来的**。一个节点正常走到环形入口肯定是走了 a+nb 步, 那么现在s=nb，只要让slow再走a步就能到环形入口了。从哪里能得到a步？答案是从头节点走到环形入口，因此再重新把fast放到head，往下走，此时我们不知道a是多少，但fast和slow第二次相遇时一定是一起走了a步（这是之前推导出的），此时fast走的步数就是我们需要的a

![6270fa093a35f](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1-%E5%9B%BE%E8%A7%A3.gif)

> 图源：[环形链表 II（双指针法，清晰图解）](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)

```Java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(true){
            if(fast == null || fast.next == null) return null;  // 快指针走到头了，链表无环
            fast = fast.next.next; 
            slow = slow.next;     
            if(fast == slow)  break; // 相遇说明有环，退出循环，此时slow位置很重要，这是第一次相遇
        }
        
        fast = head;
        while(fast != slow){
            slow = slow.next;
            fast = fast.next;
        }
        return fast;   // 第二次相遇，fast的位置就是环形入口
    }
}
```



本题扩展：输出环的长度

让fast停在环形入口，slow继续走一圈，走到fast处，走过的路径可得环的长度





### 160. 相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。题目数据 **保证** 整个链式结构中不存在环。**注意**，函数返回结果后，链表必须 **保持其原始结构** 。[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

图示两个链表在节点 `c1` 开始相交：

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E7%A4%BA%E4%BE%8B.png" alt="image-20220503212241705" style="zoom:200%;" />

方法一：哈希集合

首先遍历链表 headA，并将链表headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：如果当前节点不在哈希集合中，则继续遍历下一个节点；如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。



方法二：双指针

我先走我的路，再走你的路，你先走你的路，再走我的路，这样咱俩走的路程就一样了，速度一样，那么肯定在咱俩两条路的交叉口相遇

```Java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;

        // 要么相遇即节点相等，要么都为空（只走一次对方的路，都有尽头为null），最终都能跳出循环。
        while(curA != curB){
            // 两人以相同的速度（一次一步）沿着各自的路径走
            // 当走完各自的路时，再“跳”至对方的路上。（起点平齐速度相同，终点即为相遇点）
            curA = (curA == null? headB: curA.next);
            curB = (curB == null? headA: curB.next);
        }
        return curA;
    }
}
```

时间复杂度：O(m+n)   空间复杂度：O(1)



### 2. 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 0，每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值，如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1。

逻辑上不难，基本的加法进位本位，多写几遍就熟悉了，细节已注释，逻辑统一加上虚拟头结点

代码如下：

```Java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);  // 定义新链表虚拟头节点
        int carry = 0;                         // 进位数，进位数先使用后计算，所以得提前定义好
        ListNode cur = dummyHead;              // 可移动指针，初始化指向虚拟头节点
        while(l1 != null || l2 !=null){        // 两个都遍历完才算结束，有值就取，没有补0
            int x = (l1 !=null ? l1.val : 0);
            int y = (l2 !=null ? l2.val : 0);  
            int sum = x + y + carry;           // 将两个链表的值进行相加，并加上前一轮的进位数
            carry = sum / 10;                  // 计算进位数
            sum = sum % 10;                    // 计算本位数
            // 将求和数赋值给新链表的节点，注意别写为cur.next = sum
            cur.next = new ListNode(sum);      
            cur = cur.next;
            if(l1 !=null) l1 = l1.next;
            if(l2 !=null) l2 = l2.next;
        }
        // 循环结束了，但最高位还有进位，而且也只能是1，就再加一个节点
        if(carry == 1) cur.next = new ListNode(carry);
        return dummyHead.next;                 // 注意返回真正的头节点
    }
}
```





### 143. 重排链表

给定一个单链表 L 的头节点 head ，单链表 L 表示为：L0 → L1 → … → Ln - 1 → Ln

请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。[143. 重排链表 - 力扣](https://leetcode-cn.com/problems/reorder-list/)

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E7%A4%BA%E4%BE%8B.png" alt="image-20220503215014680" style="zoom:200%;" />

**方法一：线性表**存储

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。题目其实就是给一个链表，然后依次头尾头尾头尾取元素，组成新的链表。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按题目需要的顺序访问指定元素，重建该链表即可。

时间复杂度：O(N)，空间复杂度：O(N)



**方法二：链表中点 + 翻转链表 + 合并链表**

注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

1. 找到原链表的中点：我们可以使用快慢指针找到链表的中间节点。参考876题
2. 将原链表的右半端反转：我们可以使用迭代法实现链表的反转。参考206题
3. 将原链表的两端合并：因为两链表长度相差不超过 1，因此直接合并即可。

非常综合考察的好题目

```
1 -> 2 -> 3 -> 4 -> 5 -> 6
第一步，将链表平均分成两半
1 -> 2 -> 3
4 -> 5 -> 6
    
第二步，将第二个链表逆序
1 -> 2 -> 3
6 -> 5 -> 4
    
第三步，依次连接两个链表
1 -> 6 -> 2 -> 5 -> 3 -> 4
```

代码：

```Java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) return;
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null; // 注意断开mid的next指针
        l2 = reverse(l2);
        mergeList(l1,l2);
    }

    // 返回中间节点， 偶数个节点返回第一个中点
    private ListNode middleNode(ListNode head){
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 翻转链表
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }

    // 拼接链表，注意没有返回值
    private void mergeList(ListNode list1, ListNode list2){
        ListNode temp1;
        ListNode temp2;
        while(list1 != null && list2 != null){
            temp1 = list1.next;
            temp2 = list2.next;
            list1.next = list2;
            list1 = temp1;
            list2.next = list1;
            list2 = temp2;
        } 
    }
}
```

时间复杂度：O(N)，空间复杂度：O(1)





### 234. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 

[234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

```
输入：head = [1,2,2,1]
输出：true
```



**方法一：将值复制到数组中后用双指针法**

单向链表无法倒着索引，但数组可以，因此可以将链表元素放到数组中，然后首尾指针对比是否是回文

时间复杂度：O(n)，空间复杂度：O(n)



**方法二：链表中点 + 翻转链表**

和143题类似，也可以用链表中点+翻转链表来解决。具体来说，快慢指针用来找链表中点，将后半部分的链表翻转，再和前半部分对比，是否是回文

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null; // 注意断开mid的next指针
        l2 = reverse(l2);

        while(l1 != null && l2 != null){
            if(l1.val != l2.val) return false;
            l1 = l1.next;
            l2 = l2.next;
        }
        return true;
    }

    // 返回中间节点， 偶数个节点返回第一个中点
    private ListNode middleNode(ListNode head){
        ListNode slow = head;
        ListNode fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    // 翻转链表
    private ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```

注意，题目没要求不得改动原链表，否则还要把后半部分翻转回来



**方法三：翻转前半部分**

翻转链表时自然也可以翻转前半部分，像上面一样调用函数去翻转前半部分这里就不提了，另一种方法是前半部分的慢指针找中点过程中，边找边翻转，时间复杂度更低。具体代码如下所示

```Java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        ListNode slow = head, fast = head, pre = null, cur = head;
        // 注意这样写，如果是偶数个的话，slow会停在第二个中点，pre会停在第一个中点，符合我们的需求
        while(fast != null && fast.next != null){ 
            cur = slow;
            slow = slow.next;               // 快慢指针找中点
            fast = fast.next.next;
            cur.next = pre;                 // 反转链表
            pre = cur;
        }
        if(fast != null) slow = slow.next;  // 如果fast不为空，说明链表的长度是奇数个，跳过中点
        // 开始判断回文，分别是以cur为头的前半部分的翻转链表，以slow为头的后半部分的原链表
        while(cur != null && slow != null){
            if(cur.val != slow.val) return false;
            cur = cur.next;
            slow = slow.next;
        }
        return true;
    }
}
```

此处的逻辑非常需要小心，正常的找中点和翻转是独立分开的，此处并不能完全意义上的先翻转或者先后移快慢指针，因为翻转的过程中，slow是作为保存下一个结点来用的，因此一定要写在真正的翻转，即`cur.next = pre; `之前。比如下面这段代码，cur.next已经原地翻转了，所以slow没办法向后指向真正的下一个结点了，而是向前指了

```Java
while(fast != null && fast.next != null){ 
    cur = slow;
    cur.next = pre;                 // 反转链表
    pre = cur;
    slow = slow.next;               // 快慢指针找中点
    fast = fast.next.next; 
}
```

但`cur = slow;`又不能写在移动快慢指针之后，如下所示，cur还没翻转呢，就跳到下一个了

```Java
while(fast != null && fast.next != null){ 
    slow = slow.next;               // 快慢指针找中点
    fast = fast.next.next;
    cur = slow;
    cur.next = pre;                 // 反转链表
    pre = cur;
}
```







### 19. 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```



**方法一：双指针+前置指针**

涉及到了待操作结点的前一个结点，设置虚拟头节点，否则头结点没有前一个结点，要单独讨论

初始时slow和fast都指向虚拟头节点，slow指针不动，让fast指针先走n步，然后两个指针同时移动，再定义一个pre指针始终指向slow前一个结点。当fast移到null时，slow就指向了待删除结，使用pre删除它

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(-1,head);
        ListNode slow = dummyHead;
        ListNode fast = dummyHead;
        for(int i = n; i>0; i--) fast = fast.next;  // 让fast先动n步
        ListNode pre = null;
        while(fast != null){
            pre = slow;         // 定义pre始终指向待删除结点的前一个节点
            slow = slow.next;   // 更新slow指向待删除的节点
            fast = fast.next;     
        }
        pre.next = slow.next;   // 删除节点
        return dummyHead.next;
    }
}
```





### 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表*。

```
输入：head = [1,1,2]
输出：[1,2]
```



**方法一：迭代**

画草稿的时候多搞点重复元素，比如链表里有4个3

指定 cur 指针指向头部 head，当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了（实际上如果单独用if考虑了null的情况，只需要在while里考虑cur.next就行）。当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果，如果不相等则 cur 移动到下一个位置继续循环

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode cur = head;
        while(cur != null && cur.next != null){
            if(cur.val == cur.next.val) 
                cur.next = cur.next.next;  // 注意不是更新cur，是更新cur.next
            else cur = cur.next;           // 确定cur.next没问题再更新cur
        }
        return head;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



**方法二：递归**

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        head.next = deleteDuplicates(head.next);
        // 递归返回什么看是否重复，重复就返回下一个结点，不重复返回自身
        return head.val == head.next.val ? head.next : head;
    }
}
```

时间复杂度：O(N)，空间复杂度：O(N)，递归调用的时候会用到了系统的栈



### 82. 删除排序链表中的重复元素Ⅱ

给定一个已排序的链表的头 `head` ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表 。[82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/submissions/)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```



**方法一：迭代**

画草稿的时候多搞点重复元素，比如链表里有4个3

和上一题的区别就是删除全部重复的元素，那么不要去判断cur和cur.next是否相等，这时候cur已经在第一个相等元素处了，而是去判断cur.next和cur.next.next是否相等，这时cur还在相等元素的前一个元素。if里再加个while循环寻找合适的cur.next

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head == null) return head;
        ListNode dummyHead = new ListNode(-1,head);
        ListNode cur = dummyHead;
        while(cur.next != null && cur.next.next != null){
            if(cur.next.val == cur.next.next.val){
                int x = cur.next.val;          // 元素全部被删除了，单独备份一下
                while(cur.next != null && cur.next.val == x){
                    cur.next = cur.next.next;  // 注意不是更新cur，是更新cur.next
                }
            }
            else{
                cur = cur.next;                // 确定cur.next没问题再更新cur
            }
        }
        return dummyHead.next;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



**方法二：递归**

```Java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null)  return head;
        // 当前结点和下一个结点相等
        if (head.next != null && head.val == head.next.val) {
            // 先遍历到相同元素的最后一个元素，比如4个3，head定位到最后一个3
            while (head.next != null && head.val == head.next.val) {
                head = head.next;
            }
            // 返回下一个结点的递归，即抛弃最后一个3
            return deleteDuplicates(head.next);
        }
        // 当前结点和下一个结点不等，当前结点指向下一个结点为头的递归
        else head.next = deleteDuplicates(head.next);
        // 最终返回头结点
        return head;    
    }
}
```

时间复杂度：O(N)，空间复杂度：O(N)，递归调用的时候会用到了系统的栈





### 138. 复制带随机指针的链表

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

val：一个表示 Node.val 的整数。

random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

![image-20220504232113851](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```



本题要求我们对一个特殊的链表进行深拷贝。如果是普通链表，我们可以直接按照遍历的顺序创建链表节点。而本题中因为随机指针的存在，当我们拷贝节点时，「当前节点的随机指针指向的节点」可能还没创建

**方法一：哈希表**

我们用哈希表来解决这个问题，首先创建一个哈希表，先遍历原链表，遍历的同时不断在新链表中创建节点，我们将原节点作为**key**，新节点作为**value**放入哈希表中。

![image-20220505134940263](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A3.png)

从上图中我们可以发现，原节点和新节点是一一对应的关系，所以能够得出：

* 新节点.next = map.get(原节点.next)
* 新节点.random = map.get(原节点.random)

所以再进行第二次遍历原链表，这次我们要将新链表的next和random指针给设置上。

![image-20220505135225570](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A31.png)

> 图源：[两种实现+图解 138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/liang-chong-shi-xian-tu-jie-138-fu-zhi-dai-sui-ji-/)

最后，`map.get(head)`，也就是返回对应的新链表的头节点

总结为先根据原链表创建新链表，再根据原链表构建新链表指向

```Java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Map<Node,Node> map = new HashMap<>();
        Node cur = head;
        while(cur != null){  // 第一次遍历构建哈希表与新链表架子
            Node newNode = new Node(cur.val);
            map.put(cur,newNode);
            cur = cur.next;
        }
        cur = head;          // 第二次遍历构建新链表指向
        while(cur != null){
            Node newNode = map.get(cur);          // 获取哈希表中新链表的节点
            newNode.next = map.get(cur.next);     // 构建新链表节点的next指向
            newNode.random = map.get(cur.random); // 构建新链表节点的random指向
            cur = cur.next;
        }
        return map.get(head);
    }
}
```

时间复杂度：O(n)，空间复杂度：O(n)



**方法二：迭代原地模拟**

我们使用「哈希表」的目的为了实现原节点和新节点的映射关系，更进一步的是为了快速找到某个节点 random 在新链表的位置。那么我们可以利用原链表的 next 做一个临时中转，从而实现映射。

具体的，我们可以按照如下流程进行：

* 对原链表的每个节点节点进行复制，并追加到原节点的后面；

* 之后，链表的奇数位置代表了原链表节点，链表的偶数位置代表了新链表节点，且每个原节点的 next 指针执行了对应的新节点。这时候，我们需要构造新链表的 random 指针关系，可以利用观察到的规律：如果原节点`i`的随机指针指向的是原节点`j`，那么新节点`i+1`的随机指针，指向的是原节点`j`的**next**，即为

    `link[i + 1].random = link[i].random.next`，i 为奇数下标。

    比如下图1的random指向3，那么1的下一个1的random就指向3的下一个3

* 对链表进行拆分操作。（拆分操作需要前继节点，创建虚拟头节点）

![image-20220505141352525](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/138%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8-%E5%9B%BE%E8%A7%A32.png)

>  图源：[【宫水三叶】一题双解：「哈希表」&「原地算法」 - 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-pqek/)

写构建和拆分代码之前一定要先画图，搞清楚指针指向顺序

```Java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        // 第一次遍历构建新链表架子
        Node cur = head;                  
        while(cur != null){
            Node newNode = new Node(cur.val);
            newNode.next = cur.next;
            cur.next = newNode;
            cur = newNode.next;          
        }
        // 第二次遍历构建新链表指向
        cur = head;
        while(cur != null){
            if (cur.random != null) cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 第三次遍历拆分链表
        cur = head;
        // 注意一定要先保留第二个节点为头的链表，不能在最后再返回head.next，那会head.next不是链表头
        Node res = head.next;      
        while(cur != null){
            Node temp = cur.next;
            if(cur.next != null) cur.next = temp.next;
            cur = temp;
        }
        return res;
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)





### 328. 奇偶链表

给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。[328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```



**方法一：迭代**

定义两个指针odd和even去遍历整个链表，注意奇链表头不用保存，偶链表头需要额外定义节点保存

逻辑上不难，画画图就行。此题也可以只维护一个指针，但节省一个指针意义不大，反而降低代码可读性

```Java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head == null) return head;
        ListNode evenHead = head.next;   // 记录初始的偶链表头节点
        ListNode odd = head;             // 奇偶两个指针用于遍历
        ListNode even = evenHead;
        while(even != null && even.next != null){
            odd.next = even.next;        // 改变奇偶指针指向
            even.next = even.next.next;  
            odd = odd.next;              // 更新奇偶遍历指针
            even = even.next;
        }
        // 由于while循环条件有even.next != null，当链表长度为奇数时没影响
        // 当链表长度为偶数时，最后一个odd还会指向最后一个even，需要断开
        odd.next = null;                 
        odd.next = evenHead;             // 奇链表后加上偶链表，所以上一句其实可以省略
        return head;    
    }
}
```

时间复杂度：O(n)，空间复杂度：O(1)



### NC207. 排序奇升偶降链表

给定一个奇数位升序，偶数位降序的链表，返回对其排序后的链表。[排序奇升偶降链表_牛客网](https://www.nowcoder.com/practice/3a188e9c06ce4844b031713b82784a2a?tpId=117&tqId=39396&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26pageSize%3D50%26search%3D207%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D117&difficulty=undefined&judgeStatus=undefined&tags=&title=207)

```
输入：{1,3,2,2,3,1}
输出：{1,1,2,2,3,3}
```



**方法一：迭代**

不难分析，此题就是 **奇偶链表+链表反转+合并链表**

具体来说，先将原链表拆成奇链表和偶链表，偶链表是降序，所以把偶链表翻转，再把两个链表拼起来

```Java
public class Solution {
    public ListNode sortLinkedList (ListNode head) {
        if(head == null || head.next == null) return head;
        // 拆分奇偶链表
        ListNode oddHead = head;
        ListNode evenHead = head.next;
        ListNode odd = oddHead;
        ListNode even = evenHead;
        while(even != null && even.next != null){
            odd.next = even.next;       
            even.next = even.next.next;  
            odd = odd.next;              
            even = even.next;
        }
        // 与上题不同的是，此处一定要先断开最后的odd.next，否则就会出错，比如1->3->2->2->3->1，理想状态奇链表是拆成为1->2->3，但实际上不加这句就会拆成1->2->3->1，即最后一个odd还会指向最后一个even
        odd.next = null;     
        evenHead = reverseList(evenHead);
        return mergeTwoLists(oddHead,evenHead);
    }
    
    // 翻转链表
    private ListNode reverseList(ListNode head){
        if (head == null || head.next == null) return head; 
        ListNode pre = null;
        ListNode cur = head;
        while(cur != null){
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
    
    // 合并两个有序链表
    private ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode preHead = new ListNode(0);
        ListNode pre = preHead;
        while(list1 != null && list2 != null){
            if(list1.val < list2.val){
                pre.next = list1;
                list1 = list1.next;
            } else {
                pre.next = list2;
                list2 = list2.next;
            }
            pre = pre.next;
        }
        pre.next = list1 ==null ? list2 : list1;
        return preHead.next;
    }  
}
```





### 876. 链表的中间结点

给定一个头结点为 `head` 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。



**方法一：快慢指针**

使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。

题目要求：「两个中间结点的时候，返回第二个中间结点」。此时可以在草稿纸上写写画画，可以得出：快指针可以前进的条件是：**当前快指针和当前快指针的下一个结点都非空。**

```Java
class Solution {
    public ListNode middleNode(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```

时间复杂度：O(N)  空间复杂度：O(1)



**本题扩展**：如果题目要求「两个中间结点的时候，返回第一个中间结点」。

在草稿纸上写写画画，可以得出：快指针可以前进的条件是：**当前快指针的下一个结点和当前快指针的**下下一个结点**都非空。**

所以就是把上面代码的while条件改一下

```Java
while(fast.next != null && fast.next.next != null)
```



### 203. 移除链表元素

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

本题逻辑很简单，但是不加虚拟头节点很麻烦，需要添加虚拟头节点，不用对头节点进行额外考虑

```Java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null) return head;
        // 虚拟头节点
        ListNode dummy = new ListNode(-1,head);        
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur != null){
            if(cur.val == val){
                pre.next = cur.next;
            }
            else{
                pre = cur;
            }
            cur = cur.next;
        }

        return dummy.next;
    }
}
```



## 栈







## 队列











## 查找表

### 349.两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。输入：nums1 = [1,2,2,1], nums2 = [2,2]   输出：[2]   [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

面试官可能会问：两个数组怎么求交集？时间复杂度多少？如果两个数组都是非递减的，又该怎么求，复杂度多少？对应下面的几种解法：

**方法一：使用集合**

先把num1中的所有元素全部添加到集合set1中，然后遍历nums2中的所有元素，判断在集合set1中是否存在，如果存在，说明有交集，就把他添加到集合resSet中，最后再把resSet转化为数组

```Java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> tempSet = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        // 把nums1中的元素全部加入到集合tempSet中
        for(int num:nums1){
            tempSet.add(num);
        }
        // 查看nums2中的元素是否存在集合tempSet中，如果存在就加入到集合resSet中
        for(int num:nums2){
            if(tempSet.contains(num)) {
                resSet.add(num);
            }
        }
        //下面一大坨是把集合reSet转换为数组
        int[] res = new int[resSet.size()];
        int i=0;
        for(int num:resSet){
            res[i++] = num;
        }
        return res;
    }
}
```

复杂度分析：

时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n)的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。即O(n)级别

空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。



**方法二：排序+双指针**

首先将数组排序，定义一个数组保存结果result

两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位。如果两个数字相等，且该数字不等于result的尾部元素，同时将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。（这个逻辑很简单，自己画图看看就知道了）

```Java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        //先对两个数组进行排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        // 双指针一开始都指向0
        int i = 0;
        int j = 0;
        // 由于要不停添加元素，显然List更好用
        List<Integer> resList = new ArrayList<>();
        // 有一个指针越界就停止
        while(i<nums1.length && j<nums2.length){
            if(nums1[i] < nums2[j]){
                i++;
            } else if(nums1[i] > nums2[j]){
                j++;
            } else{ // nums1[i] == nums2[j]
                // 空集合要先加入元素，容易漏掉
                // 判断当前相等元素和集合最后一个元素是否相同，去重
                // 或者此处直接用集合就不用判断了 resSet.add(nums1[i]);
                if(resList.size()==0 || nums1[i] != resList.get(resList.size()-1)){
                    resList.add(nums1[i]);
                }
                i++;
                j++;
            }
        }
        //下面一大坨是把List转换为数组
        int[] res = new int[resList.size()];
        int k=0;
        for(int num:resList){
            res[k++] = num; 
        }
        return res;
    }
}
```

复杂度分析

时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。对两个数组排序的时间复杂度分别是O(mlogm) 和 O(nlogn)，双指针寻找交集元素的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)。因此如果算排序时间，就是O(nlogn)，不算排序就O(n)级别

空间复杂度：O(logm+logn)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于排序使用的额外空间。



方法三：排序+二分

先排序，for循环遍历一个数组的每一个元素，然后去另一个数组里用二分找这个元素，找到了就加到集合里，结束。

时间复杂度不算排序的话，貌似是O(m + logn)？



### 350.两个数的交集Ⅱ

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序



## 并查集





## 哈希表





## 二叉树

二叉树的定义与力扣保持一致，要能写得出来

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 1. 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历。大部分二叉树的题目最终都是归结到遍历操作上，因此针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。

#### 1.1 深度优先遍历（DFS）

#### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示。节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。



前序遍历： 每个节点都按照“**中**--左--右”（中在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做。例子顺序是 1 2 4 5 3 6 7

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode node, List<Integer> list){
        if(node == null) return;

        list.add(node.val);  // 处理元素
        preorderRecur(node.left,list);
        preorderRecur(node.right,list);
    }
}
```





中序遍历：每个节点都按照“左--**中**--右”（中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做。例子顺序是 4 2 5 1 6 3 7 

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inorder(root,res);
        return res;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if(node == null) return;

        inorder(node.left,res);
        res.add(node.val);  // 处理元素
        inorder(node.right,res);
    }
}
```



后序遍历：每个节点都按照“左--右--**中**”（中在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做。例子顺序是 4 5 2  6 7 3 1

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if(root == null) return;

        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```



#### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

**在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。**

**一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。**



前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (! stack.isEmpty()){
            root = stack.pop();
            res.add(root.val); // 处理元素
            if (root.right != null) stack.push(root.right);
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```



后序遍历

后序遍历的本质还是前序遍历，前序遍历是头左右，后序遍历是左右头，只需要调整一下前序遍历的顺序，设为头右左，再翻转一下res数组，就可以得到左右头。因为栈先入后出，所以应该先压左再压右。

观察下面的代码，与前序的差别就在于压栈顺序和翻转数组

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            root = stack.pop(); 
            res.add(root.val); // 处理元素
            if (root.left != null) stack.push(root.left);
            if (root.right != null) stack.push(root.right);
        }
        Collections.reverse(res); // 翻转数组
        return res;
    }
}
```





中序遍历

中序遍历和前序遍历不能通用，前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**而中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); // 弹出栈顶元素
                res.add(root.val);  // 处理元素
                root = root.right;  // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
        return res;
    }
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />



#### Morris遍历

Morris遍历是一种遍历二叉树的方式，并且时间复杂度O(N)，**空间复杂度O(1)**，它通过利用原树中大量空闲指针的方式，达到**节省空间**的目的

这种方法的意义在于**面试时聊天**二叉树题目的优化，因为二叉树很多题目都和遍历紧密结合，前面递归方法是使用系统栈、迭代方法自己压栈，都使用了额外的空间，即二叉树的高度。而Morris遍历方法空间复杂度是O(1)，显然是一种优化。但由于其代码量更大，**思路也比较难，不适合在笔试时使用**（说白了就是难写出来）

遍历过程：

假设来到当前节点cur，开始时cur来到头节点位置，

* 如果cur没有左孩子，cur向右移动
* 如果cur有左孩子，找到左子树上最右的节点mostRight：
    * 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动 
    * 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动（说明rightMost.right曾经被修改过，我们这是第二次来到这个点，重新修改其为null，**说明该节点的左子树全部访问完毕**，所以此时**cur向右走**。）
* cur为空时遍历停止

（cur是真正有效的移动指针，它会走过所有的节点，rightMost是为了修改指针而存在的）

```Java
public static void morrisIn(Node head) {
    if (head == null) return;
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {          // cur为空时遍历停止
        
        // 如果cur有左子树
        if (mostRight != null) {
            mostRight = cur.left;      // 先找cur左子树         
            // 找左子树的最右节点mostRight，因为我们后续人为地将mostRight指向了空或者cur，所以此处要判断
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            
            // 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue; // while循环进入下一次
            } 
            
            // 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动，在第29行
            else {
                mostRight.right = null;
            }
        }
        
        // 如果cur没有左子树，cur向右移动
        cur = cur.right; 		
    }
    System.out.println();
}
```

其实不难发现，在这种遍历方式中，有些节点会访问两次，有些节点会访问一次。**因为我们有两个指针cur和rightMost，cur会走过所有的节点，rightMost会修改节点指向，使得cur重新访问到某个父节点。** 更具体的可以见这篇博客[Mirrors遍历]([(22条消息) 树（一）——Morris 二叉树神级遍历_yindarui的博客-CSDN博客_mirrors遍历](https://blog.csdn.net/qq_38684427/article/details/107708469))







#### 1.2 广度优先遍历（BFS）

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，**与深度优先遍历非递归使用栈不同，宽度优先遍历主要使用队列来解决问题**。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点）（队列是先进先出，所以先左再右），没有子节点就不放
* 循环

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

因为此题要用两层列表输出，所以加个for循环弹出当前层的元素个数，这是层序遍历需要对每层操作的经典方式

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            LinkedList<Integer> level = new LinkedList<>();
            // for循环弹出当前层的元素个数
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();  // 规范起见，这里不要用root=queue.poll()；
                level.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

也有很多力扣题目BFS是可以作为解法的（但不一定是最优解），例如：[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)、[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

层序遍历也有DFS方式，后面研究下

```Java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```



#### 1.3 遍历相关

#### xxx. 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。

例如:N=1时，打印: down N=2时，打印: down down up

本题考察的是二叉树的中序遍历，可以试着折两下子，发现每一次折都会在**最新的折痕上下位置**出现两个新的折痕，并且都是上面为down折痕，下面为up折痕，命名什么不重要，重点是二叉树的结构。打印的时候，从上往下打印，类似于二叉树的中序遍历

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98-%E5%9B%BE%E8%A7%A3.png" alt="image-20220420153749056" style="zoom:150%;" />

![image-20220420154722278](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E6%8A%98%E7%BA%B8%E9%97%AE%E9%A2%98-%E5%9B%BE%E8%A7%A31.png)

其代码就是简单的中序遍历，左节点是down，右节点是up

```Java
class Solution {	
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	public static void printProcess(int i, int N, boolean down) {
		if (i > N) return;
		printProcess(i + 1, N, true);
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false);
	}
}
```



### 2. 二叉树的属性

#### 104. 二叉树的最大深度

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

解决此类递归问题，需要将目光聚焦于任意一个节点x为根的树，它的最大深度为什么。

针对此题能够得出：任意一个节点x为根的树其最大深度为左子树和右子树的最大深度 +1

```Java
class solution {
    public int maxdepth(treenode root) {
        if (root == null) return 0;
        int leftdepth = maxdepth(root.left);
        int rightdepth = maxdepth(root.right);
        return Math.max(leftdepth, rightdepth) + 1;
    }
}
// 或者简化为：
return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
```

或者也可以使用层序遍历，每一层记录高度+1，此处略。同样的逻辑也可以处理一下[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)



#### 111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

针对此题能够得出：任意一个节点x为根的树其最小深度需要具体讨论，所有的情况都如下

* 如果其左右子树都为空，最小深度就是其自身，也就是1
* 如果其左子树为空，那么就是右子树的最小深度 +1
* 如果其右子树为空， 那么就是左子树的最小深度 +1
* 如果其左右子树都不为空，那就递归下去，是左右子树的最小深度 +1

这样直接写出来的代码为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null && root.right== null) return 1;
        if(root.left == null) return rightDepth + 1;
        if(root.right == null) return leftDepth + 1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

但显然前三种条件可以统一简化为：左右子树任一个子树为空。前三种的结果也可以统一化简为一个公式，即 leftDepth + rightDepth +1; 

因为第一种情况，左右子树最小深度就是0，公式结果为1；第二种情况，左子树深度为0，公式结果为 rightDepth + 1;  第三种情况，右子树深度为0，公示结果为 leftDepth + 1。 

因此代码可以化简为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null || root.right== null) return leftDepth + rightDepth +1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

虽然还可以用三元表达式进一步化简，但意义不大，可读性较差.

同样的，此题也可以用层序遍历，在for循环外加上depth计数，for循环里加上判断，如果弹出的节点是叶子节点，直接返回depth即可，此时就是最小深度



#### 662. 二叉树的最大宽度

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        // 在构造队列对象时，注意父类接口只能大不能小，比如层序遍历队列用单向队列即可，但辅助队列
        // 需要用双端队列Deque或者链表LinkedList作为父类接口
        Queue<TreeNode> queue = new LinkedList<>();    // 层序遍历的队列
        LinkedList<Integer> list = new LinkedList<>(); // 辅助队列/数组
        queue.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值

        while(!queue.isEmpty()){
            
        // 设立循环，循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标
        // 比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，
        // 辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了
            int count = queue.size();
            for(int i=count; i>0; i--){ 

                // 记录弹出的元素，和弹出元素的下标（弹出元素的下标用于添加下一层元素的下标）
                TreeNode cur = queue.poll();
                int curIndex = list.removeFirst();

                // 层序遍历添加元素，同时也注意根据弹出元素的下标向辅助队列里添加左右子节点的下标
                if(cur.left != null){
                    queue.offer(cur.left);
                    list.offer(curIndex * 2);
                }
                if(cur.right != null){
                    queue.offer(cur.right);
                    list.add(curIndex * 2 +1);
                }
            }

            if(list.size() >= 2){
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        // while循环结束，队列为空，res为最大宽度
        return res;
    }
}
```



#### 101. 验证对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

首先写写画画梳理正确的逻辑，才能写出正确的递归。此题显然是自顶向下的递归，对称，就是左右两边相等，也就是左子树和右子树相等。将每个节点的左子树记做 left，右子树记做 right。首先要比较 left 和 right 的值是否相等，不等的话直接返回false。相等的话继续比较外侧是否对称，即 left 的左子树 和 right 的右子树是否相等， 还要比较内侧是否对称，即 left 的右子树 和 right 的左子树是否相等， 都不出问题，才是对称。什么情况下出问题呢？分别是：两个节点中只有一个为空，肯定不对称；两个节点的值不相等，也肯定不对称。递归到什么程度就对称了，递归到左右节点都没有子节点了，即两个节点都为空了。

基于以上的逻辑再写递归，不要上来就按照三部曲写递归，逻辑都不清楚，写什么递归。

递归三部曲

1.确定递归函数的参数和返回值

​	因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。返回值自然是bool类型。

```Java
public boolean compare(TreeNode left, TreeNode right){}
```

2.确定递归终止条件

一定要先判断节点为空的情况，再判断数值是否相等，否则会出现空指针问题（这在二叉树里尤为重要）

- 左子树为空，右子树为空，对称，return true
- 左右子树只有一个为空，不对称，return false
- 左右子树根节点的值不相等，不对称，return false

同时也要注意，判断时可以写 if 或者 else if，但不能写else，因为还有情况是左右子树都不为空且左右子树根节点值相等的情况，但这种情况显然可能并没有递归到底，所以并不能作为终止条件

```Java
if (left == null && right == null) return true;
if(left == null || right == null) return false;
if (left.val != right.val)  return false;
```

3.确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右子树都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

整体代码如下：

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        //调用递归函数，比较左节点，右节点
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode left, TreeNode right){
        //递归的终止条件是两个节点都为空
        //或者两个节点中有一个为空
        //或者两个节点的值不相等
        if (left == null && right == null) return true;
        if(left == null || right == null) return false;
        if (left.val != right.val)  return false;
        // 比较外侧，即左节点的左孩子 和 右节点的右孩子
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧，即左节点的右孩子 和 右节点的左孩子
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
}
```

此题使用递归方法，自然也可以使用非递归方法，还是那个道理，递归是系统压入栈，我们自然可以自己实现栈（队列也可以），将需要比较的节点放入栈或队列，弹出后比较，弹出时再放入子节点，详见提交记录里的其它解法。



#### 110. 验证平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

左程云介绍的递归套路，可以解决二叉树的树型DP问题，即可以通过从左右子树获取信息的方式来解决的问题

以本题为例，首先分析二叉树里，以任意一个节点x为根的树，需要什么样的条件，才能是平衡二叉树：

* 左子树是平衡二叉树
* 右子树是平衡二叉树
* | 左子树高度-右子树高度 | < 2

只有同时满足上述三个条件，x为根的树才能是平衡二叉树。那么现在x为根的树需要子树提供什么样的信息呢：

* 左子树提供是否是平衡二叉树、以及左子树的高度
* 右子树提供是否是平衡二叉树、以及右子树的高度

因为是递归，左右子树需要统一信息，即子树提供两个信息：子树提供是否是平衡二叉树、子树的高度，编写代码时将其作为单独的类封装起来，供递归调用

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 封装子树需要提供的信息
    public static class ReturnType {   
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

    public static ReturnType process(TreeNode x) {
        if(x == null) return new ReturnType(true,0); // 递归的base

        // 左右子树递归
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);

        // 递归所需信息的处理
		int height = Math.max(leftData.height, rightData.height) + 1; // 左右子树的最大高度加1
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;

        // 返回递归所需信息
        return new ReturnType(isBalanced, height);

    }
}
```

此思想的简化代码版本，来自力扣题解。核心思想是一致的，即构造一个获取当前节点最大深度的方法`depth(root)`，通过比较此子树的左右子树的最大高度差来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。

简单来说，就是将上面封装类中的isBalanced写为递归函数。

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

这个代码思想是自顶向下的递归，更优解是自底向上的递归，后续再整理

这道题后面也可以整理一下，还是聚焦于判断，一个根节点为x的二叉树，满足什么条件才是平衡二叉树，就和二叉树的最大深度、最小深度一样。想清除这个自顶向下的递归逻辑，就容易写出来，感觉左程云的套路还是稍微复杂了一点，虽然思想是一样的





#### 112. 路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

总体思路：二叉树的遍历+回溯（做过回溯再做这道题就很简单）

targetSum 是从根节点到叶子节点的路径上的节点值相加的目标和，对 root 递归。转为判断：root 的左、右子树中能否找出和为 sum-root.val 的路径，这样就变成一个规模小一点的相同问题。即，每遍历一个节点，sum 就减去当前节点值，当遍历到叶子节点时，因为没有子节点了，如果 sum - 当前叶子节点值 == 0 ，即找到了从根节点到叶子节点的和为 sum 的路径。

时间复杂度：O(n)，每个节点被遍历一次

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        // 遍历到叶子节点，如果当前剩下的targetSum-当前节点的val = 0，那就刚好返回true
        if(root.left == null && root.right == null) return targetSum-root.val == 0;
        // 不是上面的情况，则拆成两个子树的问题，其中一个true了就行
        if (root.left != null){
            // 这里不能直接写成 return hasPathSum(root.left,targetSum-root.val); 
            // 因为如果返回的false只是代表左子树可能没有，但右子树可能有，直接返回false就没考虑右子树
            boolean left = hasPathSum(root.left,targetSum-root.val);
            if (left) return true;
        }
        if (root.right != null){
            boolean right = hasPathSum(root.right,targetSum-root.val);
            if (right) return true;
        }
        return false;
    }
}
```

if (root.left != null) 处的注释需要格外关注，所以更好的写法是下满这种，|| 很好的解决了这种冲突，在二叉树左右子树的递归问题里很常见

```Java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) return false;
        // 遍历到叶子节点，如果当前剩下的targetSum-当前节点的val = 0，那就刚好返回true
        if(root.left == null && root.right == null) return targetSum-root.val == 0;
        // 不是上面的情况，则拆成两个子树的问题，其中一个true了就行
        return hasPathSum(root.left,targetSum-root.val) || hasPathSum(root.right,targetSum-root.val);
    }
}
```



#### 113. 路经总和Ⅱ

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

和上一题类似，只是本题需要将path记录下来，回溯做多了的话此题并不难

```Java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    Deque<Integer> path = new ArrayDeque<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root == null) return res;
        backTracking(root, targetSum);
        return res;
    }

    public void backTracking(TreeNode node, int targetSum){
        // 递归终止条件1
        if(node == null) return;
        // 递归终止条件2：目标
        if(node.left == null && node.right == null && targetSum-node.val ==0){
            // 自己写的时候漏加了这一步的addLast和removeLast
            // 其实这一步满足条件只是判定了下，但还没有加进队列以及回溯出去，以后需要注意
            path.addLast(node.val);
            res.add(new ArrayList(path));
            path.removeLast();
            return;
        }
        // 单层递归，回溯左右子树
        path.addLast(node.val);
        backTracking(node.left,targetSum-node.val);
        backTracking(node.right,targetSum-node.val);
        path.removeLast();
    }
}
```

上面的单层递归里，还可以写成下面这样，但其实没必要，因为进入左右子树的path是一样的，左右子树递归到最后，总要回溯的，也就是总要调用removeLast()。写写画画就知道了

```Java
path.addLast(node.val);
backTracking(node.left,targetSum-node.val);
path.removeLast();		 // 其实和最后一行重复
path.addLast(node.val);  // 其实和第一行重复
backTracking(node.right,targetSum-node.val);
path.removeLast();
```



### 3. 二叉树的修改与改造

#### 226. 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转二叉树非常简单，不用想的太复杂，其实就是把每个节点的左右子节点交换而已，那么如何访问到每个节点自然是关键之处，还是使用各种遍历方法。前序、后序、层序都很简单。中序遍历会把某些节点的左右孩子翻转了两次，虽然可以通过代码避免，不建议使用（动笔写写画画就知道了）

前序递归遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

层序遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                swap(cur);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
        }
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```



#### xxx. 寻找二叉树的后继节点

此题来自左程云算法课，没找到对应力扣，记录一下

现在有一种新的二叉树节点类型如下：

```Java
public class Node {
    public int value;
    public Node left;
    public Node right;
    public Node parent;
    public Node(int val) {
    	value = val;
    }
}
```

该结构比普通二叉树节点结构多了一个指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。
只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。**在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点。**

分析：

本题返回的后继节点在平常自然可以通过二叉树的中序遍历找到，但时间复杂度为O(n)，但其实如果一个节点到后继节点的距离为k，**根据新结构**是可以得到时间复杂度为O(k)的设计。比如一棵二叉树为 1 2 3 4 5 6 7。中序遍历顺序为4 2 5 1 6 3 7

4到2树上的距离显然是1，不用中序遍历才能找到4的后继节点2，再比如5的后继节点是1，树上的距离为2，可以用O(2)的复杂度得到1，当然了这是建立在此题的二叉树新结构基础上。

就本题而言，任意一个节点x，其后继节点分为两种情况：

* x有右子树的时候，x的后继节点为右子树的最左叶子节点Y，从中序遍历的角度去想是不难的

    ![image-20220420104629607](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A3)

* x无右子树的时候，往上走看每个节点，看自己是不是父亲的左孩子，是的话，该节点Y就是x的后继节点。因为从节点Y看，x就是自己左树的最右子节点。其后继节点就是Y。不是的话，说明x就是整棵树的最右叶子节点，他的后继是空

    ![image-20220420105003143](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/xxx%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9-%E5%9B%BE%E8%A7%A31.png)

整体代码为：

```Java
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return node;
    }
    // 情况1：节点x有右子树，x的后继节点为右子树的最左叶子节点
    if (node.right != null) {
        return getLeftMost(node.right);
    } else {
        // 情况2：节点x没有右子树，向上遍历
        Node parent = node.parent;
        // 向上遍历停止的条件：
        //（1）遍历到空了，说明节点x是整棵树的最右叶子节点
        // (2) 发现了自己是父节点的左孩子
        while (parent != null && parent.left != node) {
            // 这两步是一直向上遍历
            node = parent;
            parent = node.parent;
        }
        // 此时的parent就是x节点的后继节点
        return parent;
    }
}

public static Node getLeftMost(Node node) {
    if (node == null) {
        return node;
    }
    while (node.left != null) {
        node = node.left;
    }
    return node;
}
```



#### 297. 二叉树的序列化与反序列化

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。[297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

解法一：DFS

序列化：递归的第一步都是特例的处理，因为这是递归的中止条件：按照先序遍历，如果根节点为空，返回”null“，序列化的结果为：根节点值 + "," + 左子节点值(进入递归) + "," + 右子节点值(进入递归)，递归就是不断将“根节点”值加到结果中的过程

反序列化：先将字符串转换成队列，接着也是前序遍历的递归，弹出左侧元素，即队列出队，如果元素为“null”，返回null，否则，新建一个值为弹出元素的新节点，其左子节点为队列的下一个元素，进入递归；右子节点为队列的下下个元素，也进入递归，递归就是不断将子树的根节点连接到父节点的过程

```Java
public class Codec {

    // 序列化
    public String serialize(TreeNode root) {
        if(root == null) return "null,";
        // 前序遍历
        String res = root.val + ",";
        res += serialize(root.left);
        res += serialize(root.right);
        return res;
    }

    // 反序列化
    public TreeNode deserialize(String data) {
        // 将字符串转为队列
        String[] values = data.split(",");
        Queue<String> queue = new ArrayDeque<>();
        for(int i=0; i<values.length; i++){
            queue.offer(values[i]);
        }
        // 或者用Arrays.asList()方法
        // Queue<String> queue = new ArrayDeque<>(Arrays.asList(values));
        return dfs(queue);
    }

    public TreeNode dfs(Queue<String> queue) {
        String val = queue.poll();
        if("null".equals(val)) return null;
        // 依然是前序遍历
        TreeNode root = new TreeNode(Integer.parseInt(val));
        root.left = dfs(queue);
        root.right = dfs(queue);
        return root;
    }
}
```

解法二：BFS



### 4. 二叉搜索树的属性

#### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
		LinkedList<Long> inOrderList = new LinkedList<>();
		process(root, inOrderList);
        long pre = Long.MIN_VALUE;
        for(long cur: inOrderList){
            if(pre >= cur) return false;
            pre = cur;
        }
        return true;
    }

    public static void process(TreeNode node, LinkedList<Long> inOrderList) {
        if (node == null) {
            return;
        }

        process(node.left, inOrderList);
        inOrderList.add((long)node.val); // 操作元素，注意转换
        process(node.right, inOrderList);
	}
}
```



解法二：在递归过程中，判断是否升序（**最佳**）

中序递归遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。其实也就是把中序遍历的打印操作换成一个判断操作

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        // 递归左子树
        if(!isValidBST(root.left)) return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if(root.val <= pre) return false;
        pre = root.val;
        
        // 递归右子树
        return isValidBST(root.right);
    }
}
```



解法三：在非递归过程中，判断是否升序

和解法二类似，都是在过程中判断是否升序，只不过换成了非递归的中序

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); 
               
                // 非递归遍历中加入的判断
                if(root.val <= pre) return false;
                else pre = root.val;

                root = root.right; 
            }
        }
        return true;
    }
}
```



解法四：左程云的二叉树递归套路（暂时跳过）

```Java

```





#### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。









### 5. 二叉树的公共祖先

#### 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

说白了就是两个点往上，第一个在哪里汇聚，包括其中一个点是自身。



这道题还是用递归去解决，现在用以后一直贯穿的思想，递归三部曲：

（1） 递归函数的功能、返回值、参数类型

本题递归函数就是为了在树上找节点，主要目的有三个：对于给定两个节点 p 和 q，

* 如果 p 和 q 都存在，则返回它们的公共祖先；
* 如果只存在一个，则返回存在的一个；
* 如果 p 和 q 都不存在，则返回NULL

```Java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {}
```

（2）递归的终止条件

向下找一直找到了叶子节点，那肯定得返回。还有就是找到了p或者q节点，那这棵树一定返回 p 或者 q

```Java
if(root == null) return root;           //递归终止条件1：找完叶子节点
if(root == p || root == q) return root; //递归终止条件2：找到了p或q节点
```

（3）单层递归逻辑

若 root是 p, q 的 **最近公共祖先** ，则只可能为以下情况之一：

* p 和 q 在 root 的子树中，且分列 root 的异侧（即分别在左、右子树中）；
* p = root，且 q 在 root 的左或右子树中；
* q = root，且 p 在 root 的左或右子树中；

递归左右子树，**因为是递归，使用函数后可认为左右子树已经算出结果**，用 left 和 right 表示。若left为空，那最终结果只要看右子树返回；若 right为空，那最终结果只要看左子树返回（如果 left 和 right 都空其实也包含在这里面）。如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先

```Java
TreeNode left = lowestCommonAncestor(root.left,p,q);
TreeNode right = lowestCommonAncestor(root.right,p,q);
if(left == null) return right;
if(right == null) return left;
return root;  // if(left != null && right != null)
```



完整代码为：

```Java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;           //递归终止条件1：找完叶子节点
        if(root == p || root == q) return root; //递归终止条件2：找到了p或q节点
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left == null) return right;
        if(right == null) return left;
        return root; // if(left != null && right != null)
    }
}
```



#### 235. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。















# 排序

排序一般是基于数组的，我们常见的排序算法可以分为：

基础排序：选择排序、冒泡排序、插入排序、希尔排序，其中插入排序很重要，希尔排序只需要知道思想；

归并排序和快速排序：非常重要，它们是理解「递归」的很好的学习材料；

堆排序暂时不涉及，放在优先队列进行介绍；

非比较排序：计数排序、基数排序、桶排序。它们不是绝大多数面试和笔试的考点。

他们的时间复杂度为：

| 算法     | 最好时间 | 最坏时间 | 平均时间    | 额外空间 | 稳定性 |
| -------- | -------- | -------- | ----------- | -------- | ------ |
| 选择排序 | O(n^2）  | O(n^2)   | O(n^2)      | O(1)     | 不稳定 |
| 冒泡排序 | O(n）    | O(n^2)   | O(n^2)      | O(1)     | 稳定   |
| 插入排序 | O(n）    | O(n^2)   | O(n^2)      | O(1)     | 稳定   |
| 希尔排序 |          | O(n^2)   | O(n·logn^2) | O(1)     | 不稳定 |
|          |          |          |             |          |        |
|          |          |          |             |          |        |
|          |          |          |             |          |        |
|          |          |          |             |          |        |





## 选择排序

在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。第一轮for循环遍历每个位置，内嵌第二轮for循环去未排序序列里寻找每个位置适合的元素

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=0; i<nums.length; i++){
            int minIndex = i;
            for(int j=i+1; j<nums.length; j++){
                if(nums[j]<nums[minIndex]) minIndex = j;
            }
            swap(nums,i,minIndex);
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 冒泡排序

n个数，需要比较n-1轮，每轮将最大（小）的数冒泡（交换）到后面，因为最后面的 i 个数已经排好序了，所以每轮要比较的次数在不断变少，为n-1-i

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        for(int i=0; i<nums.length-1; i++){
            for(int j = 0; j<nums.length-1-i; j++)
                if(nums[j] > nums[j+1]) swap(nums,j+1,j);
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

优化：如果扫描一次剩下的元素发现没有元素需要交换，说明此时数组已经有序了，程序提前终止，那么对于完全有序的数组，它就成了O(n)复杂度。

代码里加上一个标志位 sorted 来解决，在外层for循环的条件上加上sorted，意为发生排序了才进行后面的循环。初始化时赋为true，以便进入循环，进行每层内循环前要先设为false，内循环里如果发生交换了，再设为true

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        boolean sorted = true;
        for(int i=0; i<nums.length-1 && sorted; i++){
            sorted = false;
            for(int j = 0; j<nums.length-1-i; j++)
                if(nums[j] > nums[j+1]) {
                    swap(nums,j+1,j);
                    sorted = true;
                }
        }
        return nums;
    }
    private void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 插入排序

插入排序基本思想是把 nums[i] 插入有序数组 nums[0..i - 1]。有两种插入的方式：（1）逐个交换：待插入元素逐个交换到前面，每次比较当前元素和前一个元素的大小，符合条件就交换，这种比较浪费时间，没写代码。（2）先暂存再后移：先暂存待插入元素，然后将前面比暂存元素严格大的后移。

写代码之前画画图

```Java
class Solution {
    public int[] sortArray(int[] nums) {
        // 把 nums[i] 插入有序数组 nums[0..i - 1]，从nums[1]开始，nums[0]不用动
        for(int i=1; i<nums.length; i++){
            int temp = nums[i];  // 先保存nums[i]，通过索引j找到合适的位置再插入
            int j;				 // 索引j保存合适的位置，后面需要用到，不能放到for循环里初始化
            // 有索引j-1，j不能为0
            for(j=i; j>0 && nums[j-1]>temp; j--)  // 前面的元素比nums[i]大
                nums[j] = nums[j-1];              // 就将前面的元素后移
            nums[j] = temp;                       // 找到了合适的位置替换为nums[i]
        }
        return nums;
    }
}
```



## 希尔排序

希尔排序是 「**分组插入排序**」 或者 「**带间隔的插入排序**」。好处是：**让较小的元素一下子来到数组的前面**。

了解思想即可



## 归并排序



## 快速排序



## 堆排序













# 查找

## 二分查找





## 双指针

双指针是解题中常用的思想，能够解决很多问题，此处记录一下典型的双指针问题



### 15. 三数之和







### 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下**原地**对数组进行操作。[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

由于是原地操作，本题可以使用双指针解决

**方法一：向前赋值非0元素**

我们创建两个指针 i 和 j，第一次遍历的时候指针 j 用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。第二次遍历的时候，起始位置就从 j 开始到结束，将剩下的这段区域内的元素全部置为0。

```Java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int j=0; // 额外指针
        // 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]
        for(int i=0; i<nums.length; i++){
            if(nums[i] != 0){
                nums[j] = nums[i];
                j++; // 注意是赋值后+1
            }
        }
        for(int i=j; i<nums.length; i++){
            nums[i] = 0;
        }
    }
}
```

**方法二：向后赋值0元素**

第一种方法是碰到非0元素就找到合适的位置（用 j 记录）覆盖掉原来的元素，相当于是向前赋值非0元素。还有一种是思想是碰到非0元素就和第一个0元素（还是用 j 记录）交换一下位置，相当于是将0元素不断向后移。

```Java
class Solution {
	public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
		int j = 0; // 额外指针
		for(int i=0;i<nums.length;i++) {
			//当前元素!=0，就把其交换到左边，等于0的交换到右边
			if(nums[i]!=0) {
				int tmp = nums[i];
				nums[i] = nums[j];
				nums[j++] = tmp;
			}
		}
	}
}
```

还有个优化是这里的交换没有必要真正的交换，很浪费时间，直接将第一个0元素位置赋值为当前的非0元素，然后非0元素那里赋值为0。注意防止非0元素的交换

```Java
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums == null || nums.length == 0) {
            return;
        }
        int j = 0;
        for (int i = 0; i < length; i++) {
            if (nums[i] != 0) {  // 非0就右移j，所以除非都是非0，否则j总能指向第一个0
                if (i > j) {     // 防止都是非0的情况
                    nums[j] = nums[i];
                    nums[i] = 0;
                }
                j++;
            }
        }
    }
}
```



### 26. 删除有序数组中的重复项

给你一个 **升序排列** 的数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

解法：双指针

指针定义的指向不同，代码就不同，为了统一，建议将额外指针 j 指向待修改的元素，保持这个循环不变量，会更好解题。j<1时，直接覆盖并向右移，j>=1 时，就要比较当前遍历的元素和nums[j - 1] 处元素的大小了，谨记 j 始终指向待修改的位置。这里其实用增强for循环，能够更好的理解，数组中的元素反正是都要遍历一遍的，我们只需要关注 j 的位置就好

```Java
class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0; 
        for (int x : nums) {
            if (j < 1 || nums[j - 1] != x){
                nums[j] = x;
                j++;
            }
        }
        return j;
    }
}
```



### 80. 删除有序数组中的重复项Ⅱ

给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。[80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

为了扩展，直接写出使每个元素最多出现K次，和上题强调的一样，让 j 始终指向待修改的元素。j<k时，直接覆盖并向右移，j>=k 时，就要比较当前遍历的元素和nums[j - k] 处元素的大小了。这里其实用增强for循环，能够更好的理解，数组中的元素反正是都要遍历一遍的，我们只需要关注 j 的位置就好

```Java
class Solution {
    public int removeDuplicates(int[] nums) {   
        return process(nums, 2);
    }
    public int process(int[] nums, int k) {
        int j = 0; 
        for (int x : nums) {
            if (j < k || nums[j - k] != x){
                nums[j] = x;
                j++;
                // 或者nums[j++] = x;
            }
        }
        return j;
    }
}
```





### 27.  移除元素

给你一个数组 `nums` 和一个值 `val`，你需要原地移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

解法：双指针

```Java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums==null || nums.length==0) return 0;
        int j = 0;
        for(int i=0; i<nums.length; i++){
            if(nums[i] !=val ){
                nums[j] = nums[i];
                j++;
            }
        }
        return j;
    }
}
```



## 滑动窗口

### 3. 无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。 [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)





### 剑指Ⅱ008. 和大于等于 target 的最短子数组

[剑指 Offer II 008. 和大于等于 target 的最短子数组](https://leetcode-cn.com/problems/2VG8Kg/)





## BFS





## DFS

### xxx. 汉诺塔问题

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。[面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

对于三个柱子A、B、C，A上有n个盘子，

* n = 1 时，直接把盘子从 A 移到 C；
* n > 1 时，
    * 先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
    * 再将最大的盘子从 A 移到 C；
    * 再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）

```Java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlant(A.size(),A,B,C);
    }

    //size 需要移动的盘子的数量、start 起始的柱子、other 辅助柱子、target 目标柱子
    public void movePlant(int size, List<Integer> start,List<Integer> other,List<Integer> target){
        //当只剩一个盘子时，直接将它从第一个柱子移动到第三个柱子
        if(size == 1){
            target.add(start.remove(start.size()-1));
            return;
        }
        //首先将 n-1 个盘子，从第一个柱子移动到第二个柱子
        movePlant(size-1,start,target,other);
        //然后将最后一个盘子移动到第三个柱子上
        target.add(start.remove(start.size()-1));
        //最后将第二个柱子上的 n-1 个盘子，移动到第三个柱子上
        movePlant(size-1,other,start,target);
    }
}
```





### 200. 岛屿数量

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

![image-20220426231056043](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E5%9B%BE%E8%A7%A3.png)

本题属于网格类搜索问题，常用的方法都是DFS和BFS，同类型的还可以看回溯小节-79单词搜索

方法一：DFS

目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。设目前索引指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。从 (i,  j) 向此点的上下左右 (i+1, j)，(i-1, j)，(i, j+1)，(i, j-1) 做深度搜索。遍历遇到 1 即遇到土地，土地肯定在一个岛上，计数 +1。

注意：每次遍历需要把遍历过的1重新记为0，如果不把与它和同在一个岛的土地变成 0，则DFS遍历到它们时，会对一个岛重复计数。所以每次遍历都要将当前的 1 变 0（沉岛思想），当前坐标的上下左右依次递归，同处一个岛的 1 都变 0。

终止条件：

* (i, j) 越过矩阵边界;

* grid[i] [j] == 0，代表此方块已经被遍历过。

```Java
class Solution {
    public int numIslands(char[][] grid) {
        int res = 0;
        for(int i=0; i<grid.length; i++){
            for(int j=0; j<grid[0].length; j++){
                if(grid[i][j] == '1'){
                    dfs(grid,i,j);
                    res++;
                }
            }
        }
        return res;
    }

    private void dfs(char[][] grid, int i, int j){
        // 递归终止条件：越界、重复
        if(i<0||j <0 || i>=grid.length || j>=grid[0].length || grid[i][j] == '0'){
            return;
        }
        grid[i][j] = '0';     // 沉岛
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```



不过从工业界角度想，最好能够克隆一份grid，直接修改原始的数组不太好，面试看有没有机会提到吧，不是重点

```Java
int[][] copy = new int[m][n];
for(int i = 0;i < m;i++) {
    for(int j = 0;j < n;j++) {
        copy[i][j] = grid[i][j];
    }
}
```



方法二：BFS





### 695. 岛屿的最大面积

给你一个大小为 m x n 的二进制矩阵 grid 。岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。岛屿的面积是岛上值为 1 的单元格的数目。计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

![image-20220427102539142](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/695%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-%E5%9B%BE%E8%A7%A3.png)

**解法一：DFS**

解法同上一题，但每次遍历时，给为1的计数。一开始做这道题时，想到了思路，但是没写出来，没写出`num += dfs(...)`这种结构，还是写的太少了。

```Java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int res = 0; 
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {  // 注意改成了整型数组
                    res = Math.max(res, dfs(i, j, grid));
                }
            }
        } 
        return res;
    }

    private int dfs(int i, int j, int[][] grid) {
        if (i < 0 || j < 0 || i >= grid.length || j >= grid[i].length || grid[i][j] == 0) { 
            return 0;
        } 
        grid[i][j] = 0;  // 沉岛
        int num = 1;     // 默认num为1，进入后判断如果不是岛屿，则直接返回0
        num += dfs(i + 1, j, grid);
        num += dfs(i - 1, j, grid);
        num += dfs(i, j + 1, grid);
        num += dfs(i, j - 1, grid);
        return num;
        
    }
}
```









## 回溯

（二刷的时候整理好代码的变量名、方法名规范）

回溯算法是一种遍历算法，以 **深度优先遍历** 的方式尝试所有的可能性。有些教程上也叫**暴力搜索**。回溯算法是 **有方向地** 搜索，区别于多层循环实现的暴力法。

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案。

由于回溯和深度优先搜索有着千丝万缕的联系，因此也介绍下深度优先搜索

深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；具体实现起来，ArrayList、LinkedList等都可以实现

回溯算法与深度优先遍历都有不撞南墙不回头的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而深度优先遍历强调一种遍历的思想，不回退，与之对应的遍历思想是广度优先遍历。至于广度优先遍历为什么没有成为强大的搜索算法，后面会提。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。



一些精彩的描述：（整理差不多了之后，自己总结下）

回溯：在包含问题所有解的空间树中，用DFS的方式，从根节点出发，搜索整棵解空间树。

搜索至任何一个节点时，总是会先判断当前节点是否可以通往最后的合法解。如果不可以，则结束对「以当前节点为根节点的子树」的搜索，向父节点回溯，回到之前的状态，搜索下一个分支。否则，进入该子树，继续以DFS的方式搜索。

空间树中的节点是动态的，即，当前有哪些选项可选择，是根据上一步的选择得出的，所以做回溯时，要把状态还原成进入当前节点之前的状态。

确定出问题的解空间树，它是隐式的，不是显式的一棵树。不熟练的就画图看看。

然后，明确每个节点的扩展搜索规则。然后进行DFS搜索，并注意剪枝，避免无效的搜索。



回溯的三个要素：选择（选项）、约束条件、目标。

我们关心当下有什么选择，作了一个选择之后，会怎么限制下一个选择。所以，不仅要关注选择（选项），还要关注约束条件。前者展开出一棵解的空间树，后者用来剪枝，剪去不能产生正确解的分支，避免无效搜索。第三个要素：目标（结束条件），明确了目标，就知道何时去将解加入解集。并且让你知道：搜索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。



回溯问题类型以及经典题型

| 类型       | 题目                                                         |
| ---------- | ------------------------------------------------------------ |
| 子集、组合 | [子集](https://leetcode-cn.com/problems/subsets/)、[子集 II](https://leetcode-cn.com/problems/subsets-ii/)、[组合](https://leetcode-cn.com/problems/combinations/)、[组合总和](https://leetcode-cn.com/problems/combination-sum/)、[组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/) |
| 全排列     | [全排列](https://leetcode-cn.com/problems/permutations/)、[全排列 II](https://leetcode-cn.com/problems/permutations-ii/)、[字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)、[字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/) |
| 搜索       | [单词搜索](https://leetcode-cn.com/problems/word-search/)、[N皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)、[分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)、[二进制手表](https://leetcode-cn.com/problems/binary-watch/)、[解数独](https://leetcode-cn.com/problems/sudoku-solver/) |



### 78. 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。 [78. 子集](https://leetcode-cn.com/problems/subsets/)

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**

其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。

**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从begin开始，而不是从0开始！**而且子递归给`i+1`

什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合。后序会讲

![78.子集](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/78%E5%AD%90%E9%9B%86-%E5%9B%BE%E8%A7%A3.png)

代码：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>(); //用ArrayList速度会快一点
    public List<List<Integer>> subsets(int[] nums) {
        backTracking(0,nums);
        return res;
    }

    public void backTracking(int begin, int[] nums){
        res.add(new LinkedList<>(path));  // 不同点：遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合
        if(begin >= nums.length) return;  // 不加递归终止条件也可以，因为for循环会递归完
        for(int i=begin; i<nums.length; i++){
            path.addLast(nums[i]);    // 用ArrayList就是path.add(nums[i])
            backTracking(i+1, nums);  // 自己写写成了begin+1，以后注意
            path.removeLast();        // 用ArrayList就是path.remove(path.size()-1)
        }
    } 
}
```



**需要非常注意的是 要使用res.add(new LinkedList<>(path))这样保存结果，res.add(path)会为空**

因为变量 `path` 所指向的列表 **在深度优先遍历的过程中只有一份** ，深度优先遍历完成以后，回到了根结点，成为空列表。在 Java 中，参数传递是 **值传递**，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 `res` 变量，但实际上指向的是同一块内存地址，这块内存地址最后都变成 [ ] 了，所以打印出来的也都是空，所以要弄一份当前的拷贝，放入 res，这样后续对 path 的操作，就不会影响已经放入 res 的内容



### 90. 子集Ⅱ

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。 [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

区别就是集合里有重复元素了，而且求取的子集要去重。解法和第40题 组合总和Ⅱ相同

```Java
class Solution {
  List<List<Integer>> res = new ArrayList<>();
  Deque<Integer> path = new LinkedList<>();
  public List<List<Integer>> subsetsWithDup( int[] nums ) {
    Arrays.sort( nums );  // 先排序
    subsetsWithDupHelper( nums, 0 );
    return res;
  }

  private void subsetsWithDupHelper( int[] nums, int begin ) {
    res.add( new ArrayList<>( path ) );

    for ( int i = begin; i < nums.length; i++ ) {
        // 跳过当前树层使用过的、相同的元素
        if ( i-1 >= begin && nums[i - 1] == nums[i] ) continue;
        path.addLast( nums[i] );
        subsetsWithDupHelper( nums, i + 1 );
        path.removeLast();
    }
  }
}
```





### 77. 组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。你可以按 **任何顺序** 返回答案。      [77. 组合](https://leetcode-cn.com/problems/combinations/)

**回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了**

![image-20220407101907621](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/77%E7%BB%84%E5%90%88-%E5%9B%BE%E8%A7%A3.png)

> 图源：[回溯算法 + 剪枝](https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/)



叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 path，它是一个列表，特别地，path 是一个栈；

每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start ，表示在区间 [begin, n] 里选出若干个数的组合；

**回溯递归三部曲：**

* 递归函数的返回值以及参数：返回值为空，题目要求的两个参数传入，并将两个结果集（一个最终结果，一个临时结果）作为参数传入，或者设为全局变量（很多题目的递归函数参数不是一开始就能定下来的，先写着）

    ```Java
    public void backTracking(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path)
    ```

* 回溯函数终止条件：path这个数组的大小如果达到k，就到达叶子节点了

    ```Java
    if(path.size()==k){  
        ......  
        return;
    }
    ```

* 单层搜索的过程，由于元素是不能重复的，因此选完一个元素，就得从剩下的元素里选择，所以递归时需要`backTracking(i+1)`

    ```java
    for (int i = begin; i <= n; i++) {
        path.addLast(i);   // 处理节点
        backTracking(n, k, i + 1, path, res); // 递归：backTracking
        path.removeLast(); // 回溯，撤销处理的节点
    }
    ```



整体代码如下

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的最终集合
        Deque<Integer> path = new LinkedList<>();     // 存放符合条件结果的临时集合，队列或数组都可以
        if(k<=0 || k>n) return res;
        backTracking(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void backTracking(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            backTracking(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```

**辅助解题**

在解题时候可以在回溯周围加入打印信息，给一个测试用例，观察递归写的是否正确，这点非常重要！！自己写递归经常容易出问题

```Java
public class Combinations {
    public List<List<Integer>> combine(int n, int k) {
		......
    }

    private void backTracking(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i <= n; i++) {
            path.addLast(i);
            System.out.println("递归之前 => " + path);
            backTracking(n, k, i + 1, path, res);
            path.removeLast();
            System.out.println("递归之后 => " + path);
        }
    }

    public static void main(String[] args) {
        Combinations solution = new Combinations();
        int n = 5;
        int k = 3;
        List<List<Integer>> res = solution.combine(n, k);
        System.out.println(res);
    }
}
```

> 递归之前 => [1]
> 递归之前 => [1, 2]
> 递归之前 => [1, 2, 3]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 4]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 5]
> 递归之后 => [1, 2]
> 递归之后 => [1]
>
> ......

**剪枝优化**

上面的题解中，可以进行优化。分析搜索起点的上界进行剪枝处理。

分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 `path` 的长度相关。我们举几个例子分析：

例如：`n = 6 ，k = 4`。

path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 44，最后一个被选的组合是 [4, 5, 6]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 55，最后一个被选的组合是 [5, 6]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 66，最后一个被选的组合是 [6]；

再如：n = 15 ，k = 4。
path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 1313，最后一个被选的是 [13, 14, 15]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 1414，最后一个被选的是 [14, 15]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 1515，最后一个被选的是 [15]；

可以归纳出：

**搜索起点的上界 + 接下来要选择的元素个数 - 1 = n**

得到搜索起点的上界 = n - (k - path.size()) + 1，所以，我们的剪枝过程就是：把 `i <= n` 改成 `i <= n - (k - path.size()) + 1` ：

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的集合
        Deque<Integer> path = new LinkedList<>();     // 用来存放符合条件结果
        if(k<=0 || k>n) return res;
        dfs(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void dfs(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n - (k - path.size()) + 1; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            dfs(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```



很多剪枝优化想出来其实不容易，只能多做题练习了







### 39. 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]

示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]

这道题和 [77. 组合](https://leetcode-cn.com/problems/combinations/) 的差别在于：

- 组合总和的元素个数没有数量要求
- 元素可无限重复选取

![image-20220411102216417](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E5%9B%BE%E8%A7%A3.png)

>  （图源：[「手画图解」怎么分析回溯问题？](https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/)）

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

还是熟悉的递归方式

**回溯递归三部曲**

- 递归函数参数

首先是题目中给出的参数，集合candidates, 和目标值target，以及两个结果集

此外还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。

**本题还需要begin来控制for循环的起始位置，对于组合问题，什么时候需要begin呢？**

我举过例子，如果是**一个集合来求组合的话，就需要begin**，例如：[77.组合](https://programmercarl.com/0077.组合.html)，[216.组合总和III ](https://programmercarl.com/0216.组合总和III.html)。

如果是**多个集合取组合，各个集合之间相互不影响，那么就不用begin**，例如：[17.电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)

注意以上只是说**求组合的情况**，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍

```Java
public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin)
```

- 递归终止条件

终止只有两种情况，sum大于target和sum等于target。sum等于target的时候，需要收集结果

```Java
if (sum > target) {
    return;
}

if(sum == target){
    res.add(new LinkedList<>(path));
    return;
}
```

- 单层搜索的逻辑

单层for循环依然是从startIndex开始，搜索candidates集合。

注意本题和上一题最大的差别在于，本题元素为可重复选取的，所以递归时不用`backTracking(i+1)`

```Java
for(int i=begin; i< candidates.length; i++){
    sum += candidates[i];
    path.addLast(candidates[i]);
    bfs(candidates, target, res, path, sum, i); // 本题元素为可重复选取的，所以下一个begin还是i
    sum -= candidates[i];  // 回溯
    path.removeLast();     // 回溯
}
```

所以整体代码为：

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin){
        if (sum > target) {
            return;
        }
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i); 
            sum -= candidates[i];  // 回溯
            path.removeLast();     // 回溯
        }
    }
}
```

递归的for循环也可以写为：

```Java
for(int i=begin; i< candidates.length; i++){
    path.addLast(candidates[i]);
    // 这种其实就是永远在形参里传递sum，没进递归终止条件才更新sum，所以不用像上面显式更新num后面也不用回溯，但不利于理解，上面的写法更好理解一点
    bfs(candidates, target, res, path, sum+candidates[i], i);
    path.removeLast();
}
```



**辅助解题**

同样的，在递归前后加上打印信息，此处略



**剪枝优化**

在基本的递归写完后，可以进行进一步的优化。

对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。那么可以在for循环的搜索范围上做做文章了。

**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历**。

注意，这是组合问题，可以这样操作，如果是排序就另说了

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        Arrays.sort(candidates); // 先进行排序
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            // 如果 sum + candidates[i] > target 就终止此次递归，回退到上一轮递归
            if (sum + candidates[i] > target) break;
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```





### 40. 组合总和Ⅱ

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。**注意：**解集不能包含重复的组合。  [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]

示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]

这道题目和 [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) 有如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，而上一题是无重复元素的数组candidates

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。即难点在于去重，**所谓去重，其实就是使用过的元素不能重复选取。** 

以candidates = [2,5,2,1,2], target = 5 为例， 所求解集为: [  [1,2,2],  [5] ]

![image-20220411101837423](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/40%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1-%E5%9B%BE%E8%A7%A3.png)

>  图源：[手画图解 | 长文漫谈回溯 | 40. 组合总和 II ](https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/)

如果是把所有组合求出来，再用set或者map去重，这么做很容易超时！所以要在搜索的过程中就去掉重复组合。如上图所示，选取1后，剩下的三个2只用选第一个即可，其他的2选取了也没意义，属于同一个树层的重复选取，相比于上一题只需改动三点：

* 先排序，使得重复的数字相邻，方便去重。（上一题是 作为剪枝优化方法）
* for循环加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
* 每个数字只能选用1次，1个元素选完只能从剩下的元素里选择，因此需要给子递归传`i+1`。这一点和 77题.组合 类似



**递归三部曲**

由于和上一题高度类似，此处不详细写，流程参照上一题。注意点已经写在了注释中

```Java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        // 改动1：先进行排序，使得重复的数字相邻，方便去重
        Arrays.sort(candidates); 
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            if (sum + candidates[i] > target) break;
            // 改动2：加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
            // 注意数组越界问题，i是从begin开始的，begin每次递归都在变，所以要保证i-1>=begin，而不是i-1>=0
            // 自己第一次写的时候，写成了i-1>begin，忽略了等于的情况，事实上等于也是可以的，自己理一下就行
            if (i-1>=begin && candidates[i - 1] == candidates[i]) continue;
            sum += candidates[i];
            path.addLast(candidates[i]);
            // 改动3：每个数字只能选用1次，1个元素选完只能从剩下的元素里选择，因此需要给子递归传`i+1`
            bfs(candidates, target, res, path, sum, i+1);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```











下面是此类型的实际应用题，其递归的for循环往往有自己的实际length，然后从0开始遍历，其中需要一个索引唯一指针 begin

### 17. 电话号码的字母组合

和上面的回溯思路基本相同，难点在于字符串的一些列处理，比如使用StringBuilder，将数字组成的字符串，对应到字符组成的字符串   [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-%E5%9B%BE%E8%A7%A3.png)

> 图源：[「手画图解」两种解法：DFS回溯、BFS。我理解的回溯 - 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/shou-hua-tu-jie-liang-chong-jie-fa-dfshui-su-bfsya/)

```Java
class Solution {
    List<String> res = new LinkedList<>();  // 结果集
    StringBuilder temp = new StringBuilder(); //每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuildr

    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return res;
        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backTracking(digits, numString, 0); //迭代处理
        return res;
    }

    public void backTracking(String digits, String[] numString, int begin){
        if(begin == digits.length()){
            res.add(temp.toString());
            return;
        }
        // 将digits的“23” 转为 numString中对应的字符串，注意 '2' 转为 整型2 只需要 '2'-'0' 即可
        String str = numString[digits.charAt(begin) - '0'];

        for(int i=0; i<str.length(); i++){
            temp.append(str.charAt(i)); // 添加元素
            backTracking(digits,numString,begin+1);  // 递归
            temp.deleteCharAt(temp.length() - 1); // 删除元素
        }
    }
}
```

用93的Deque<String>改写看看，不用StringBuilder，addLast或者removeLast即可，不知道可不可行



### 93. 复原IP地址

前面的题目判断回溯的条件相对来说比较简单，即数目达标或者和达标，这道题的返回条件比较复杂，或者说返回情况比较多，再加上字符串的处理，整体难度不小。基本的回溯思路还是相同的  [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/93%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-%E5%9B%BE%E8%A7%A31.png)

**回溯三要素**

尝试用回溯三要素思路线分析：

* 回溯要素一：选择

上图是本题回溯的基本思路，第一步可以选 "2" 作为第一个片段，选 "25" 作为第一个片段，选 "255" 作为第一个片段，能切三种不同的长度，切第二个片段时，又面临三种选择。这会向下分支，形成一棵树，我们用 DFS 去遍历所有选择，必要时提前回溯。

* 回溯要素二：约束条件

1. 一个片段的长度是 1~3
2. 片段的值范围是 0~255
3. 不能是 "0x"、"0xx" 形式，即长度大于1时，必须首位不为0

用这些约束进行充分地剪枝，去掉一些选择，避免搜索「不会产生正确答案」的分支

* 回溯要素三：目标

本题回溯的目标是生成 4 个有效片段，并且要耗尽 IP 的字符。

目标决定了什么时候**捕获答案**，什么时候砍掉死支，当目标满足时，说明生成了一个有效组合，加入解集，结束当前递归，继续探索别的分支。如果满4个有效片段，但没耗尽字符，不是想要的解，不继续往下递归，提前回溯。因此分析目标的时候也能推出约束条件：

4. 满4段，未耗尽所有字符



下图是一个有效的组合的样子。start 指针越界，代表耗尽了所有字符，且满 4 个片段。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/93%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80-%E5%9B%BE%E8%A7%A3.png)

> 图源：[『手画图解』DFS回溯中的细节 | 93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/)



**回溯递归三部曲**

* 递归函数的返回值以及参数：返回值为空，传入题目的String，再传入两个参数，并将两个结果集设为全局变量

    ```Java
    // start是字符串s的遍历指针，num用来记录当前ip段的数量
    public void backTracking(String s, int begin, int num){}
    ```

* 回溯函数终止条件：目标达成，片段满4段，耗尽所有字符

    ```Java
    // 目标：片段满4段，耗尽所有字符
    if(num ==4 && begin == s.length()){
        res.add(String.join(".", temp));           // 字符串拼接内置方法，否则会很麻烦
        return;
    }
    ```

* 单层搜索的过程：搭配诸多约束条件

    ```java
    for(int len=1; len<=3; len++){              // 约束条件1：枚举出选择，三种切割长度
        if(begin+len-1 >= s.length()) return;   // Java语法约束：加上切的长度就数组越界，不能切
        if(len>1 && s.charAt(begin)=='0') return;  // 约束条件3：长度大于1时，必须首位不为0，
        String str = s.substring(begin, begin + len);  // 当前选择切出的片段
        // 约束条件2：片段的值范围是 0~255
        if(Integer.parseInt(str)<0 || Integer.parseInt(str)>255) return; 
        temp.addLast(str);
        num++;
        backTracking(s,begin+len,num);     // 从len长度后开始下一次递归，此前没见过
        num--;
        temp.removeLast();
    }
    ```



整体代码：

```Java
class Solution {
    List<String> res = new LinkedList<>();
    Deque<String> temp = new LinkedList<>();
    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12 || s.length() < 4) return res; // 初始判断
        backTracking(s,0,0);
        return res;
    }

    // start是字符串s的遍历指针，num用来记录当前ip段的数量
    public void backTracking(String s, int begin, int num){
        // 目标：片段满4段，耗尽所有字符
        if(num ==4 && begin == s.length()){
            res.add(String.join(".", temp));       // 字符串拼接内置方法，否则会很麻烦
            return;
        }
        if(num ==4 && begin < s.length()) return; // 约束条件4：满4段，未耗尽所有字符，直接返回

        for(int len=1; len<=3; len++){            // 约束条件1：枚举出选择，三种切割长度
            if(begin+len-1 >= s.length()) return; // 语法约束：加上切的长度就数组越界，不能切
            if(len>1 && s.charAt(begin)=='0') return;  // 约束条件3：长度大于1时必须首位不为0
            String str = s.substring(begin, begin + len);  // 当前选择切出的片段
            // 约束条件2：片段的值范围是 0~255
            if(Integer.parseInt(str)<0 || Integer.parseInt(str)>255) return; 
            temp.addLast(str);
            num++;
            backTracking(s,begin+len,num);   // 从len长度后开始下一次递归，此前没见过
            num--;
            temp.removeLast();
        }
    }
}
```

其中，关于字符串有如下想法：

* 从解题的角度想，`Deque<String>`比StringBuilder方便，addLast或者removeLast即可，StringBuilder删减还得注意下标
* `String.join()`用于拼接很方便
* `Integer.parseInt()`转为整型很方便，如果不允许用，则可以用下面的代码进行转换，并进行判断

```Java
private boolean judgeIpSegment(String s, int left, int right) {
    int len = right - left + 1;
    if (len > 1 && s.charAt(left) == '0') {
        return false;
    }

    int res = 0;
    while (left <= right) {
        res = res * 10 + s.charAt(left) - '0';
        left++;
    }

    return res >= 0 && res <= 255;
}
```





### 22. 括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。[22. 括号生成 ](https://leetcode-cn.com/problems/generate-parentheses/)

输入：n = 3  输出：["((()))","(()())","(())()","()(())","()()()"]

**回溯三要素**

* 回溯要素一：选择

    在这里，每次最多两个选择，选左括号或右括号，“选择”会展开出一棵解的空间树

* 回溯要素二：约束条件

    什么情况下可以选左括号，什么情况下可以选右括号？

    只要`(`有剩，就可以选`(`，当剩下的`)`比`(`多（相等不行）时，才可以选`)`，否则，`)`不能选，选了就非法。因为剩下的`)`比`(`少，即，使用的`)`比`(`多，不能成双成对。

* 回溯要素三：目标

    构建出一个用尽 n 对括号的合法括号串。意味着，当构建的长度达到 2*n，就可以结束递归（不用继续选了）。

```Java
class Solution {
    List<String> res = new LinkedList<>();
    StringBuilder path = new StringBuilder();
    public List<String> generateParenthesis(int n) {
        backTracking(n,n,n);
        return res;
    }

    // leftRemain：左括号剩下的个数   rightRemain：右括号剩下的个数
    public void backTracking(int n, int leftRemain, int rightRemain){
        // 目标
        if(path.length() == 2*n){
            res.add(path.toString());
            return;
        }
        // 左括号有剩的，就可以选左括号
        if(leftRemain > 0) {
            path.append("(");
            backTracking(n, leftRemain-1, rightRemain);
            path.deleteCharAt(path.length() - 1);
        }
        // 右括号剩的大于左括号剩的，才可以选右括号
        if(rightRemain > leftRemain) {
            path.append(")");
            backTracking(n, leftRemain, rightRemain-1);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```





### 46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。[46. 全排列](https://leetcode-cn.com/problems/permutations/)

示例 1：输入：nums = [1,2,3]   输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]



解法就是按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。这样的思路，可以用一个树形结构表示。

![46全排列-图解](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/46%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%BE%E8%A7%A3.png)

> 图源：[「代码随想录」带你学透回溯算法！46. 全排列](https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/)



**回溯递归三部曲**

- 递归函数参数

    由于全排列每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。所以它和前面子集、组合类问题最大的不同就是：for循环里不用添加begin这个开始索引了。

    但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示，细节放在后面聊。将辅助的集合和数组都定义为全局变量：

    ```Java
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    
    public void backTracking(int[] nums){}
    ```

- 递归终止条件

    从图解里可以看出叶子节点，就是收割结果的地方。那么什么时候，算是到达叶子节点呢？

    当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

    ```Java
    if(path.size() == nums.length){
        res.add(new LinkedList<>(path));
        return;
    }
    ```

- 单层搜索的逻辑

    前面提过全排列每次都要从头开始搜索，所以它和前面子集、组合类问题最大的不同就是：for循环里不用添加begin这个开始索引了。但排列问题需要一个used数组，标记已经选择的元素，记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。

    ![微信截图_20200514183911.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/46%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%BE%E8%A7%A31)

    > 图源：[「手画图解」怎么写出回溯算法 | 46.全排列问题](https://leetcode-cn.com/problems/permutations/solution/chou-xiang-cheng-jue-ce-shu-yi-ge-pai-lie-jiu-xian/)

    如上图所示，第一个取1的树枝里，是如何保证后续的数据不再取1的？在第一层的for循环里，i=0的时候，取了1，然后进递归，第二层的for循环也是从0开始，还是遍历3次，但当 i=0 想添加1时，有一个辅助数组判定，这个1已经用过了，不要再用了，因此到 i=1，即添加2.

    即这是在每个树枝上对使用过的元素进行判定（在下一题会涉及到树层上）

    ```Java
    for(int i=0; i<nums.length; i++){
        if(used[i] == true) continue;  // 如果元素使用过，跳过这一轮循环
    
        used[i] = true;
        path.addLast(nums[i]);
        backTracking(nums);
        path.removeLast();
        used[i] = false;
    }
    ```



完整的代码为：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];  // 自己写的时候还写成了boolean[] used = ...，离谱
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=0; i<nums.length; i++){
            if(used[i] == true) continue;  // 如果元素使用过，跳过这一轮循环
            
            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



大家此时可以感受出排列问题的不同：

- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了



### 47. 全排列 II

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。  示例 ：输入：nums = [1,1,2]  输出：[[1,1,2], [1,2,1], [2,1,1]]     [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

和46的区别在与**给定一个可包含重复数字的序列**，要返回**所有不重复的全排列**。这里又涉及到去重了。

之前也讲过类似的题型，注意**去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

这里的去重一共有两个地方：

* 和上一题一样的，在每个树枝上确保前面被选过的元素不要被再选，如下图的红色圆圈路径

    ```Java
    if (used[i] == true) continue;
    ```

* 本题特殊的，集合重复元素不再重选，确保树层上相同的元素不要被再选。如何确保？用如下的代码

    ```Java
    if(i-1>=0 && nums[i] == nums[i-1] && used[i-1] == false) continue;
    ```

判定当前的nums[i] == nums[i-1] 很好理解，元素重复。为什么是used[i-1] == false ? 

nums[i] == nums[i-1] 会遇到两种情况：

（1）used[i-1] == false，比如第二个树枝里的红色三角形，这是在选第二个1，和第一个1相同，但第一个1没被上层选过（上层只选过一个2），那按照递归的顺序，他肯定被递归过了，所以本次的1（即第二个1）就不能再选，属于树层上的重复，需要舍弃

（2）used[i-1] == true，如下图中的绿色圆，比如第一个树枝，选第二个1的时候，和第一个1相同，但是第一个1在上一层被选过了（上层选的就是第1个1），那按照上一句代码里的逻辑，它会被跳过，即第一个1没机会被递归，那就得让第2个1被递归

所以这个used[i-1] == false到底是什么？答案是判定当前这个重复元素的前一个元素（nums[i-1]），在上层有没有被选过。

如果被选过，那前一个元素（nums[i-1]）按照第一个判定条件，没机会递归，所以让当前元素（nums[i]）递归，

如果没被选过，那前一个元素（nums[i-1]）按照第一个判定条件，已经递归过了，当前元素（nums[i]）舍弃

![微信截图_20200514183911.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/47%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1-%E5%9B%BE%E8%A7%A3.png)



整体代码如下：

```Java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    Deque<Integer> path = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];  // 默认都是false
        Arrays.sort(nums);  // 排序
        backTracking(nums);
        return res;
    }

    public void backTracking(int[] nums){
        if(path.size() == nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        for(int i=0; i<nums.length; i++){   
            //如果同⼀树⽀nums[i]使⽤过则跳过
            if (used[i] == true) continue;
            // nums[i-1] == nums[i]说明是重复元素
            // used[i - 1] 等于 false 说明 nums[i-1]在上层被选过，已经递归过了，nums[i]就不用递归了，舍弃
            if(i-1>=0 && nums[i] == nums[i-1] && used[i-1] == false) continue;

            used[i] = true;
            path.addLast(nums[i]);
            backTracking(nums);
            path.removeLast();
            used[i] = false;
        }
    }
}
```



### 79. 单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

基本思想和前面的差不多，但由于题型场景特殊，代码能不能写出来不好说。。注意点都写在下面了，结合图解看懂应该是不难，自己写就费劲了

以"SEE"为例，首先要选起点：遍历矩阵，找到起点S。起点可能不止一个，基于其中一个S，看看能否找出剩下的"EE"路径。下一个字符E有四个可选点：当前点的上、下、左、右。逐个尝试每一种选择。基于当前选择，为下一个字符选点，又有四种选择。每到一个点做的事情是一样的。DFS 往下选点，构建路径。当发现某个选择不对，不用继续选下去了，结束当前递归，考察别的选择。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E5%9B%BE%E8%A7%A3.png)

约束条件：

1. 当前的点，越出矩阵边界。
2. 当前的点，之前访问过，不满足「同一个单元格内的字母不允许被重复使用」。
3. 当前的点，不是目标点，比如你想找 E，却来到了 D。

![image.png](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E5%9B%BE%E8%A7%A31.png)

> 图源：[「手画图解」回溯思路的形成与细节 | 79.单词搜索](https://leetcode-cn.com/problems/word-search/solution/shou-hua-tu-jie-79-dan-ci-sou-suo-dfs-si-lu-de-cha/)

```Java
class Solution {
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        boolean[][] used = new boolean[m][n];
        // 遍历每个格子，每个格子都可能是起点
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(backTracking(board,i,j,0,word,used)) return true;
            }
        }
        return false;
    }

    // backTracking()的作用：当前点[row,col]能否为剩下的字符找到路径，能就继续递归，不能就结束递归，直到最后递归终止才回到for循环
    // row：当前遍历的行位置 col：当前遍历的列位置 i：当前遍历到的word位置
    // 即记录两个位置，一个是网格内的字母位置，一个是word里的字母位置
    public boolean backTracking(char[][] board, int row, int col, int i, String word, boolean[][] used){
        // 目标：全部字符匹配
        // 注意这里必须是i == word.length()才能全部匹配完，如果是 i == word.length()-1，那么最后一个字符还没有判定
        // 并且这里只是递归终止条件，这个结束是在主函数里进行下一个for循环，其并不能作为当前字符匹配成功的条件，这个在下面
        if(i == word.length()) return true;
        // 约束1：当前节点不在网格内，越界
        if(row<0 || row >= board.length || col <0 || col>=board[0].length) return false;
        // 约束2：重复访问
        if(used[row][col] == true) return false;
        // 约束3：字符不匹配
        if(board[row][col] != word.charAt(i)) return false;

        // 当前字符匹配 做访问标记
        used[row][col] = true;
        // 当前点[row,col]往四个方向尝试匹配下一个字符
        boolean canFindRest = 
            backTracking(board, row - 1, col, i + 1, word, used) ||
            backTracking(board, row + 1, col, i + 1, word, used) ||
            backTracking(board, row, col - 1, i + 1, word, used) ||
            backTracking(board, row, col + 1, i + 1, word, used);
        // 当前点[row,col]可以为剩下的字符找到路径，继续递归
        if (canFindRest == true) return true; 
        // 先回溯修改当前不能访问的点 但是接下来的方向可以访问它，然后再返回false
        used[row][col] = false;
        // 当前点[row,col]不可以为剩下的字符找到路径
        return false;
    }
}
```













### 51. N皇后















35：26

37：30











# 动态规划

动态规划（Dynamic programming, DP）

将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案

最优子结构：通过求子问题的最优解，可以获得原问题的最优解。

动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 dp(i)、dp(i)(j)、dp(i)(j)(k)......

动态规划做题步骤：

* 明确 dp(i) 应该表示什么；
* 根据 dp(i) 和 dp(i-1) 或者其他变量的关系得出状态转移方程；
* 确定初始条件，如 dp(0)等。







## 剑指offer10. 斐波那契数列

我们从斐波那契数列问题引入，写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

（以下解答忽略题目中的取模1000000007）

该问题不难用递归解决，即我们认为已经知道了 f(n-1) 和 f(n-2) 的答案，如何求 f(n)。



**方法一：递归（暴力搜索）**

```Java
class Solution {
    // 超时
    public int fib(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        return (fib(n-1)+fib(n-2));
    }
}
```

递归的时间复杂度为指数次方，完全不符合要求。究其原因，其递归树中包含特别多的重复计算，如下图所示：

![Snipaste_2022-04-20_22-37-29](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/%E5%89%91%E6%8C%8710%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97-%E5%9B%BE%E8%A7%A3.png)



**方法二：记忆化递归（记忆化搜索）**

同样是自上而下解决问题，怎样避免重复计算，答案是空间换时间的思想，我们构建一个数组，存放每次F(n)的数值，递归过程中，只有没被计算过的值才计算，计算过的值，直接索引数组即可。

**缺点：** 记忆化存储需要使用 O(N)的额外空间。

```Java
class Solution {
    public int fib(int n) {
        int[] memo = new int[n+1];
        Arrays.fill(memo,-1);  // 初始化数组时，记得不要初始化为以后可能用上的值
        return fib(n,memo);
    }

    public int fib(int n, int[] memo) {
        if(n==0) return 0;
        if(n==1) return 1;
        if(memo[n]==-1)
            memo[n] = fib(n-1,memo) + fib(n-2,memo);
        return memo[n];
    }
}
```



**方法三：动态规划**

动态规划是自下而上的解决问题，既然知道每个值是怎么得来的，那自然可以用循环，从下而上，计算出每个值是多少，这里可以像记忆化递归一样构建一个长度为n的数组，但空间复杂度为 O(N)。

由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可 

```Java
class Solution {
    public int fib(int n) {
        int a=0,b=1,sum;
        for(int i=0; i<n; i++){
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}
```



**总结**

通过上面的分析，能够看出递归问题存在着重叠的子问题，有两种解决办法：

* 记忆化递归--自顶向下的解决问题
* 动态规划-自底向上的解决问题



## 70. 爬楼梯

与上面斐波那契类似的，还有一道经典爬楼梯。

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？提示：`1 <= n <= 45`。    [70. 爬楼梯 - 力扣](https://leetcode-cn.com/problems/climbing-stairs/)

**方法一：动态规划**

```Java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        // 这里n为0的现实意义是爬0阶楼梯，只有一种可能，但比较难理解
        // 不妨理解为dp[2]=2，但是为了充分利用数组空间，让dp[0]=1
        dp[0] = 1; 
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

不过用了额外的数组，但这也是最标准的动态规划答案，其中涉及到了状态转移方程

对于此题可以用之前斐波那契数列的动态规划解法，使用三个整形变量 sum, a, b ，利用辅助变量 sum 使 a, b 两数字交替前进即可。这是「滚动数组思想」。对于for循环的起始终点，自己多举例子试试就知道了

```Java
class Solution {
    public int climbStairs(int n) {
        if(n==1) return 1;
        int a=1,b=2,sum;
        for(int i=1; i<n; i++){
            sum = a+b;
            a = b;
            b = sum;
        } 
        return a;
    }
}
```

上述的时间复杂度均为O(n)

由于现在的内卷，面试官有时候也要会O(logn)的解法，这里用到了几种数学方法--矩阵快速幂、特征方程，暂时略过，摆烂



## 53. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个**连续**部分。[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

有最优要求，而且题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用「动态规划」解决。

1. 定义状态

`dp[i]`：表示以 `nums[i]` **结尾** 的 **连续** 子数组的最大和。

2. 状态转移方程

本题的重点在于 `nums[i]` 一定会被选取，以 `nums[i]` 结尾的连续子数组与以 `nums[i - 1]` 结尾的连续子数组只相差一个元素 `nums[i]` 。不难得出：dp[i] = Math.max(nums[i], dp[i-1]+nums[i]); 

3. 初始化

dp[0]为nums[0]

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int res = nums[0];
        for(int i=1; i<nums.length; i++){
            dp[i] = Math.max(nums[i], dp[i-1]+nums[i]);
            // 或者先来个条件判断
            // if(dp[i-1]>0) dp[i] = dp[i-1]+nums[i];
            // else dp[i] = nums[i];
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

4. 空间优化

使用「滚动变量」的方式将代码进行优化。用一个变量pre保存dp[i-1]的值

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        int pre = nums[0]; 
        int res = nums[0];
        for(int i=1; i<nums.length; i++){
            pre = Math.max(nums[i], pre+nums[i]);
            res = Math.max(res, pre);
        }
        return res;
    }
}
```

**时间复杂度**：O(N)，这里 N 是输入数组的长度。



扩展问题：打印最大和的连续子数组

未使用滚动数组优化版本的打印：

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        int[] dp = new int[nums.length];  // 记录nums[i]结尾的最大和
        dp[0] = nums[0];
        int res = nums[0];                // 记录整体最大和
        int maxStart = 0, maxLen = 1;     // 记录最大连续子序列的起点和长度
        int start =0, len = 1;            // 记录连续子序列的起点和长度

        for(int i=1; i<nums.length; i++){
            // 由于要判断是继续当前序列，还是另起新序列，所以必须要分情况讨论
            if(dp[i-1]>0){  // 继续当前序列
                dp[i] = dp[i-1] + nums[i];
                len++;      // 更新长度
            } else{         // 另起新序列
                dp[i] = nums[i];
                start = i;  // 更新起点
                len = 1;    // 更新长度
            }
            
            if(dp[i]>res){  // 更新最大和时，也要更新对应的起点和长度
                maxStart = start;
                maxLen = len;
                res = dp[i];
            }
        }
        System.out.println(maxLen);  //打印最大和子序列的长度
        System.out.println(Arrays.toString(Arrays.copyOfRange(nums, maxStart, maxStart+maxLen)));                  //打印最大和子序列
        return res;
    }
}
```

空间优化版本的打印，此处省略，照着上面优化参考就行





## 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

我们不难分析出这道题具有重叠子问题和最优子结构的情况。所以可以使用动态规划的方法来解决。

假设有10间房屋，现在我正在对第5间进行决策，那么我的决策思路就是判断 **偷前三家+第五家赚,还是偷前四家更赚**，总结为一句话就是，**是否选择偷当前房屋取决于： 是偷当前房屋收益高，还是偷前一家房屋收益高?**

动态规划算法分析

* 1、确定dp数组以及下标的含义
    * dp[i] 表示前 i 间房屋能偷窃到的最高总金额，**说明**：i = 0代表只有一个房间

* 2、确定递推公式

    * 当来到第i间房的时候，只有两种选择：

        * 偷窃第 i 间房屋，那么就不能偷窃第 i−1 间房屋（这个时候你不能想第i-1怎么办，我们只分析第i间房），偷窃总金额为前 i−2 间房屋的最高总金额与第 i 间房屋的金额之和即：dp[i]=dp[i-2]+nums[i]

        * 不偷窃第 i 间房屋，偷窃总金额为前 i−1 间房屋的最高总金额即：dp[i] = dp[i-1]

    * 因为题目要最大值所以直接取两者最大值即：dp[i]=max(dp[i−2]+nums[i] , dp[i−1])，

* 3、dp数组初始化
    * 如果 i = 0 则只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额即，dp[i] = nums[0];
    * 如果 i = 1 则只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额即，dp[1] = max(nums[0], nums[1]);

* 4、确定遍历顺序
    * 通过递归公式发现 dp[i] 是由 前 i - 1 或者 i - 2 个状态推出来的所以遍历顺序是从前往后遍历。
* 5、返回值
    * 返回dp[i]的最大值当然是把所有房间都遍历一遍的最后一个是最大值即，dp[nums.size()-1];

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1) return nums[0];
        // dp[i] 表示前 i 间房屋能偷窃到的最高总金额
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);
        for(int i=2; i<nums.length; i++){
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i]);
        }
        return dp[nums.length-1];
    }
}
```

优化，因为dp[i]只跟dp[i−1]、dp[i−2]有关，所以也是可以只保留这两个数，不用dp数组

```Java
class Solution {
    public int rob(int[] nums) {
        if(nums.length == 1) return nums[0];
        // cur用于记录dp[i]，pre用于记录dp[i-1]，temp用于记录dp[i-2]
        // 自己写写画画就知道了
        int pre =0, cur=0, temp;
        for(int i=0; i<nums.length; i++){
            temp = pre; 
            pre = cur;
            cur = Math.max(pre, temp + nums[i]);
        }
        return cur;
    }
}
```





## 343. 整数拆分

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。返回 *你可以获得的最大乘积* 。`2 <= n <= 58` [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)



**方法一：暴力搜索**

n=10，它可以拆分为1和9，我们可以对9进行递归，又可以拆分为2和8，对8进行递归……

对于数字 n，可以拆分为 i 和 n-i，i 的范围从 1 到 n-1。

遍历所有的 i，对于 n-i，它**可以选择拆分或不拆分**（不拆分也是一种情况！！！），如果拆分就递归。

![343](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/Leetcode/343%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-%E5%9B%BE%E8%A7%A3.png)

因此可以写出如下代码：

```Java
// 暴力解法
public int integerBreak(int n) {
    if (n == 2) return 1;
    int res = -1;
	//for循环起始终止条件，自己举例子画画图
    for (int i = 1; i <= n - 1; i++) {
        // 这里需要注意的是，拆分和不拆分都是情况之一，拆分就是三部分起步了，不拆分就是两部分
        // 结果需要保存
        res = Math.max(res, Math.max(i * (n - i), i * integerBreak1(n - i)));
    }
    return res;
}
```

由图中所示，此方法存在大量重复递归，因此肯定超时，不满足要求。



**方法二：记忆化搜索**

根据斐波那契题的思考，我们采用空间换时间的思想，用一个数组记录每次拆分的乘积最大值，如果碰到数组里的值不是初始化时的值，说明他被计算过了。不难写出下面的代码

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        return integerBreakHelper(n,dp);
    }

    public int integerBreakHelper(int n, int[] dp) {
        if(n==2) return 1;
        if(dp[n] != 0) return dp[n];
        int res = -1;
        for(int i=1; i<n; i++){
            //  n可以拆分为 i 和 n-i，n-i可以选择不拆分或继续拆分
            res = Math.max(res, Math.max(i*(n-i), i*integerBreakHelper(n-i,dp)));
        }
        dp[n] = res;
        return res;
    }
}
```

这依然是一个自顶向下的过程



**方法三：动态规划**

其实，记忆化搜索已经满足的题目的要求。但是对于这样的一个`递归`代码，我们更习惯转化为`递推`，将`自顶向下`的思路转换为`自底向上`，这也是记忆化搜索和DP之间的区别所在。

对于的正整数 n，当 n ≥ 2 时，可以拆分成至少两个正整数的和。令 i 是拆分出的第一个正整数，则剩下的部分是 n−i。第一个正整数 i 可以不继续拆分，或者继续拆分成至少两个正整数的和（一个问题可以分解为相似的子问题因此想到动态规划）假设对正整数 i 拆分出的第一个正整数是 j ，那么剩下的就是 i-j，

动态规划算法分析

* 确定dp数组以及下标的含义
    * dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积
* 确定状态转移方程
    * 当 i ≥ 2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j<i），则有以下两种方案：
        * 将 i 拆分成 j 和 i-j 的和，且 i−j <font color=red>不再拆分</font>成多个正整数，此时的乘积是 j×(i−j) ；
        * 将 i 拆分成 j 和 i−j 的和，且 i−j <font color=red>继续拆分</font>成多个正整数，此时的乘积是 j×dp[i−j] 。
        * 因此，当 j 固定时，有 dp[i]=max(j×(i−j),j×dp[i−j])。由于 j 的取值范围是 1 到 i−1 ，需要遍历所有的 j 得到dp[i]的
* 初始化状态
    * 0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。与语法初始化相同，可以不写
    * 2只有一种拆分方式，乘积为1，所以dp[2] = 1
* 遍历顺序
    * 由状态转移方程知道dp[i] 是从 j×(i−j)和j×dp[i−j] 且j 的取值范围是 1 到 i−1 ，需要遍历所有的 j 得到dp[i]所以从前往后遍历。
* 返回值
    * 最终得到dp[n]的值即为将正整数n拆分成至少两个正整数的和之后，这些正整数的最大乘积。

```Java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        return integerBreakHelper(n,dp);
    }

    public int integerBreakHelper(int n, int[] dp) {
        dp[2] = 1;
        // i肯定是要取到n的，要不然无法计算dp[n]，虽然i=n时，另一个数是0，不符合正整数了
        for(int i =3; i<=n; i++){
            // j取不到i，j=i时，i-j就为0了，不符合正整数的要求。虽然哪怕取到i也可以ac
            for(int j=1; j<i; j++){
                // 不拆就是 i-j ，拆就是 dp[i-j]
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```





## 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)



**方法一：暴力解法**

**思路**：枚举所有发生一次交易的股价差。时间复杂度：O(N^2)  此处略过



**方法二：动态规划**+贪心

dp[i] 表示前 i 天的最大利润，因为我们始终要使利润最大化，所以要记录股票的最低价格，记股票价格的最低点为minprice，这里也是贪心所在，则状态方程为：

dp [i] = max ( dp[i-1],  prices[i] - minprice )

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length ==0) return 0;
        int minPrice = prices[0];
        int[] dp = new int[prices.length];
        for(int i=1; i<prices.length; i++){
            minPrice = Math.min(minPrice, prices[i]);      // 记录股票最低点
            dp[i] = Math.max(dp[i-1], prices[i]-minPrice); // 更新最大利润
        }
        return dp[dp.length-1];
    }
}
```

空间优化，用一个变量保存最大利润

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length ==0) return 0;
        int minPrice = prices[0];
        int maxProfit = 0;
        for(int i=1; i<prices.length; i++){
            minPrice = Math.min(minPrice, prices[i]);
            maxProfit = Math.max(maxProfit, prices[i]-minPrice);
        }
        return maxProfit;
    }
}
```

时间复杂度：O(N)

这道题dp还有其他的写法，但贪心+dp反而是最好理解的



## 122. 买卖股票的最佳时机Ⅱ

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

与上一道题唯一的区别就是本题不限制买卖次数，卖完了还可以再买



方法一：贪心

最好理解的依然是贪心，遍历整个股票交易日价格列表 `price`，策略是所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）。即因为不限制交易次数，不用像上题一样维护最小值，而是做出判断，是否上涨，上涨就把利润加到总利润中（注意题目是可以一天内卖买的）

```Java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices == null || prices.length==0) return 0;
        int maxProfit=0;
        for(int i=1; i<prices.length; i++){
            if(prices[i]>prices[i-1]) 
                maxProfit = maxProfit + prices[i] - prices[i-1];
        }
        return maxProfit;
    }
}
```





## 122. 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)



**方法一：动态规划**

这题就得用真正的dp了，刷第二轮的时候注意写一下







## 300. 最长递增（上升）子序列  LIS

给你一个整数数组 nums ，找到其中最长严格递增子序列（longest-increasing-subsequence）的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

输入：nums = [10,9,2,5,3,7,101,18]  输出：4  解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。



**方法一：暴力解法**

使用「回溯搜索算法」或者「位运算」的技巧，可以得到输入数组的所有子序列，时间复杂度为 O(2^N)。再对这些子串再依次判定是否为「严格上升」，时间复杂度 为O(N)，所以总的时间复杂度为：O(N⋅2^N )。

> 如果题目只问最优解，而没有问具体解，可以考虑使用动态规划，而不应该使用回溯算法（暴力搜索）搜索所有具体解。



**方法二：动态规划**

首先考虑题目问什么，就尝试把什么定义成状态。题目问最长上升子序列的长度，其实可以把「子序列的长度」定义成状态，但是发现「状态转移」不好做。可以将状态定义为「以 `nums[i]` 结尾 的「上升子序列」的长度」。

1. 定义状态：

dp[i] 表示：以 nums[i] 结尾 的「上升子序列」的长度（不一定是最长！！！）。注意：**这个定义中 nums[i] 必须被选取**，且必须是这个子序列的最后一个元素；

2. 状态转移方程：

如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。只要 nums[i] 严格大于在它位置之前的某个数nums[j]（可以用第二轮循环遍历），那么 nums[i] 就可以接在这个数后面形成一个更长的上升子序列，而且只可能是这个数结尾的上升子序列长度+1。

所以 dp[i] = max( dp[i] , dp[j] + 1)

3. 初始化：

`dp[i] = 1`，每个字符都是长度为1，显然是长度为 1 的上升子序列。

4. 输出：

不能返回最后一个状态值，最后一个状态值只表示以 nums[len - 1] 结尾的「上升子序列」的长度，不一定是整个数组的LIS

5. 空间优化：

遍历到一个新数的时候，之前所有的状态值都得保留，因此无法优化空间。



清楚这个流程后，可以写写画画一个简单的用例，大概理解思路，再写代码

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        // dp[i]表示以nums[i]结尾的上升子序列的长度，不一定是最长！！！
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        int res = 1;
        // 第一轮循环遍历数组每个元素
        for(int i=0; i<nums.length; i++){
            // 第二轮循环遍历当前元素与之前元素的大小关系，符合条件考虑更新dp[i]
            for(int j = 0; j<i; j++){
                if(nums[j] < nums[i])
                    dp[i] = Math.max(dp[i], 1+dp[j]);
            }
            // 更新res，让其始终为最大的dp[i]
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

复杂度分析：

时间复杂度：O(N^2)，这里 N 是数组的长度，我们写了两个 for 循环，每个 for 循环的时间复杂度都是线性的；

空间复杂度：O(N)，要使用和输入数组长度相等的状态数组，因此空间复杂度是 O(N)。



**方法三：修改状态定义（同时用到了贪心策略、二分查找）**

方法二一个很显著的缺点就是第二轮循环时要让当前元素跟在它之前每个数都进行比较。最好能不要这样，让当前元素尽可能的少比较。

我们可以分析出：已经得到的上升子序列的结尾的数**越小**，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列。即同样是长度为2的子序列，[2,3] 就比 [2,5] 好。因为[2,3]后面如果有4的话，组成[2,3,4]长度就是3了，但是[2,5]因为不满足条件，就没法组队了。

因此我们组成子序列的时候，不仅要让这个序列尽可能的长，而且要让子序列中的**上升的时候尽可能的缓慢**，[2,3]就比[2,5]上升的缓慢，这样就有机会能拼接出更长的上升子序列，这就是我们的贪心策略。

因此，我们需要用一个数组来保存 **所有** 上升子序列结尾的最小值，注意，这跟题目中的LCS完全不是一回事

1. 定义新状态（特别重要）

`tail[i]` 表示： **所有**长度为 `i + 1` 的上升子序列结尾的最小值。下标和长度有数值为 `1` 的偏差；

比如，示例 `[10, 9, 2, 5, 3, 7, 18, 4, 4]`，**所有**长度为 1 的上升子序列中，结尾最小的元素是2，因此`tail[0] = 2`，长度为 2 的**所有**上升子序列中，结尾最小的是子序列 `[2, 3]` ，因此 `tail[1] = 3`；

2. 状态转移方程：

既然是上升，那这个数组是严格递增的。因为是严格递增的，数组中最后一个值`tail[max]`就是最大值。遍历到新的元素时，有两种情况：

* 新元素比 tail[max] 大，那么很明显，这个数组的长度就要+1，并且将新元素添加到数组的末尾。
    * 比如： 原来是 [10, 9, 2] ，长度为1的LCS结尾最小的值变化为10 -> 9 -> 2，所以2遍历完时，tail[0] = 2，现在遍历到 5 时，5 比 2 大了，那么tail数组就得+1，并且这个新元素加进来，tail数组现在为 [ 2 , 5]
* 新元素比 tail[max] 小，那么显然新元素更适合作为上升子序列的结尾，因此我们需要看之前所有长度的上升子序列，<font color=red>找到第一个结尾比新元素大的上升子序列，将其替换为新元素。</font>说白了就是在tail数组中，寻找第一个比新元素大的数字，然后替换掉它，这里使用二分法。这里是最难理解的！！！多举一些例子
    * 比如上一个说明中，5之后遍历到3，3没有5大，显然3比5更适合作为结尾，现在所有长度为1的上升子序列中，结尾最小的元素是2，2不比新元素大，pass；所有长度为2的上升子序列中，结尾最小的元素是5，5比3大了，所以将5改为3，即现在所有长度为2的上升子序列中，结尾最小的元素是3，tail = [2 , 3]
    *  将这个示例遍历完：下一个新元素是7，7比3大，所以tail长度+1，tail此时为 [2, 3, 7]；下一个新元素是18，tail更新为[2, 3, 7, 18]。
    * 下一个新元素是 4，4比18小了，显然4比18更适合作为结尾，现在所有长度为1的上升子序列中，结尾最小的元素是2，2不比新元素大，pass；所有长度为2的上升子序列中，结尾最小的元素是3，3不比新元素大，pass；所有长度为3的上升子序列中，结尾最小的元素是7，7比4大了，所以将7改为4，即现在所有长度为3的上升子序列中，结尾最小的元素是4，tail = [2 , 3 , 4]。所有长度为4的上升子序列中，结尾最小的元素是依然是18，元素4并不会影响长度为4的上升子序列，tail = [2 , 3 , 4, 18]。<font color=red>这里再次强调，`tail[i]` 表示： **所有**长度为 `i + 1` 的上升子序列结尾的最小值，tail数组本身并不是原数组里的上升子序列</font>
* 新元素和 tail[max] 相等，由于题目要求严格上升，什么都不做，因为以新元素结尾的最短的「上升子序列」已经存在；
    * 比如下一个新元素还是4，4在原数组中能够成新的严格上升子序列嘛，并不能，所以它没啥影响

3. 初始化：

遍历第 1 个数 nums[0]，直接放在有序数组 tail 的开头 tail[0] = nums[0]。

4. 输出：

有序数组 tail 的长度，就是所求的「最长上升子序列」的长度。

5. 空间优化：

无法优化空间。

```Java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        // tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几
        int[] tail = new int[nums.length];
        tail[0] = nums[0];  // 初始化，nums[0]直接放在有序数组tail的开头
        int end = 0;        // end表示有序数组tail的最后一个已经赋值元素的索引
        for(int i=0; i<nums.length; i++){
            // 情况1：新元素比tail数组末尾元素大
            if(nums[i] > tail[end]){
                end++;
                tail[end] = nums[i];
            // 情况2：新元素比tail数组末尾元素小，二分法
            } else if(nums[i] < tail[end]){
                int left = 0, right = end;
                while(left<right){
                    int mid = left+(right-left)/2;
                    if(tail[mid]<nums[i]) left = mid + 1;
                    else right = mid;
                }
                tail[left] = nums[i];  // 二分结束之后，left就是要更新的地方
            // 情况3：新元素和tail数组末尾元素相等，pass
            } else{
                continue;
            }
        }
        // 此时 end 是有序数组 tail 最后一个元素的索引，题目要求返回的是长度，因此 +1 后返回
        end++;
        return end;
    }
}
```



**扩展问题，打印所有的最长LCS**



## 1143. 最长公共子序列  LCS

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列（longest-common-subsequence）的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

**方法一：动态规划**

求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[ 0:i ] 中想要求的结果；当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i] [j] ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果。

1. 状态定义

比如对于本题而言，可以定义 dp[i] [j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。 （注：text1[0:i-1] 表示的是 text1 的 第 0 个元素到第 i - 1 个元素，两端都包含）之所以 dp[i] [j] 的定义不是 text1[0:i] 和 text2[0:j] ，是为了方便当 i = 0 或者 j = 0 的时候，dp[i] [j]表示的为空字符串和另外一个字符串的匹配，这样 dp[i] [j] 可以初始化为 0.

2. 状态转移方程

知道状态定义之后，我们开始写状态转移方程。

* 当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i] [j] = dp[i - 1] [j - 1] + 1；
    * 举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度，结果为0 + 1 = 1。
* 当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dp[i] [j] 应该是 dp[i - 1] [j] 和 dp[i] [j - 1] 的最大值。
    * 举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1。

综上状态转移方程为：

当 text1[i - 1] == text2[j - 1]，dp[i] [j] = dp[i - 1] [j - 1] + 1
当 text1[i - 1] != text2[j - 1]， dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])

3. 状态的初始化

初始化就是要看当 i = 0 与 j = 0 时， dp[i] [j] 应该取值为多少。

当 i = 0 时，dp[0] [j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0.
当 j = 0 时，dp[i] [0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
综上，当 i = 0 或者 j = 0 时，dp[i] [j] 初始化为 0.

4. 遍历方向与范围

由于 dp[i] [j] 依赖与 dp[i - 1] [j - 1] , dp[i - 1] [j], dp[i] [j - 1]，所以 ii 和 jj 的遍历顺序肯定是从小到大的。
另外，由于当 i 和 j 取值为 0 的时候，dp[i] [j] = 0，而 dp 数组本身初始化就是为 0，所以，直接让 i 和 j 从 1 开始遍历。遍历的结束应该是字符串的长度为 len(text1) 和 len(text2)。

5. 最终返回结果

由于 dp[i] [j] 的含义是 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列。我们最终希望求的是 text1 和 text2 的最长公共子序列。所以需要返回的结果是 i = len(text1) 并且 j = len(text2) 时的 dp[len(text1)] [len(text2)]。

```Java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int M = text1.length();
        int N = text2.length();
        // dp[i] [j] 表示 text1[0:i-1] 和 text2[0:j-1] 的最长公共子序列
        // 两个维度容量+1，方便i,j从1开始遍历，dp[0][j]和dp[i][0]默认都为0，不用初始化
        int[][] dp = new int[M+1][N+1];
        for(int i=1; i<=M; i++){
            for(int j=1; j<=N; j++){
                if(text1.charAt(i-1) == text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[M][N];
    }
}
```



**扩展问题：打印LCS**







## xxx.背包问题

考题频率貌似不是很高，除了322 518，第一轮暂时不看，



## 322. 零钱兑换



## 518. 零钱兑换Ⅱ





































































# 贪心算法

贪心算法更多考察平时对贪心策略的积累，其区分度不大，能想出贪心策略就会，否则就不会，不像其他算法有很多优化的空间，因此在面试时比较少见，笔试里占的篇幅也不大，可能5题里有1题，所以平常可以稍微多练习下贪心策略，多看点题目。整个校招的过程不应该将此作为核心重点。 

贪心算法的在笔试时的解题套路：

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明（笔试压根没这个时间，而且也太难了，全是数学证明）





# 大数据题目







# 模式匹配







