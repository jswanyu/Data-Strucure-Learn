# 插入排序

## 一、概念及其介绍
插入排序(InsertionSort)，一般也被称为直接插入排序。

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。



## 二、适用说明

|   算法   | 最好时间 | 最坏时间 | 平均时间 | 额外空间 | 稳定性 |
| :------: | :------: | :------: | :------: | :------: | :----: |
| 插入排序 |  O(n）   |  O(n^2)  |  O(n^2)  |   O(1)   |  稳定  |

**优点**就是数据有序的情况下，可以提前终止部分内层循环，只在有需要时才对数组进行排序

**缺点**就是所有比插入元素大的元素都必须移动

最优的情况是当待排序数组是有序时，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 **N-1** 次，时间复杂度为 **O(N)**。这具有非常重要的意义，因为**日常有时候的数据就是近乎有序的**

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 **O(n^2)**。

对于随机顺序的数组来说，移动和比较的次数与最坏情况接近，也就是说当数组大小加倍时，一般都需要付出4倍的努力来排序。



## 三、过程图示

[![5TLf5F.gif](https://z3.ax1x.com/2021/10/27/5TLf5F.gif)](https://imgtu.com/i/5TLf5F)



## 四、实例代码

```java
public class InsertionSort {
    public static <E extends Comparable<E>> void sort(E[] arr){
        for (int i = 0; i < arr.length; i++) {
            E t = arr[i];  //复制一份外层循环当前轮次的元素
            int j;         //变量j保存元素e应该所在的位置，单独初始化是因为for循环后面还要用到
            // 务必注意是当前轮次的值arr[i]即t与arr[j-1]比较，而不是arr[j]，并且j-1是可以=0d
            for (j = i; j-1 >=0 && t.compareTo(arr[j-1])<0; j--)
                arr[j] = arr[j-1]; //比前一个元素大，那就让前一个元素后移，不用让arr[j]与arr[j-1]一直交换
            arr[j] = t;    //此时j就是合适的位置，将开始的arr[i]赋给它
        }
    }
}
```



## 五、改进

优化一：减少插入次数

改进的代码已经写在第四部分，插入排序的最初版本代码如下，其每次判定成功就swap()，相当于插了多次。在动图中即表现为红色的临时值一直在插入，再取出来，再插入。而上面的代码则是对其的小优化，减少交换次数，判定当前元素比前一个元素大，那就让前一个元素后移，不用让arr[j]与arr[j-1]一直交换，等到找到合适的插入位置，只插一次

```java
public class InsertionSort {    
	public static <E extends Comparable<E>> void sort2(E[] arr){
        for (int i = 0; i < arr.length; i++) {
            for (int j = i; j-1 >= 0 && arr[j].compareTo(arr[j-1])<0; j--)
                swap(arr,j,j-1);
        }
    }
}
```



### 二分查找法改进

用到再说
