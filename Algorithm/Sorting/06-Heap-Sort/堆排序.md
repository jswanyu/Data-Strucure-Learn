# 堆排序

## 一、概念及其介绍

二叉堆是一个完全二叉树，并且堆中某个节点的值总是不大于其父节点的值，这是最大堆（相应的也可以定义最小堆）

例如下图就是一个最大堆，每个节点总是小于等于其父节点值。这样堆中的最大值显然就是其根节点

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png" alt="image-20220322161718734" style="zoom: 50%;" />

如果用数组存储最大堆，可以得出以下关系 ，不过此时数组第0位是空的

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%86.png" alt="image-20220322162016360" style="zoom: 50%;" />

如果从第0位开始记录，左右子节点和父节点的公式要做出相应修改

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E6%9C%80%E5%A4%A7%E5%A0%861.png" alt="image-20220322162236689" style="zoom: 50%;" />

每次添加新元素时，一开始放到数组最后，即树中的右下节点，此时需要一个向上浮动的过程，将其按照最大堆的原则放置到合适的位置。这个动作称之为`siftUp`

![6239d10f78a8e](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%85%83%E7%B4%A0.gif)

每次取最大元素只需要把根节点取出，随后将最后一个元素放到根节点处，再将该元素不断与子节点比较，直至放置到合适的位置，这个动作称之为`siftDown`

![6239d512d647f](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E5%A0%86-%E5%8F%96%E5%87%BA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.gif)

根据二叉堆的性质以及添加元素、取出最大元素，我们不难根据其进行堆排序，将数组data中的元素一个个放到二叉堆中，随后每次再取出最大元素，即可进行堆排序。



repalce操作：取出堆中的最大元素，并且替换成元素e。

方法：把e放在根节点，而不是像之前siftDown将最后一个元素放在根节点，再将e下沉到合适的位置即可



Heapify操作：将任意数组整理成二叉堆的形状

方法：一种是将数组一个个的添加到二叉堆中，时间复杂度为O(nlogn)

另一种是先将数组按照初始顺序看成一棵二叉树，再从下往上，将一个个**非叶子节点**下沉，因为叶子节点并不用下沉，非叶子节点不断下沉的时候，会将叶子节点放到合适的位置。一棵完全二叉树的叶子节点为n/2，所以这种方法可以省去一定时间，此方法的时间复杂度为O(n)。推导需要严谨的数学公式，暂时不做要求

如何找到第一个非叶子节点？是最后一个叶子节点的父亲节点

这个操作就是现在堆排序的核心算法。





## 二、算法性能

|  算法  | 最好时间 | 最坏时间 | 平均时间 | 额外空间 | 稳定性 |
| :----: | :------: | :------: | :------: | :------: | :----: |
| 堆排序 |  O(n）   |  O(n^2)  |  O(n^2)  |   O(1)   |  稳定  |





## 三、过程图示









## 四、实例代码

```c++

```







## 五、改进

### 改进一：
