题型有点多，自己整理下经典题型的思路

参考来源：

* 数据结构与算法 左程云 
* 代码随想录、labuladong、ACWing等。。
* 力扣题解

先整理左程云的视频（除非个别题解很差，注意一定要到力扣上证明成功再记录） -->  对比代码随想录  -->  看各个题解 ，记录并练习最优题解



[TOC]







# 二叉树

二叉树的定义与力扣保持一致，要能写得出来

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历。大部分二叉树的题目最终都是归结到遍历操作上，因此针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。

### 1.1 深度优先遍历（DFS）

#### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示。节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。



前序遍历： 每个节点都按照“**中**--左--右”（中在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做。例子顺序是 1 2 4 5 3 6 7

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode node, List<Integer> list){
        if(node == null) return;

        list.add(node.val);  // 处理元素
        preorderRecur(node.left,list);
        preorderRecur(node.right,list);
    }
}
```





中序遍历：每个节点都按照“左--**中**--右”（中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做。例子顺序是 4 2 5 1 6 3 7 

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inorder(root,res);
        return res;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if(node == null) return;

        inorder(node.left,res);
        res.add(node.val);  // 处理元素
        inorder(node.right,res);
    }
}
```



后序遍历：每个节点都按照“左--右--**中**”（中在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做。例子顺序是 4 5 2  6 7 3 1

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if(root == null) return;

        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```



#### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

**在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。**

**一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。**



前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (! stack.isEmpty()){
            root = stack.pop();
            res.add(root.val); // 处理元素
            if (root.right != null) stack.push(root.right);
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```



后序遍历

后序遍历的本质还是前序遍历，前序遍历是头左右，后序遍历是左右头，只需要调整一下前序遍历的顺序，设为头右左，再翻转一下res数组，就可以得到左右头。因为栈先入后出，所以应该先压左再压右。

观察下面的代码，与前序的差别就在于压栈顺序和翻转数组

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            root = stack.pop(); 
            res.add(root.val); // 处理元素
            if (root.left != null) stack.push(root.left);
            if (root.right != null) stack.push(root.right);
        }
        Collections.reverse(res); // 翻转数组
        return res;
    }
}
```





中序遍历

中序遍历和前序遍历不能通用，前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**而中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); // 弹出栈顶元素
                res.add(root.val);  // 处理元素
                root = root.right;  // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
        return res;
    }
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />



#### Morris遍历

Morris遍历是一种遍历二叉树的方式，并且时间复杂度O(N)，**空间复杂度O(1)**，它通过利用原树中大量空闲指针的方式，达到**节省空间**的目的

这种方法的意义在于**面试时聊天**二叉树题目的优化，因为二叉树很多题目都和遍历紧密结合，前面递归方法是使用系统栈、迭代方法自己压栈，都使用了额外的空间，即二叉树的高度。而Morris遍历方法空间复杂度是O(1)，显然是一种优化。但由于其代码量更大，**思路也比较难，不适合在笔试时使用**（说白了就是难写出来）

遍历过程：

假设来到当前节点cur，开始时cur来到头节点位置，

* 如果cur没有左孩子，cur向右移动
* 如果cur有左孩子，找到左子树上最右的节点mostRight：
    * 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动 
    * 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动（说明rightMost.right曾经被修改过，我们这是第二次来到这个点，重新修改其为null，**说明该节点的左子树全部访问完毕**，所以此时**cur向右走**。）
* cur为空时遍历停止

（cur是真正有效的移动指针，它会走过所有的节点，rightMost是为了修改指针而存在的）

```Java
public static void morrisIn(Node head) {
    if (head == null) return;
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {          // cur为空时遍历停止
        
        // 如果cur有左子树
        if (mostRight != null) {
            mostRight = cur.left;      // 先找cur左子树         
            // 找左子树的最右节点mostRight，因为我们后续人为地将mostRight指向了空或者cur，所以此处要判断
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            
            // 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue; // while循环进入下一次
            } 
            
            // 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动，在第29行
            else {
                mostRight.right = null;
            }
        }
        
        // 如果cur没有左子树，cur向右移动
        cur = cur.right; 		
    }
    System.out.println();
}
```

其实不难发现，在这种遍历方式中，有些节点会访问两次，有些节点会访问一次。**因为我们有两个指针cur和rightMost，cur会走过所有的节点，rightMost会修改节点指向，使得cur重新访问到某个父节点。** 更具体的可以见这篇博客[Mirrors遍历]([(22条消息) 树（一）——Morris 二叉树神级遍历_yindarui的博客-CSDN博客_mirrors遍历](https://blog.csdn.net/qq_38684427/article/details/107708469))







### 1.2 广度优先遍历（BFS）

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，**与深度优先遍历非递归使用栈不同，宽度优先遍历主要使用队列来解决问题**。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点）（队列是先进先出，所以先左再右），没有子节点就不放
* 循环

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

因为此题要用两层列表输出，所以加个for循环弹出当前层的元素个数，这是层序遍历需要对每层操作的经典方式

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            LinkedList<Integer> level = new LinkedList<>();
            // for循环弹出当前层的元素个数
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();  // 规范起见，这里不要用root=queue.poll()；
                level.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

也有很多力扣题目BFS是可以作为解法的（但不一定是最优解），例如：[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)、[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

层序遍历也有DFS方式，后面研究下

```Java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```







## 2. 二叉树的属性

### 2.1 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

解决此类递归问题，需要将目光聚焦于任意一个节点x为根的树，它的最大深度为什么。

针对此题能够得出：任意一个节点x为根的树其最大深度为左子树和右子树的最大深度 +1

```Java
class solution {
    public int maxdepth(treenode root) {
        if (root == null) return 0;
        int leftdepth = maxdepth(root.left);
        int rightdepth = maxdepth(root.right);
        return Math.max(leftdepth, rightdepth) + 1;
    }
}
// 或者简化为：
return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
```

或者也可以使用层序遍历，每一层记录高度+1，此处略。同样的逻辑也可以处理一下[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)



### 2.2 二叉树的最小深度

针对此题能够得出：任意一个节点x为根的树其最小深度需要具体讨论，所有的情况都如下

* 如果其左右子树都为空，最小深度就是其自身，也就是1
* 如果其左子树为空，那么就是右子树的最小深度 +1
* 如果其右子树为空， 那么就是左子树的最小深度 +1
* 如果其左右子树都不为空，那就是左右子树的最小深度 +1

这样直接写出来的代码为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null && root.right== null) return 1;
        if(root.left == null) return rightDepth + 1;
        if(root.right == null) return leftDepth + 1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

但显然前三种条件可以统一简化为：左右子树任一个子树为空。前三种的结果也可以统一化简为一个公式，即 leftDepth + rightDepth +1; 

因为第一种情况，左右子树最小深度就是0，公式结果为1；第二种情况，左子树深度为0，公式结果为 rightDepth + 1;  第三种情况，右子树深度为0，公示结果为 leftDepth + 1。 

因此代码可以化简为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null || root.right== null) return leftDepth + rightDepth +1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

虽然还可以用三元表达式进一步化简，但意义不大，可读性较差.

同样的，此题也可以用层序遍历，在for循环外加上depth计数，for循环里加上判断，如果弹出的节点是叶子节点，直接返回depth即可，此时就是最小深度



### 2.3 二叉树的最大宽度

[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        // 在构造队列对象时，注意父类接口只能大不能小，比如层序遍历队列用单向队列即可，但辅助队列
        // 需要用双端队列Deque或者链表LinkedList作为父类接口
        Queue<TreeNode> queue = new LinkedList<>();    // 层序遍历的队列
        LinkedList<Integer> list = new LinkedList<>(); // 辅助队列/数组
        queue.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值

        while(!queue.isEmpty()){
            
        // 设立循环，循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标
        // 比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，
        // 辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了
            int count = queue.size();
            for(int i=count; i>0; i--){ 

                // 记录弹出的元素，和弹出元素的下标（弹出元素的下标用于添加下一层元素的下标）
                TreeNode cur = queue.poll();
                int curIndex = list.removeFirst();

                // 层序遍历添加元素，同时也注意根据弹出元素的下标向辅助队列里添加左右子节点的下标
                if(cur.left != null){
                    queue.offer(cur.left);
                    list.offer(curIndex * 2);
                }
                if(cur.right != null){
                    queue.offer(cur.right);
                    list.add(curIndex * 2 +1);
                }
            }

            if(list.size() >= 2){
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        // while循环结束，队列为空，res为最大宽度
        return res;
    }
}
```



### 2.4 验证对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

首先写写画画梳理正确的逻辑，才能写出正确的递归。此题显然是自顶向下的递归，对称，就是左右两边相等，也就是左子树和右子树相等。将每个节点的左子树记做 left，右子树记做 right。首先要比较 left 和 right 的值是否相等，不等的话直接返回false。相等的话继续比较外侧是否对称，即 left 的左子树 和 right 的右子树是否相等， 还要比较内侧是否对称，即 left 的右子树 和 right 的左子树是否相等， 都不出问题，才是对称。什么情况下出问题呢？分别是：两个节点中只有一个为空，肯定不对称；两个节点的值不相等，也肯定不对称。递归到什么程度就对称了，递归到左右节点都没有子节点了，即两个节点都为空了。

基于以上的逻辑再写递归，不要上来就按照三部曲写递归，逻辑都不清楚，写什么递归。

递归三部曲

1.确定递归函数的参数和返回值

​	因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。返回值自然是bool类型。

```Java
public boolean compare(TreeNode left, TreeNode right){}
```

2.确定递归终止条件

一定要先判断节点为空的情况，再判断数值是否相等，否则会出现空指针问题（这在二叉树里尤为重要）

- 左子树为空，右子树为空，对称，return true
- 左右子树只有一个为空，不对称，return false
- 左右子树根节点的值不相等，不对称，return false

同时也要注意，判断时可以写 if 或者 else if，但不能写else，因为还有情况是左右子树都不为空且左右子树根节点值相等的情况，但这种情况显然可能并没有递归到底，所以并不能作为终止条件

```Java
if (left == null && right == null) return true;
if(left == null || right == null) return false;
if (left.val != right.val)  return false;
```

3.确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右子树都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

整体代码如下：

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        //调用递归函数，比较左节点，右节点
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode left, TreeNode right){
        //递归的终止条件是两个节点都为空
        //或者两个节点中有一个为空
        //或者两个节点的值不相等
        if (left == null && right == null) return true;
        if(left == null || right == null) return false;
        if (left.val != right.val)  return false;
        // 比较外侧，即左节点的左孩子 和 右节点的右孩子
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧，即左节点的右孩子 和 右节点的左孩子
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
}
```

此题使用递归方法，自然也可以使用非递归方法，还是那个道理，递归是系统压入栈，我们自然可以自己实现栈（队列也可以），将需要比较的节点放入栈或队列，弹出后比较，弹出时再放入子节点，详见提交记录里的其它解法。



### 2.5 验证平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

左程云介绍的递归套路，可以解决二叉树的树型DP问题，即可以通过从左右子树获取信息的方式来解决的问题

以本题为例，首先分析二叉树里，以任意一个节点x为根的树，需要什么样的条件，才能是平衡二叉树：

* 左子树是平衡二叉树
* 右子树是平衡二叉树
* | 左子树高度-右子树高度 | < 2

只有同时满足上述三个条件，x为根的树才能是平衡二叉树。那么现在x为根的树需要子树提供什么样的信息呢：

* 左子树提供是否是平衡二叉树、以及左子树的高度
* 右子树提供是否是平衡二叉树、以及右子树的高度

因为是递归，左右子树需要统一信息，即子树提供两个信息：子树提供是否是平衡二叉树、子树的高度，编写代码时将其作为单独的类封装起来，供递归调用

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 封装子树需要提供的信息
    public static class ReturnType {   
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

    public static ReturnType process(TreeNode x) {
        if(x == null) return new ReturnType(true,0); // 递归的base

        // 左右子树递归
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);

        // 递归所需信息的处理
		int height = Math.max(leftData.height, rightData.height) + 1; // 左右子树的最大高度加1
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;

        // 返回递归所需信息
        return new ReturnType(isBalanced, height);

    }
}
```

此思想的简化代码版本，来自力扣题解。核心思想是一致的，即构造一个获取当前节点最大深度的方法`depth(root)`，通过比较此子树的左右子树的最大高度差来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。

简单来说，就是将上面封装类中的isBalanced写为递归函数。

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

这个代码思想是自顶向下的递归，更优解是自底向上的递归，后续再整理

这道题后面也可以整理一下，还是聚焦于判断，一个根节点为x的二叉树，满足什么条件才是平衡二叉树，就和二叉树的最大深度、最小深度一样。想清除这个自顶向下的递归逻辑，就容易写出来，感觉左程云的套路还是稍微复杂了一点，虽然思想是一样的





## 3. 二叉树的修改与改造

### 3.1 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转二叉树非常简单，不用想的太复杂，其实就是把每个节点的左右子节点交换而已，那么如何访问到每个节点自然是关键之处，还是使用各种遍历方法。前序、后序、层序都很简单。中序遍历会把某些节点的左右孩子翻转了两次，虽然可以通过代码避免，不建议使用（动笔写写画画就知道了）

前序递归遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

层序遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                swap(cur);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
        }
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```



## 4. 二叉搜索树的属性

### 4.1 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
		LinkedList<Long> inOrderList = new LinkedList<>();
		process(root, inOrderList);
        long pre = Long.MIN_VALUE;
        for(long cur: inOrderList){
            if(pre >= cur) return false;
            pre = cur;
        }
        return true;
    }

    public static void process(TreeNode node, LinkedList<Long> inOrderList) {
        if (node == null) {
            return;
        }

        process(node.left, inOrderList);
        inOrderList.add((long)node.val); // 操作元素，注意转换
        process(node.right, inOrderList);
	}
}
```



解法二：在递归过程中，判断是否升序（**最佳**）

中序递归遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。其实也就是把中序遍历的打印操作换成一个判断操作

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        // 递归左子树
        if(!isValidBST(root.left)) return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if(root.val <= pre) return false;
        pre = root.val;
        
        // 递归右子树
        return isValidBST(root.right);
    }
}
```



解法三：在非递归过程中，判断是否升序

和解法二类似，都是在过程中判断是否升序，只不过换成了非递归的中序

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); 
               
                // 非递归遍历中加入的判断
                if(root.val <= pre) return false;
                else pre = root.val;

                root = root.right; 
            }
        }
        return true;
    }
}
```



解法四：左程云的二叉树递归套路（暂时跳过）

```Java

```









# 回溯

回溯算法是一种遍历算法，以 **深度优先遍历** 的方式尝试所有的可能性。有些教程上也叫**暴力搜索**。回溯算法是 **有方向地** 搜索，区别于多层循环实现的暴力法。

回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确的答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案。

由于回溯和深度优先搜索有着千丝万缕的联系，因此也介绍下深度优先搜索

深度优先搜索 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 尽可能深 的搜索树的分支。当结点 v 的所在边都己被探寻过，搜索将 回溯 到发现结点 v 的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。

回溯算法与深度优先遍历都有不撞南墙不回头的意思。我个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 不断变化 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。而深度优先遍历强调一种遍历的思想，不回退，与之对应的遍历思想是广度优先遍历。至于广度优先遍历为什么没有成为强大的搜索算法，后面会提。

搜索问题的解，可以通过 **遍历** 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。



一些精彩的描述：（整理差不多了之后，自己总结下）

回溯：在包含问题所有解的空间树中，用DFS的方式，从根节点出发，搜索整棵解空间树。

搜索至任何一个节点时，总是会先判断当前节点是否可以通往最后的合法解。如果不可以，则结束对「以当前节点为根节点的子树」的搜索，向父节点回溯，回到之前的状态，搜索下一个分支。否则，进入该子树，继续以DFS的方式搜索。

空间树中的节点是动态的，即，当前有哪些选项可选择，是根据上一步的选择得出的，所以做回溯时，要把状态还原成进入当前节点之前的状态。

确定出问题的解空间树，它是隐式的，不是显式的一棵树。不熟练的就画图看看。

然后，明确每个节点的扩展搜索规则。然后进行DFS搜索，并注意剪枝，避免无效的搜索。



回溯的三个要素：选择（选项）、约束、目标。

我们关心当下有什么选择，作了一个选择之后，会怎么限制下一个选择。所以，不仅要关注选择（选项），还要关注约束条件。前者展开出一棵解的空间树，后者用来剪枝，剪去不能产生正确解的分支，避免无效搜索。第三个要素：目标（结束条件），明确了目标，就知道何时去将解加入解集。并且让你知道：搜索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。





## 组合

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合      [77. 组合](https://leetcode-cn.com/problems/combinations/)

**回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了**

![image-20220407101907621](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E5%A4%9A%E5%8F%89%E6%A0%91.png)

> 图源：[回溯算法 + 剪枝](https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/)



叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 path，它是一个列表，特别地，path 是一个栈；

每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start ，表示在区间 [begin, n] 里选出若干个数的组合；

### 1. 回溯递归三部曲：

* 递归函数的返回值以及参数：返回值为空，题目要求的两个参数传入，并将两个结果集（一个最终结果，一个临时结果）作为参数传入，或者设为全局变量

    ```Java
    public void dfs(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path)
    ```

* 回溯函数终止条件：path这个数组的大小如果达到k，就到达叶子节点了

    ```Java
    if(path.size()==k){  
        ......  
        return;
    }
    ```

* 单层搜索的过程

    ```java
    for (int i = begin; i <= n; i++) {
        path.addLast(i);   // 处理节点
        dfs(n, k, i + 1, path, res); // 递归：bfs
        path.removeLast(); // 回溯，撤销处理的节点
    }
    ```



整体代码如下

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的最终集合
        Deque<Integer> path = new LinkedList<>();     // 存放符合条件结果的临时集合，队列或数组都可以
        if(k<=0 || k>n) return res;
        dfs(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void dfs(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            dfs(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```

### 2. 辅助解题

在解题时候可以在回溯周围加入打印信息，给一个测试用例，观察递归写的是否正确，这点非常重要！！自己写递归经常容易出问题

```Java
public class Combinations {
    public List<List<Integer>> combine(int n, int k) {
		......
    }

    private void dfs(int n, int k, int begin, Deque<Integer> path, List<List<Integer>> res) {
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = begin; i <= n; i++) {
            path.addLast(i);
            System.out.println("递归之前 => " + path);
            dfs(n, k, i + 1, path, res);
            path.removeLast();
            System.out.println("递归之后 => " + path);
        }
    }

    public static void main(String[] args) {
        Combinations solution = new Combinations();
        int n = 5;
        int k = 3;
        List<List<Integer>> res = solution.combine(n, k);
        System.out.println(res);
    }
}
```

> 递归之前 => [1]
> 递归之前 => [1, 2]
> 递归之前 => [1, 2, 3]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 4]
> 递归之后 => [1, 2]
> 递归之前 => [1, 2, 5]
> 递归之后 => [1, 2]
> 递归之后 => [1]
>
> ......

### 3. 剪枝优化

上面的题解中，可以进行优化。分析搜索起点的上界进行剪枝处理。

分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 `path` 的长度相关。我们举几个例子分析：

例如：`n = 6 ，k = 4`。

path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 44，最后一个被选的组合是 [4, 5, 6]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 55，最后一个被选的组合是 [5, 6]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 66，最后一个被选的组合是 [6]；

再如：n = 15 ，k = 4。
path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 1313，最后一个被选的是 [13, 14, 15]；
path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 1414，最后一个被选的是 [14, 15]；
path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 1515，最后一个被选的是 [15]；

可以归纳出：

**搜索起点的上界 + 接下来要选择的元素个数 - 1 = n**

得到搜索起点的上界 = n - (k - path.size()) + 1，所以，我们的剪枝过程就是：把 `i <= n` 改成 `i <= n - (k - path.size()) + 1` ：

```Java
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new LinkedList<>(); // 存放符合条件结果的集合
        Deque<Integer> path = new LinkedList<>();     // 用来存放符合条件结果
        if(k<=0 || k>n) return res;
        dfs(n,k,1,res,path); // 回溯递归，从 1 开始是题目的设定
        return res;
    }

    public void dfs(int n, int k, int begin, List<List<Integer>> res, Deque<Integer> path){
        if(path.size()==k){  // 递归终止条件是：path 的长度等于 k
            res.add(new LinkedList<>(path));  // 不要忘记把此刻的path添加到res中，不能直接add(path)
            return;
        }

        for(int i = begin; i <= n - (k - path.size()) + 1; i++){  // 遍历可能的搜索起点
            path.addLast(i);  // 向路径变量里添加一个数
            dfs(n,k,i+1,res,path); // 下一轮搜索设置的搜索起点要加 1，因为组合数理不允许出现重复的元素
            path.removeLast();  // 递归之前做了什么，递归之后需要做相同操作的逆向操作
        }
    }
}
```



很多剪枝优化想出来其实不容易，只能多做题练习了





## 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

示例 1： 输入：candidates = [2,3,6,7], target = 7, 所求解集为： [ [7], [2,2,3] ]

示例 2： 输入：candidates = [2,3,5], target = 8, 所求解集为： [  [2,2,2,2],  [2,3,3],  [3,5] ]

这道题和上一道题的差别在于：

- 组合总和的元素个数没有数量要求
- 元素可无限重复选取

![image-20220411102216417](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E5%9B%BE%E8%A7%A3.png)

>  （图源：[「手画图解」怎么分析回溯问题？](https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/)）

注意图中叶子节点的返回条件，因为本题没有组合数量要求，仅仅是总和的限制，所以递归没有层数的限制，只要选取的元素总和超过target，就返回！

还是熟悉的递归方式

### 1. 回溯递归三部曲

- 递归函数参数

首先是题目中给出的参数，集合candidates, 和目标值target，以及两个结果集

此外还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，我依然用了sum。

**本题还需要begin来控制for循环的起始位置，对于组合问题，什么时候需要begin呢？**

我举过例子，如果是**一个集合来求组合的话，就需要begin**，例如：[77.组合](https://programmercarl.com/0077.组合.html)，[216.组合总和III ](https://programmercarl.com/0216.组合总和III.html)。

如果是**多个集合取组合，各个集合之间相互不影响，那么就不用begin**，例如：[17.电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)

注意以上只是说**求组合的情况**，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍

```Java
public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin)
```

- 递归终止条件

终止只有两种情况，sum大于target和sum等于target。sum等于target的时候，需要收集结果

```Java
if (sum > target) {
    return;
}

if(sum == target){
    res.add(new LinkedList<>(path));
    return;
}
```

- 单层搜索的逻辑

单层for循环依然是从startIndex开始，搜索candidates集合。注意本题和上一题的差别在于，本题元素为可重复选取的

```Java
for(int i=begin; i< candidates.length; i++){
    sum += candidates[i];
    path.addLast(candidates[i]);
    bfs(candidates, target, res, path, sum, i); // 本题元素为可重复选取的，所以下一个begin还是i
    sum -= candidates[i];  // 回溯
    path.removeLast();     // 回溯
}
```

所以整体代码为：

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, Deque<Integer> path, int sum, int begin){
        if (sum > target) {
            return;
        }
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i); 
            sum -= candidates[i];  // 回溯
            path.removeLast();     // 回溯
        }
    }
}
```

递归的for循环也可以写为：

```Java
for(int i=begin; i< candidates.length; i++){
    path.addLast(candidates[i]);
    // 这种其实就是永远在形参里传递sum，没进递归终止条件才更新sum，所以不用像上面显式更新num后面也不用回溯，但不利于理解，上面的写法更好理解一点
    bfs(candidates, target, res, path, sum+candidates[i], i);
    path.removeLast();
}
```





### 2. 辅助解题

同样的，在递归前后加上打印信息，此处略



### 3. 剪枝优化

在基本的递归写完后，可以进行进一步的优化。

对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。那么可以在for循环的搜索范围上做做文章了。

**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历**。

注意，这是组合问题，可以这样操作，如果是排序就另说了

```Java
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        Arrays.sort(candidates); // 先进行排序
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            // 如果 sum + candidates[i] > target 就终止此次递归，回退到上一轮递归
            if (sum + candidates[i] > target) break;
            sum += candidates[i];
            path.addLast(candidates[i]);
            bfs(candidates, target, res, path, sum, i);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```





## 组合总和Ⅱ

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。**注意：**解集不能包含重复的组合。  [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]

示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]

这道题目和上一题有如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，而上一题是无重复元素的数组candidates

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。即难点在于去重，**所谓去重，其实就是使用过的元素不能重复选取。** 

以candidates = [2,5,2,1,2], target = 5 为例， 所求解集为: [  [1,2,2],  [5] ]

![image-20220411101837423](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1%E5%9B%BE%E8%A7%A3.png)

>  图源：[手画图解 | 长文漫谈回溯 | 40. 组合总和 II ](https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/)

如果是把所有组合求出来，再用set或者map去重，这么做很容易超时！所以要在搜索的过程中就去掉重复组合。如上图所示，选取1后，剩下的三个2只用选第一个即可，其他的2选取了也没意义，属于同一个树层的重复选取，相比于上一题只需改动三点：

* 先排序，使得重复的数字相邻，方便去重。（上一题是 作为剪枝优化方法）
* for循环加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
* 当前选择的数字不能和下一个选择的数字重复，给子递归传`i+1`，避免与当前选的`i`重复。



### 1. 递归三部曲

由于和上一题高度类似，此处不详细写，流程参照上一题。注意点已经写在了注释中

```Java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new LinkedList<>();
        Deque<Integer> path = new LinkedList<>();
        // 改动1：先进行排序
        Arrays.sort(candidates); 
        bfs(candidates, target, res, path, 0, 0);
        return res;
    }

    public void bfs(int[] candidates, int target, List<List<Integer>> res, 
                    Deque<Integer> path, int sum, int begin){
        if(sum == target){
            res.add(new LinkedList<>(path));
            return;
        }

        for(int i=begin; i< candidates.length; i++){
            if (sum + candidates[i] > target) break;
            // 改动2：加入一个判断，忽略掉同一层重复的选项，避免产生重复的组合。
            // 注意数组越界问题，i是从begin开始的，begin每次递归都在变，所以要保证i-1>=begin，而不是i-1>=0
            // 自己第一次写的时候，写成了i-1>begin，忽略了等于的情况，事实上等于也是可以的，自己理一下就行
            if (i-1>=begin && candidates[i - 1] == candidates[i]) continue;
            sum += candidates[i];
            path.addLast(candidates[i]);
            // 改动3：当前选择的数字不能和下一个选择的数字重复，给子递归传`i+1`，避免与当前选的`i`重复。
            bfs(candidates, target, res, path, sum, i+1);
            sum -= candidates[i];
            path.removeLast();
        }
    }
}
```





## 全排列

我们尝试在纸上写 3个数字、4 个数字、5 个数字的全排列，相信很简单。以数组 `[1, 2, 3]` 的全排列为例，123 132 213 231 312 321

解法就是按顺序枚举每一位可能出现的情况，已经选择的数字在 **当前** 要选择的数字中不能出现。按照这种策略搜索就能够做到 **不重不漏**。这样的思路，可以用一个树形结构表示。

![image-20220406223106946](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF-%E5%85%A8%E6%8E%92%E5%88%97%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png)

**说明**：

* 每一个结点表示了求解全排列问题的不同的阶段，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；
* 使用深度优先遍历有「回头」的过程，在「回头」以后， 状态变量需要设置成为和先前一样 ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；
* 深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；
* 深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。

使用编程的方法得到全排列，就是在这样的一个树形结构中完成 **遍历**，从树的根结点到叶子结点形成的路径就是其中一个全排列。



设计状态变量

* 首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；
* 递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；
* 布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。

这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。





46. 全排列































35：26

37：30









# 贪心算法

贪心算法更多考察平时对贪心策略的积累，其区分度不大，能想出贪心策略就会，否则就不会，不像其他算法有很多优化的空间，因此在面试时比较少见，笔试里占的篇幅也不大，可能5题里有1题，所以平常可以稍微多练习下贪心策略，多看点题目。整个校招的过程不应该将此作为核心重点。 

贪心算法的在笔试时的解题套路：

1. 实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2. 脑补出贪心策略A、贪心策略B、贪心策略C...
3. 用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4. 不要去纠结贪心策略的证明（笔试压根没这个时间，而且也太难了，全是数学证明）



