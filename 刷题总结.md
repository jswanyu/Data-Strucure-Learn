题型有点多，自己整理下经典题型的思路

参考来源：

* 数据结构与算法 左程云 
* 代码随想录、labuladong、ACWing等。。
* 力扣题解

先整理左程云的视频（除非个别题解很差，注意一定要到力扣上证明成功再记录） -->  对比代码随想录  -->  看各个题解 ，记录并练习最优题解



[TOC]







# 二叉树

二叉树的定义与力扣保持一致，要能写得出来

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历。大部分二叉树的题目最终都是归结到遍历操作上，因此针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。

### 1.1 深度优先遍历（DFS）

#### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示。节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。



前序遍历： 每个节点都按照“**中**--左--右”（中在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做。例子顺序是 1 2 4 5 3 6 7

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode node, List<Integer> list){
        if(node == null) return;

        list.add(node.val);  // 处理元素
        preorderRecur(node.left,list);
        preorderRecur(node.right,list);
    }
}
```





中序遍历：每个节点都按照“左--**中**--右”（中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做。例子顺序是 4 2 5 1 6 3 7 

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inorder(root,res);
        return res;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if(node == null) return;

        inorder(node.left,res);
        res.add(node.val);  // 处理元素
        inorder(node.right,res);
    }
}
```



后序遍历：每个节点都按照“左--右--**中**”（中在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做。例子顺序是 4 5 2  6 7 3 1

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if(root == null) return;

        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```



#### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。递归更容易让程序员理解，但收敛不好，容易栈溢出。这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

**在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。**

**一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。**



前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (! stack.isEmpty()){
            root = stack.pop();
            res.add(root.val); // 处理元素
            if (root.right != null) stack.push(root.right);
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```



后序遍历

后序遍历的本质还是前序遍历，前序遍历是头左右，后序遍历是左右头，只需要调整一下前序遍历的顺序，设为头右左，再翻转一下res数组，就可以得到左右头。因为栈先入后出，所以应该先压左再压右。

观察下面的代码，与前序的差别就在于压栈顺序和翻转数组

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            root = stack.pop(); 
            res.add(root.val); // 处理元素
            if (root.left != null) stack.push(root.left);
            if (root.right != null) stack.push(root.right);
        }
        Collections.reverse(res); // 翻转数组
        return res;
    }
}
```





中序遍历

中序遍历和前序遍历不能通用，前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**而中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); // 弹出栈顶元素
                res.add(root.val);  // 处理元素
                root = root.right;  // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
        return res;
    }
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />



#### Morris遍历

Morris遍历是一种遍历二叉树的方式，并且时间复杂度O(N)，**空间复杂度O(1)**，它通过利用原树中大量空闲指针的方式，达到**节省空间**的目的

这种方法的意义在于**面试时聊天**二叉树题目的优化，因为二叉树很多题目都和遍历紧密结合，前面递归方法是使用系统栈、迭代方法自己压栈，都使用了额外的空间，即二叉树的高度。而Morris遍历方法空间复杂度是O(1)，显然是一种优化。但由于其代码量更大，**思路也比较难，不适合在笔试时使用**（说白了就是难写出来）

遍历过程：

假设来到当前节点cur，开始时cur来到头节点位置，

* 如果cur没有左孩子，cur向右移动
* 如果cur有左孩子，找到左子树上最右的节点mostRight：
    * 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动 
    * 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动（说明rightMost.right曾经被修改过，我们这是第二次来到这个点，重新修改其为null，**说明该节点的左子树全部访问完毕**，所以此时**cur向右走**。）
* cur为空时遍历停止

（cur是真正有效的移动指针，它会走过所有的节点，rightMost是为了修改指针而存在的）

```Java
public static void morrisIn(Node head) {
    if (head == null) return;
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {          // cur为空时遍历停止
        
        // 如果cur有左子树
        if (mostRight != null) {
            mostRight = cur.left;      // 先找cur左子树         
            // 找左子树的最右节点mostRight，因为我们后续人为地将mostRight指向了空或者cur，所以此处要判断
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            
            // 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue; // while循环进入下一次
            } 
            
            // 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动，在第29行
            else {
                mostRight.right = null;
            }
        }
        
        // 如果cur没有左子树，cur向右移动
        cur = cur.right; 		
    }
    System.out.println();
}
```

其实不难发现，在这种遍历方式中，有些节点会访问两次，有些节点会访问一次。**因为我们有两个指针cur和rightMost，cur会走过所有的节点，rightMost会修改节点指向，使得cur重新访问到某个父节点。** 更具体的可以见这篇博客[Mirrors遍历]([(22条消息) 树（一）——Morris 二叉树神级遍历_yindarui的博客-CSDN博客_mirrors遍历](https://blog.csdn.net/qq_38684427/article/details/107708469))







### 1.2 广度优先遍历（BFS）

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，**与深度优先遍历非递归使用栈不同，宽度优先遍历主要使用队列来解决问题**。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点）（队列是先进先出，所以先左再右），没有子节点就不放
* 循环

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

因为此题要用两层列表输出，所以加个for循环弹出当前层的元素个数，这是层序遍历需要对每层操作的经典方式

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            LinkedList<Integer> level = new LinkedList<>();
            // for循环弹出当前层的元素个数
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();  // 规范起见，这里不要用root=queue.poll()；
                level.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

也有很多力扣题目BFS是可以作为解法的（但不一定是最优解），例如：[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)、[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

层序遍历也有DFS方式，后面研究下

```Java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```







## 2. 二叉树的属性

### 2.1 二叉树的最大深度

[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

解决此类递归问题，需要将目光聚焦于任意一个节点x为根的树，它的最大深度为什么。

针对此题能够得出：任意一个节点x为根的树其最大深度为左子树和右子树的最大深度 +1

```Java
class solution {
    public int maxdepth(treenode root) {
        if (root == null) return 0;
        int leftdepth = maxdepth(root.left);
        int rightdepth = maxdepth(root.right);
        return Math.max(leftdepth, rightdepth) + 1;
    }
}
// 或者简化为：
return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) +1;
```

或者也可以使用层序遍历，每一层记录高度+1，此处略。同样的逻辑也可以处理一下[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)



### 2.2 二叉树的最小深度

针对此题能够得出：任意一个节点x为根的树其最小深度需要具体讨论，所有的情况都如下

* 如果其左右子树都为空，最小深度就是其自身，也就是1
* 如果其左子树为空，那么就是右子树的最小深度 +1
* 如果其右子树为空， 那么就是左子树的最小深度 +1
* 如果其左右子树都不为空，那就是左右子树的最小深度 +1

这样直接写出来的代码为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null && root.right== null) return 1;
        if(root.left == null) return rightDepth + 1;
        if(root.right == null) return leftDepth + 1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

但显然前三种条件可以统一简化为：左右子树任一个子树为空。前三种的结果也可以统一化简为一个公式，即 leftDepth + rightDepth +1; 

因为第一种情况，左右子树最小深度就是0，公式结果为1；第二种情况，左子树深度为0，公式结果为 rightDepth + 1;  第三种情况，右子树深度为0，公示结果为 leftDepth + 1。 

因此代码可以化简为：

```Java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);

        if(root.left==null || root.right== null) return leftDepth + rightDepth +1;
        return Math.min(leftDepth, rightDepth) + 1;
    }
}
```

虽然还可以用三元表达式进一步化简，但意义不大，可读性较差.

同样的，此题也可以用层序遍历，在for循环外加上depth计数，for循环里加上判断，如果弹出的节点是叶子节点，直接返回depth即可，此时就是最小深度



### 2.3 二叉树的最大宽度

[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        // 在构造队列对象时，注意父类接口只能大不能小，比如层序遍历队列用单向队列即可，但辅助队列
        // 需要用双端队列Deque或者链表LinkedList作为父类接口
        Queue<TreeNode> queue = new LinkedList<>();    // 层序遍历的队列
        LinkedList<Integer> list = new LinkedList<>(); // 辅助队列/数组
        queue.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值

        while(!queue.isEmpty()){
            
        // 设立循环，循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标
        // 比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，
        // 辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了
            int count = queue.size();
            for(int i=count; i>0; i--){ 

                // 记录弹出的元素，和弹出元素的下标（弹出元素的下标用于添加下一层元素的下标）
                TreeNode cur = queue.poll();
                int curIndex = list.removeFirst();

                // 层序遍历添加元素，同时也注意根据弹出元素的下标向辅助队列里添加左右子节点的下标
                if(cur.left != null){
                    queue.offer(cur.left);
                    list.offer(curIndex * 2);
                }
                if(cur.right != null){
                    queue.offer(cur.right);
                    list.add(curIndex * 2 +1);
                }
            }

            if(list.size() >= 2){
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        // while循环结束，队列为空，res为最大宽度
        return res;
    }
}
```



### 2.4 验证对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

首先写写画画梳理正确的逻辑，才能写出正确的递归。此题显然是自顶向下的递归，对称，就是左右两边相等，也就是左子树和右子树相等。将每个节点的左子树记做 left，右子树记做 right。首先要比较 left 和 right 的值是否相等，不等的话直接返回false。相等的话继续比较外侧是否对称，即 left 的左子树 和 right 的右子树是否相等， 还要比较内侧是否对称，即 left 的右子树 和 right 的左子树是否相等， 都不出问题，才是对称。什么情况下出问题呢？分别是：两个节点中只有一个为空，肯定不对称；两个节点的值不相等，也肯定不对称。递归到什么程度就对称了，递归到左右节点都没有子节点了，即两个节点都为空了。

基于以上的逻辑再写递归，不要上来就按照三部曲写递归，逻辑都不清楚，写什么递归。

递归三部曲

1.确定递归函数的参数和返回值

​	因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。返回值自然是bool类型。

```Java
public boolean compare(TreeNode left, TreeNode right){}
```

2.确定递归终止条件

一定要先判断节点为空的情况，再判断数值是否相等，否则会出现空指针问题（这在二叉树里尤为重要）

- 左子树为空，右子树为空，对称，return true
- 左右子树只有一个为空，不对称，return false
- 左右子树根节点的值不相等，不对称，return false

同时也要注意，判断时可以写 if 或者 else if，但不能写else，因为还有情况是左右子树都不为空且左右子树根节点值相等的情况，但这种情况显然可能并没有递归到底，所以并不能作为终止条件

```Java
if (left == null && right == null) return true;
if(left == null || right == null) return false;
if (left.val != right.val)  return false;
```

3.确定单层递归的逻辑

此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右子树都不为空，且数值相同的情况。

- 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。
- 比较二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子。
- 如果左右都对称就返回true ，有一侧不对称就返回false 。

整体代码如下：

```Java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null) return true;
        //调用递归函数，比较左节点，右节点
        return compare(root.left, root.right);
    }

    public boolean compare(TreeNode left, TreeNode right){
        //递归的终止条件是两个节点都为空
        //或者两个节点中有一个为空
        //或者两个节点的值不相等
        if (left == null && right == null) return true;
        if(left == null || right == null) return false;
        if (left.val != right.val)  return false;
        // 比较外侧，即左节点的左孩子 和 右节点的右孩子
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧，即左节点的右孩子 和 右节点的左孩子
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
}
```

此题使用递归方法，自然也可以使用非递归方法，还是那个道理，递归是系统压入栈，我们自然可以自己实现栈（队列也可以），将需要比较的节点放入栈或队列，弹出后比较，弹出时再放入子节点，详见提交记录里的其它解法。



### 2.5 验证平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

左程云介绍的递归套路，可以解决二叉树的树型DP问题，即可以通过从左右子树获取信息的方式来解决的问题

以本题为例，首先分析二叉树里，以任意一个节点x为根的树，需要什么样的条件，才能是平衡二叉树：

* 左子树是平衡二叉树
* 右子树是平衡二叉树
* | 左子树高度-右子树高度 | < 2

只有同时满足上述三个条件，x为根的树才能是平衡二叉树。那么现在x为根的树需要子树提供什么样的信息呢：

* 左子树提供是否是平衡二叉树、以及左子树的高度
* 右子树提供是否是平衡二叉树、以及右子树的高度

因为是递归，左右子树需要统一信息，即子树提供两个信息：子树提供是否是平衡二叉树、子树的高度，编写代码时将其作为单独的类封装起来，供递归调用

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 封装子树需要提供的信息
    public static class ReturnType {   
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

    public static ReturnType process(TreeNode x) {
        if(x == null) return new ReturnType(true,0); // 递归的base

        // 左右子树递归
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);

        // 递归所需信息的处理
		int height = Math.max(leftData.height, rightData.height) + 1; // 左右子树的最大高度加1
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;

        // 返回递归所需信息
        return new ReturnType(isBalanced, height);

    }
}
```

此思想的简化代码版本，来自力扣题解。核心思想是一致的，即构造一个获取当前节点最大深度的方法`depth(root)`，通过比较此子树的左右子树的最大高度差来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。

简单来说，就是将上面封装类中的isBalanced写为递归函数。

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

这个代码思想是自顶向下的递归，更优解是自底向上的递归，后续再整理

这道题后面也可以整理一下，还是聚焦于判断，一个根节点为x的二叉树，满足什么条件才是平衡二叉树，就和二叉树的最大深度、最小深度一样。想清除这个自顶向下的递归逻辑，就容易写出来，感觉左程云的套路还是稍微复杂了一点，虽然思想是一样的





## 3. 二叉树的修改与改造

### 3.1 翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

翻转二叉树非常简单，不用想的太复杂，其实就是把每个节点的左右子节点交换而已，那么如何访问到每个节点自然是关键之处，还是使用各种遍历方法。前序、后序、层序都很简单。中序遍历会把某些节点的左右孩子翻转了两次，虽然可以通过代码避免，不建议使用（动笔写写画画就知道了）

前序递归遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

层序遍历：

```Java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                swap(cur);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
        }
        return root;
    }

    public void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```



## 4. 二叉搜索树的属性

### 4.1 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
		LinkedList<Long> inOrderList = new LinkedList<>();
		process(root, inOrderList);
        long pre = Long.MIN_VALUE;
        for(long cur: inOrderList){
            if(pre >= cur) return false;
            pre = cur;
        }
        return true;
    }

    public static void process(TreeNode node, LinkedList<Long> inOrderList) {
        if (node == null) {
            return;
        }

        process(node.left, inOrderList);
        inOrderList.add((long)node.val); // 操作元素，注意转换
        process(node.right, inOrderList);
	}
}
```



解法二：在递归过程中，判断是否升序（**最佳**）

中序递归遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。其实也就是把中序遍历的打印操作换成一个判断操作

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        // 递归左子树
        if(!isValidBST(root.left)) return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if(root.val <= pre) return false;
        pre = root.val;
        
        // 递归右子树
        return isValidBST(root.right);
    }
}
```



解法三：在非递归过程中，判断是否升序

和解法二类似，都是在过程中判断是否升序，只不过换成了非递归的中序

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); 
               
                // 非递归遍历中加入的判断
                if(root.val <= pre) return false;
                else pre = root.val;

                root = root.right; 
            }
        }
        return true;
    }
}
```



解法四：左程云的二叉树递归套路（暂时跳过）

```Java

```

