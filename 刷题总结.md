题型有点多，自己整理下经典题型的思路

参考来源：

* 数据结构与算法 左程云 
* 代码随想录、labuladong、ACWing等。。
* 力扣题解

先整理左程云的视频（除非个别题解很差，注意一定要到力扣上证明成功再记录） -->  对比代码随想录  -->  看各个题解 ，记录并练习最优题解



[TOC]







# 二叉树

二叉树的定义与力扣保持一致：

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
```

## 1. 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历

### 1.1 深度优先遍历

#### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。



前序遍历： 每个节点都按照“**头**--左--右”（头在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做

顺序是 1 2 4 5 3 6 7

```Java
public void preOrderRecur(TreeNode head){
    if (head == null) return;;

    System.out.println(head.value);
    preOrder(head.left);
    preOrder(head.right);
}
```



中序遍历：每个节点都按照“左--**头**--右”（头在中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做

顺序是 4 2 5 1 6 3 7 

```Java
public void inOrderRecur(TreeNode head){
    if (head == null) return;;

    preOrder(head.left);
    System.out.println(head.value);
    preOrder(head.right);
}
```



后序遍历：每个节点都按照“左--右--**头**”（头在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做

顺序是 4 5 2  6 7 3 1

```Java
public void posOrderRecur(TreeNode head){
    if (head == null) return;;

    preOrder(head.left);
    preOrder(head.right);
    System.out.println(head.value);
}
```



#### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。

前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

```Java
public void preOrderUnRecur(TreeNode head){
    if (head != null){
        Stack<TreeNode> stack = new Stack<>();
        stack.push(head);
        while (!stack.isEmpty()){
            head = stack.pop();
            System.out.println(head.value + " ");
            if (head.right != null)
                stack.push(head.right);
            if (head.left != null)
                stack.push(head.left);
        }
    }
}
```



后序遍历

后序遍历实现起来需要 前序遍历 + 一个收集栈

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素放到收集栈中
* 如果弹出的这个元素有子节点，**先放左节点，再放右节点**（注意这里与真正的前序不同，那是左右，所以是先放右节点，再放左节点，所以这里实际上顺序是 头右左）
* 把收集栈依次弹出，就是后序遍历（相当于就是把上一步伪前序的头右左 反过来变成 左右头，达成后序遍历）

```Java
public static void posOrderUnRecur1(TreeNode head) {
    if (head != null) {
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        s1.push(head);
        while (!s1.isEmpty()) {
            head = s1.pop();
            s2.push(head);
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s1.push(head.right);
            }
        }
        while (!s2.isEmpty()) {
            System.out.print(s2.pop().value + " ");
        }
    }
    System.out.println();
}
```

不用收集栈也可以实现



中序遍历

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

```Java
public static void inOrderUnRecur(TreeNode head) {
    if (head != null) {
        Stack<TreeNode> stack = new Stack<>();
        while (!stack.isEmpty() || head != null) {
            // 不断地将左边界进栈
            if (head != null) {
                stack.push(head);
                head = head.left;
            } else {
                head = stack.pop();  // 弹出栈顶元素
                System.out.print(head.value + " ");
                head = head.right;   // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
    }
    System.out.println();
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />





### 1.2 广度优先遍历

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，与深度优先遍历非递归使用栈不同，宽度优先遍历主要使用队列来解决问题。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点），没有子节点就不放
* 循环

```Java
public void levelOrder(TreeNode head){
    if (head == null){
        return;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(head);
    while (!queue.isEmpty()){
        Node cur = queue.poll();
        System.out.println(cur.value);
        if (cur.left != null)
            queue.offer(cur.left);
        if (cur.right != null)
            queue.offer(cur.right);
    }
}
```





## 2. 二叉树的属性

### 2.1 二叉树最大宽度

[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        // 在构造队列对象时，注意父类接口只能大不能小，比如层序遍历队列用单向队列即可，但辅助队列
        // 需要用双端队列Deque或者链表LinkedList作为父类接口
        Queue<TreeNode> queue = new LinkedList<>();    // 层序遍历的队列
        LinkedList<Integer> list = new LinkedList<>(); // 辅助队列/数组
        queue.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值

        while(!queue.isEmpty()){
            
        // 设立循环，循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标
        // 比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，
        // 辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了
            int count = queue.size();
            for(int i=count; i>0; i--){ 

                // 记录弹出的元素，和弹出元素的下标（弹出元素的下标用于添加下一层元素的下标）
                TreeNode cur = queue.poll();
                int curIndex = list.removeFirst();

                // 层序遍历添加元素，同时也注意根据弹出元素的下标向辅助队列里添加左右子节点的下标
                if(cur.left != null){
                    queue.offer(cur.left);
                    list.offer(curIndex * 2);
                }
                if(cur.right != null){
                    queue.offer(cur.right);
                    list.add(curIndex * 2 +1);
                }
            }

            if(list.size() >= 2){
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        // while循环结束，队列为空，res为最大宽度
        return res;
    }
}
```



## 3. 二叉搜索树的属性

### 3.1 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓





解法二：在递归过程中，判断是否升序







