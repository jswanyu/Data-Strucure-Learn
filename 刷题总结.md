题型有点多，自己整理下经典题型的思路

参考来源：

* 数据结构与算法 左程云 
* 代码随想录、labuladong、ACWing等。。
* 力扣题解

先整理左程云的视频（除非个别题解很差，注意一定要到力扣上证明成功再记录） -->  对比代码随想录  -->  看各个题解 ，记录并练习最优题解



[TOC]







# 二叉树

二叉树的定义与力扣保持一致，要能写得出来

```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 1. 二叉树的遍历

二叉树的遍历是非常经典的操作，其分为深度优先遍历和广度优先遍历

### 1.1 深度优先遍历（DFS）

#### 递归遍历

递归是实现遍历的经典方法，由于递归调用且每次都要判断根节点是否为空，所以每个节点都会碰到3次，如果二叉树如下图所示。节点顺序则是 1 2 4 4 4 2 5 5 5 2 1 3 6 6 6 3 7 7 7 3 1 

![image-20220326111852391](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%AE%80%E6%98%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

其代码结构模板如下：

```Java
public void f(TreeNode head){
    if (head == null) return;;

    f(head.left);
    f(head.right);
}
```

前序、中序、后序都可以由此模板加工得来。递归序有三次得到自身，每次的操作不同就得到前序、中序、后序。



前序遍历： 每个节点都按照“**中**--左--右”（中在前）的顺序来打印。如果是递归序，则是第一次碰到该节点的时候打印，二三次什么也不做。例子顺序是 1 2 4 5 3 6 7

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new LinkedList<>();
        preorder(root,list);
        return list;
    }

    public void preorder(TreeNode node, List<Integer> list){
        if(node == null) return;

        list.add(node.val);  // 处理元素
        preorderRecur(node.left,list);
        preorderRecur(node.right,list);
    }
}
```





中序遍历：每个节点都按照“左--**中**--右”（中）的顺序来打印。如果是递归序，则是第二次碰到该节点的时候打印，一三次什么也不做。例子顺序是 4 2 5 1 6 3 7 

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        inorder(root,res);
        return res;
    }

    public void inorder(TreeNode node, List<Integer> res) {
        if(node == null) return;

        inorder(node.left,res);
        res.add(node.val);  // 处理元素
        inorder(node.right,res);
    }
}
```



后序遍历：每个节点都按照“左--右--**中**”（中在后）的顺序来打印。如果是递归序，则是第三次碰到该节点的时候打印，一二次什么也不做。例子顺序是 4 5 2  6 7 3 1

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        postorder(root, res);
        return res;
    }

    public void postorder(TreeNode root, List<Integer> res) {
        if(root == null) return;

        postorder(root.left, res);
        postorder(root.right, res);
        res.add(root.val);
    }
}
```



#### 迭代遍历

迭代遍历也就是非递归实现，递归就是系统帮我们压入栈，非递归就是我们自己实现栈。

前序遍历

* 构建一个栈，把根节点压入栈中
* 只要栈不是空的，就从栈中弹出一个元素，弹出元素就打印（或者说处理）
* 如果弹出的这个元素有子节点，先放右节点，再放左节点（因为栈是先入后出，我们希望左节点先出，所以就后放）

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```Java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (! stack.isEmpty()){
            root = stack.pop();
            res.add(root.val); // 处理元素
            if (root.right != null) stack.push(root.right);
            if (root.left != null) stack.push(root.left);
        }
        return res;
    }
}
```



后序遍历

后序遍历的本质还是前序遍历，前序遍历是头左右，后序遍历是左右头，只需要调整一下前序遍历的顺序，设为头右左，再翻转一下res数组，就可以得到左右头。因为栈先入后出，所以应该先压左再压右。

观察下面的代码，与前序的差别就在于压栈顺序和翻转数组

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

```Java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) return res;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            root = stack.pop(); 
            res.add(root.val); // 处理元素
            if (root.left != null) stack.push(root.left);
            if (root.right != null) stack.push(root.right);
        }
        Collections.reverse(res); // 翻转数组
        return res;
    }
}
```





中序遍历

中序遍历和前序遍历不能通用，前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**而中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

中序遍历的逻辑是将整棵树都用左边界分解

* 将整棵树左边界进栈
* 将栈中元素依次弹出，弹出后先打印（或者操作），如果该弹出的元素有右子树，就对右子树循环此操作（即将右子树的左边界进栈，周而复始）

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```Java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); // 弹出栈顶元素
                res.add(root.val);  // 处理元素
                root = root.right;  // 对弹出元素的右子树循环此操作，继续将左边界进栈
            }
        }
        return res;
    }
}
```

此方法的底层逻辑是：任何一棵树都可以被左边界给分解掉。

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%911.png" alt="image-20220326122757858" style="zoom:67%;" />

形成    左头 右（左头右）的循环结构

<img src="https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%81%8D%E5%8E%86-%E5%B7%A6%E7%A8%8B%E4%BA%912.png" alt="image-20220326122946603" style="zoom:67%;" />



#### Morris遍历

Morris遍历是一种遍历二叉树的方式，并且时间复杂度O(N)，**空间复杂度O(1)**，它通过利用原树中大量空闲指针的方式，达到**节省空间**的目的

这种方法的意义在于面试时聊天二叉树题目的优化，因为二叉树很多题目都和遍历紧密结合，前面递归方法是使用系统栈、迭代方法自己压栈，都使用了额外的空间，即二叉树的高度。而Morris遍历方法空间复杂度是O(1)，显然是一种优化。但由于其代码量更大，思路也比较难，不适合在笔试时使用（说白了就是难写出来）

遍历过程：

假设来到当前节点cur，开始时cur来到头节点位置，

* 如果cur没有左孩子，cur向右移动
* 如果cur有左孩子，找到左子树上最右的节点mostRight：
    * 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动 
    * 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动（说明rightMost.right曾经被修改过，我们这是第二次来到这个点，重新修改其为null，**说明该节点的左子树全部访问完毕**，所以此时**cur向右走**。）
* cur为空时遍历停止

（cur是真正有效的移动指针，它会走过所有的节点，rightMost是为了修改指针而存在的）

```Java
public static void morrisIn(Node head) {
    if (head == null) return;
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {          // cur为空时遍历停止
        
        // 如果cur有左子树
        if (mostRight != null) {
            mostRight = cur.left;      // 先找cur左子树         
            // 找左子树的最右节点mostRight，因为我们后续人为地将mostRight指向了空或者cur，所以此处要判断
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            
            // 如果 mostRight 的右指针指向空，让其指向cur，然后cur向左移动
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue; // while循环进入下一次
            } 
            
            // 如果 mostRight 的右指针指向cur，让其指向null，然后cur向右移动，在第29行
            else {
                mostRight.right = null;
            }
        }
        
        // 如果cur没有左子树，cur向右移动
        cur = cur.right; 		
    }
    System.out.println();
}
```

其实不难发现，在这种遍历方式中，有些节点会访问两次，有些节点会访问一次。**因为我们有两个指针cur和rightMost，cur会走过所有的节点，rightMost会修改节点指向，使得cur重新访问到某个父节点。**

[Mirrors遍历]([(22条消息) 树（一）——Morris 二叉树神级遍历_yindarui的博客-CSDN博客_mirrors遍历](https://blog.csdn.net/qq_38684427/article/details/107708469))



### 1.2 广度优先遍历（BFS）

广度优先遍历在二叉树里有时也被称为**宽度优先遍历**或者**层序遍历**，**与深度优先遍历非递归使用栈不同，宽度优先遍历主要使用队列来解决问题**。最标准的层序遍历思路如下：

* 构建一个队列，先放入头节点
* 弹出节点，打印（或操作），先放弹出节点的左（子节点）再放右（子节点）（队列是先进先出，所以先左再右），没有子节点就不放
* 循环

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

因为此题要用两层列表输出，所以加个for循环弹出当前层的元素个数，这是层序遍历需要对每层操作的经典方式

```Java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new LinkedList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            LinkedList<Integer> level = new LinkedList<>();
            // for循环弹出当前层的元素个数
            int n = queue.size();
            for(int i=0; i<n; i++){
                TreeNode cur = queue.poll();
                level.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(level);
        }
        return res;
    }
}
```

也有很多力扣题目BFS是可以作为解法的（但不一定是最优解），例如：[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)、[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

层序遍历也有DFS方式，后面研究下

```Java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        checkFun01(root,0);

        return resList;
    }

    //DFS--递归方式
    public void checkFun01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;

        if (resList.size() < deep) {
            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定
            List<Integer> item = new ArrayList<Integer>();
            resList.add(item);
        }
        resList.get(deep - 1).add(node.val);

        checkFun01(node.left, deep);
        checkFun01(node.right, deep);
    }
}
```



## 2. 二叉树的属性

### 2.1 二叉树的最大深度





### 2.1 二叉树最大宽度

[662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

核心思想：标准层序遍历 + 辅助队列录位置信息（放置二叉树的索引下标，由于是纯数字，也可以理解为数组）

```Java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        if(root == null) return 0;
        // 在构造队列对象时，注意父类接口只能大不能小，比如层序遍历队列用单向队列即可，但辅助队列
        // 需要用双端队列Deque或者链表LinkedList作为父类接口
        Queue<TreeNode> queue = new LinkedList<>();    // 层序遍历的队列
        LinkedList<Integer> list = new LinkedList<>(); // 辅助队列/数组
        queue.offer(root);
        list.add(1); // 将根节点的下标加入辅助队列
        int res = 1; // 最大宽度值

        while(!queue.isEmpty()){
            
        // 设立循环，循环结束后，层序遍历队列里就只剩 下一层的元素，辅助队列里只剩 下一层元素坐标
        // 比如第二层有2个元素，经过2轮循环，第二层的元素都被弹出队列，第三层的元素都被添加进队列，
        // 辅助队列里也只有第三层的各元素下标，这样就可以计算第三层的宽度了
            int count = queue.size();
            for(int i=count; i>0; i--){ 

                // 记录弹出的元素，和弹出元素的下标（弹出元素的下标用于添加下一层元素的下标）
                TreeNode cur = queue.poll();
                int curIndex = list.removeFirst();

                // 层序遍历添加元素，同时也注意根据弹出元素的下标向辅助队列里添加左右子节点的下标
                if(cur.left != null){
                    queue.offer(cur.left);
                    list.offer(curIndex * 2);
                }
                if(cur.right != null){
                    queue.offer(cur.right);
                    list.add(curIndex * 2 +1);
                }
            }

            if(list.size() >= 2){
                res = Math.max(res, list.getLast() - list.getFirst() + 1); // 更新最大宽度
            }
        }
        // while循环结束，队列为空，res为最大宽度
        return res;
    }
}
```



### 2.2 验证平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

左程云介绍的递归套路，可以解决二叉树的树型DP问题，即可以通过从左右子树获取信息的方式来解决的问题

以本题为例，首先分析二叉树里，以任意一个节点x为根的树，需要什么样的条件，才能是平衡二叉树：

* 左子树是平衡二叉树
* 右子树是平衡二叉树
* | 左子树高度-右子树高度 | < 2

只有同时满足上述三个条件，x为根的树才能是平衡二叉树。那么现在x为根的树需要子树提供什么样的信息呢：

* 左子树提供是否是平衡二叉树、以及左子树的高度
* 右子树提供是否是平衡二叉树、以及右子树的高度

因为是递归，左右子树需要统一信息，即子树提供两个信息：子树提供是否是平衡二叉树、子树的高度，编写代码时将其作为单独的类封装起来，供递归调用

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return process(root).isBalanced;
    }

    // 封装子树需要提供的信息
    public static class ReturnType {   
		public boolean isBalanced;
		public int height;

		public ReturnType(boolean isB, int hei) {
			isBalanced = isB;
			height = hei;
		}
	}

    public static ReturnType process(TreeNode x) {
        if(x == null) return new ReturnType(true,0); // 递归的base

        // 左右子树递归
		ReturnType leftData = process(x.left);
		ReturnType rightData = process(x.right);

        // 递归所需信息的处理
		int height = Math.max(leftData.height, rightData.height) + 1; // 左右子树的最大高度加1
		boolean isBalanced = leftData.isBalanced && rightData.isBalanced
				&& Math.abs(leftData.height - rightData.height) < 2;

        // 返回递归所需信息
        return new ReturnType(isBalanced, height);

    }
}
```

此思想的简化代码版本，来自力扣题解。核心简化思想，将上面封装类中的isBalanced写为递归函数

```Java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

这个代码思想是自顶向下的递归，更优解是自底向上的递归，后续再整理



## 3. 二叉搜索树的属性

### 3.1 验证二叉搜索树

[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

解法一：最朴素的思想，中序遍历取出元素依次放入列表List，判断列表是否升序。至于中序遍历使用递归还是迭代无所谓

```Java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
		LinkedList<Long> inOrderList = new LinkedList<>();
		process(root, inOrderList);
        long pre = Long.MIN_VALUE;
        for(long cur: inOrderList){
            if(pre >= cur) return false;
            pre = cur;
        }
        return true;
    }

    public static void process(TreeNode node, LinkedList<Long> inOrderList) {
        if (node == null) {
            return;
        }

        process(node.left, inOrderList);
        inOrderList.add((long)node.val); // 操作元素，注意转换
        process(node.right, inOrderList);
	}
}
```



解法二：在递归过程中，判断是否升序（**最佳**）

中序递归遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false。其实也就是把中序遍历的打印操作换成一个判断操作

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        
        // 递归左子树
        if(!isValidBST(root.left)) return false;
        
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if(root.val <= pre) return false;
        pre = root.val;
        
        // 递归右子树
        return isValidBST(root.right);
    }
}
```



解法三：在非递归过程中，判断是否升序

和解法二类似，都是在过程中判断是否升序，只不过换成了非递归的中序

```Java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        while(!stack.isEmpty() || root != null){
            if(root != null){
                stack.push(root);
                root = root.left;
            } else{
                root = stack.pop(); 
               
                // 非递归遍历中加入的判断
                if(root.val <= pre) return false;
                else pre = root.val;

                root = root.right; 
            }
        }
        return true;
    }
}
```



解法四：左程云的二叉树递归套路（暂时跳过）

```Java

```

