# 一、链表

从逻辑结构上来说，数组和链表这两种数据结构都属于线性表。所谓线性表，就是所有数据都排列在只有一个维度的“线”上

从物理上来说，即在内存中，这两种逻辑结构所对应的物理存储分布上看，数组占用的是一块连续的内存区，而链表在内存中，是分散的，因为是分散的，就需要一种东西把他们串起来，这样才能形成逻辑上的线性表，不像数组，与生俱来具有“线性”的成分。因为链表比数组多了一个“串起来”的额外操作，这个操作就是加了个指向下个节点的指针，所以对于链表来说，存储一个节点，所要消耗的资源就多了。也正因为这种物理结构上的差异，导致了他们在**访问、增加、删除**节点这三种操作上所带来的时间复杂度不同。

<font color=red>整理下线性表，放到数组笔记里</font>

之前的栈和队列都依托着动态数组实现，靠resize解决固定容量问题，其更底层则是静态数组

现在要学习真正的动态数据结构--链表，在掌握了基本的链表知识后，应该思考如何用链表构建栈和队列

## 链表的节点

链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是**非连续**的。

链表的节点对象具有两个成员变量：

* 值 `e`
* 后继节点引用 `next`

```java
private class Node{
    public E e;
    public Node next;

    public Node(E e, Node next){
        this.e = e;
        this.next = next;
    }
}
```



链表的优点：真正的动态，不需要处理固定容量的问题

链表的缺点：丧失了随机访问的能力

数组最好用于索引有语意的情况，因为其支持快速查询，链表不适合索引有语意的情况，其索引复杂度较高，最大的优点是动态



# 二、单向链表

如果序列中的节点只包含指向后继节点的链接，该链表就称为单向链表

![SinglyLinkedList](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8.png)

## 实现单向链表

其实代码如下：其中有很多操作建议拿纸笔画一画，例如插入、删除等

```java
public class ListNode {
	int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```



删除链表指定元素：

```Java
// 不添加虚拟节点，删除头结点时另做考虑（由于头结点没有前一个结点）
// 因为while循环里是考虑cur，如果没有虚拟头节点，那么初始head就没考虑进去
public ListNode removeElements(ListNode head, int val) {
    // 删除值相同的头结点后，可能新的头结点也值相等，用循环解决
    while(head != null && head.val == val){
        head = head.next;
    }

    if(head == null) return head;

    ListNode pre = head;
    ListNode cur = head.next;

    while(cur != null){
        if(cur.val == val){
            pre.next = cur.next;
        }
        else{
            pre = cur;
        }
        cur = cur.next;
    }
    return head;
}


// 添加虚拟头节点，删除头结点就不用另做考虑（更推荐）
public ListNode removeElements(ListNode head, int val) {
    if(head==null) return head;
    ListNode dummy = new ListNode(-1,head);
    ListNode pre = dummy;
    ListNode cur = head;

    while(cur != null){
        if(cur.val == val){
            pre.next = cur.next;
        }
        else{
            pre = cur;
        }
        cur = cur.next;            
    }
    return dummy.next;
}
```















```java
public class LinkedList<E> {
    //外部用户无需知道Node细节，设计成私有类
    private class Node{
        public E e;
        public Node next;

        public Node(E e, Node next){
            this.e = e;
            this.next = next;
        }

        public Node(E e){
            this(e,null);
        }

        public Node(){
            this(null,null);
        }

        @Override
        public String toString(){
            return e.toString();
        }
    }

    //创建虚拟头节点
    private Node dummyHead;
    private int size;

    public LinkedList(){
        dummyHead = new Node(null,null);
        size = 0;
    }

    //获取链表中的元素个数
    public int getsize(){
        return size;
    }

    //返回链表是否为空
    public boolean isEmpty(){
        return size==0;
    }

    // 在链表的Index(0-based)位置添加新的元素e
    public void add(int index, E e){
        if (index<0 || index>size)
            throw new IllegalArgumentException("Add failed. Illegal index.");

        //关键点：找到待插入位置的前一个元素
        // 使用虚拟头节点
        Node prev = dummyHead;
        // 如果不使用虚拟头节点，条件应该为i<index-1，因为prev一开始就在索引为0的地方，i=0时，prev=1，
        // i只需要取到index-2的地方，prev就能够=index-1,就能找到待插入位置的前一个位置
        // 如果使用虚拟头节点，条件则为i<index，因为prev一开始在索引为0的前一个地方，i=0时，prev=0，
        // i需要取到index-1，prev才能=index-1,进而找到待插入位置的前一个位置
        for (int i = 0; i < index; i++)
            prev = prev.next;

//            Node node = new Node(e);
//            node.next = prev.next;
//            prev.next = node;

        //上面三句可以合并为下面这句
        prev.next = new Node(e, prev.next);
        size++;

    }

    // 在链表头添加新的元素e
    public void addFirst(E e){
        add(0,e);
    }

    // 在链表末尾添加新的元素e
    public void addLast(E e){
        add(size,e);
    }

    // 获取链表的第Index(0-based)个位置的元素
    public E get(int index){
        if (index<0 || index>size)
            throw new IllegalArgumentException("Get failed. Illegal index.");

        // 这里和添加元素不同，那是获取索引位置的前一个位置，这里就是获取索引的位置，
        // 所以让cur指向虚拟头节点的下一个位置，循环还是取到index前一个
        Node cur = dummyHead.next;
        for (int i = 0; i < index; i++)
            cur = cur.next;
        return cur.e;
    }

    // 获得链表的第一个元素
    public E getFirst(){
        return get(0);
    }

    // 获得链表的最后一个元素
    public E getLast(){
        return get(size-1);
    }

    // 修改链表的第Index(0-based)个位置的元素为e
    // 在链表中不是一个常用的操作，练习用
    public void set(int index,E e){
        if (index<0 || index>size)
            throw new IllegalArgumentException("Set failed. Illegal index.");

        // 直接获取索引位置，cur指向虚拟头节点后一个位置，即索引为0的位置
        Node cur = dummyHead.next;
        for (int i = 0; i < index; i++)
            cur = cur.next;
        cur.e = e;
    }

    // 查找链表中是否有元素e
    public boolean contains(E e){
        Node cur = dummyHead.next;
        while (cur!=null){
            if (cur.e.equals(e))
                return true;
            cur = cur.next;
        }
        return false;
    }

    // 从链表中删除Index(0-based)位置的元素，返回删除的元素
    // 在链表中不是一个常用的操作，练习用

    public E remove(int index){
        if (index<0 || index>size)
            throw new IllegalArgumentException("Remove failed. Illegal index.");

        // 删除操作和插入操作类似，都需要找到待操作元素的前一个元素，所以使用虚拟头节点
        Node prev = dummyHead;
        for (int i = 0; i < index; i++)
            prev = prev.next;

        Node retNode = prev.next;
        prev.next = retNode.next;
        retNode.next = null;
        size--;

        return retNode.e;
    }

    // 从链表中删除第一个元素，返回删除的元素
    public E removeFirst(){
        return remove(0);
    }

    // 从链表中删除最后一个元素，返回删除的元素
    public E removeLast(){
        return remove(size-1);
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        Node cur = dummyHead.next;
        while (cur != null){
            res.append(cur + "->");
            cur = cur.next;
        }
        res.append("NULL");
        return res.toString();
    }
}
```





## 单向链表时间复杂度

添加操作（O(n) ）：addLast(e) --> O(n)     addFirst(e) --> O(1)     add(index,e)- -> O(n/2) = O(n)

删除操作（O(n) ）：removeLast(e) --> O(n)     removeFirst(e) --> O(1)     remove(index)- -> O(n/2) = O(n)

修改操作（O(n) ）：set(index,e) --> O(n/2) = O(n)

查找操作（O(n) ）：get(index) --> O(n)   contains(e) --> O(n)   getFirst--> O(1)

单向链表的增删改查操作时间复杂度都是O(n)，但如果只是对链表头进行增删查，复杂度为O(1)。所以单向链表适合只对首元素增删查的场景。



## 用单向链表实现栈

只对首元素增删查显然符合栈的应用场景，因此此处可以用构建的链表去实现一个栈，与之前用动态数组实现的栈可以对比。（这部分内容放在了栈章节对应的笔记中）



## 用单向链表实现队列

当用单向链表实现队列时，不可避免地要从一端添加元素，另一端删除元素，这就可能会让二者之一的时间复杂度变成O(n)，因为只有对链表头操作复杂度才是O(1)。这自然是要避免的，因此需要对链表进行改进。

![SinglyLinkedList_with Tail](https://jswanyu-1309100582.cos.ap-shanghai.myqcloud.com/picgo/SinglyLinkedList_with%20Tail.png)

如上图所示，由于不可避免的要从链表的另一端操作，所以需要对链表添加尾节点tail。可以想到的是，**从尾节点添加元素很容易**，将尾节点的next指针指向新节点即可，但想要**从尾节点删除元素很困难**，因为仍然需要从头节点遍历到尾节点前一个位置，时间复杂度仍然是O(n)。此时又会想到之前的分析，从链表头无论是添加元素还是删除元素都很容易，均为O(1)，因此我们可以作出如下改进：在**tail端添加元素，在head端删除元素**。由于队列的操作只要操作头尾，不涉及到中间元素，因此就不设计dummyHead虚拟头节点了，但也要小心当head和tail都为空时，都指向NULL，即链表为空的情况。

基于以上思想，重新设计链表并实现队列，代码如下：

```java
public class LinkedListQueue<E> implements Queue<E> {
    private class Node{
		//同上，此处省略
    }

    private Node head,tail;
    private int size;

    public LinkedListQueue(){
        head = null;
        tail = null;
        size = 0;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return size==0;
    }

    @Override
    public void enqueue(E e) {
        //如果tail为空，则表明链表为空
        if (tail ==null){
            tail = new Node(e);
            head = tail;
        }
        //否则，新建尾节点并更新tail，head不动
        else{
            tail.next = new Node(e);
            tail = tail.next;
        }
        size++;
    }

    @Override
    public E dequeue() {
        if(isEmpty())
            throw new IllegalArgumentException("Cannot dequeue from an empty queue.");
        //如果不为空，出队的就是头节点
        Node retNode = head;
        head = head.next; //更新头节点
        retNode.next = null; //出队的节点的next要指向null，即将其从链表中断开

        //如果链表里只有一个节点，头节点出队后head就指向了null，此时需要将tail也指向null，否则tail还在指向原来那个节点
        if (head == null)
            tail = null;
        size--;
        return retNode.e;
    }

    @Override
    public E getFront() {
        if(isEmpty())
            throw new IllegalArgumentException("Cannot dequeue from an empty queue.");
        return head.e;
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        res.append("Queue: front ");
        Node cur = head;
        while (cur != null){
            res.append(cur + "->");
            cur = cur.next;
        }
        res.append("NULL tail");
        return res.toString();
    }
}
```

此队列的各个操作时间复杂度同样为O(1)，和改进后的循环队列相同













