# 栈

栈（Stack）是一种线性结构，相比数组，栈对应的操作是数组的子集，只能从一段添加元素，也只能从同一端取出元素，这一端被称为**栈顶**。

栈是一种**后进先出**（Last In First Out, LIFO）的数据结构。

[![Igoyin.png](https://z3.ax1x.com/2021/11/15/Igoyin.png)](https://imgtu.com/i/Igoyin)

栈的应用：(举例)

* Undo操作，撤销
* 程序调用的系统栈



栈的常用操作：

* int getSize();                   O(1) 均摊
* boolean isEmpty();       O(1) 均摊
* void push(E e);              O(1) 
* E pop();                           O(1) 
* E peek();                         O(1) 



可以定义栈的接口

```java
public interface Stack<E> {
    int getSize();
    boolean isEmpty();
    void push(E e);
    E pop();
    E peek();
}
```



## 基于动态数组实现的栈

代码如下

```java
public class ArrayStack<E> implements Stack<E> {

    Array<E> array;
    public ArrayStack(int capacity){
        array = new Array<>(capacity);
    }

    public ArrayStack(){
        array = new Array<>();
    }

    @Override
    public int getSize(){
        return array.getSize();
    }

    @Override
    public boolean isEmpty(){
        return array.isEmpty();
    }

    public int getCapacity(){
        return array.getCapacity();
    }

    //可能会引起扩容
    @Override
    public void push(E e){
        array.addLast(e);
    }

    //可能会引起缩容
    @Override
    public E pop(){
        return array.removeLast();
    }

    @Override
    public E peek(){
        return array.getLast();
    }

    @Override
    public String toString(){
        StringBuilder res = new StringBuilder();
        res.append("Stack:");
        res.append("[");
        for (int i = 0; i < array.getSize(); i++) {
            res.append(array.get(i));
            if (i != array.getSize()-1)
                res.append(",");
        }
        res.append("] top");
        return res.toString();
    }
}
```



## 基于单向链表实现的栈

代码如下（在学完单向链表之后，可以用其来实现栈）

```java
public class LinkedListStack<E> implements Stack<E>{
    private LinkedList<E> list;

    public LinkedListStack() {
        list = new LinkedList<>();
    }

    @Override
    public int getSize(){
        return list.getsize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void push(E e) {
        list.addFirst(e);
    }

    @Override
    public E pop() {
        return list.removeFirst();
    }

    @Override
    public E peek() {
        return list.getFirst();
    }

    @Override
    public String toString() {
        StringBuilder res = new StringBuilder();
        res.append("Stack: top ");
        res.append(list);
        return res.toString();
    }

    public static void main(String[] args) {
        LinkedListStack<Integer> stack = new LinkedListStack<>();
        for (int i = 0; i < 5; i++) {
            stack.push(i);
            System.out.println(stack);
        }
        Integer a = stack.pop();
        System.out.println(stack);
    }
}
```



基于动态数组和链表实现的栈对比：

```java
public class Main {
    // 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒s
    // 由于测试时间和操作系统状态有关，因此更科学的是测试多次取平均值，这里只是简单测试一下
    // 同时，不同的jvm版本对java有不同的优化效果

    private static double testStack(Stack<Integer> stack, int opCount){
        long startTime = System.nanoTime();

        Random random = new Random();
        for (int i = 0; i < opCount; i++)
            stack.push(random.nextInt(Integer.MAX_VALUE));
        for (int i = 0; i < opCount; i++)
            stack.pop();

        long endTime = System.nanoTime();
        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {
        int opCount = 100000;

        ArrayStack<Integer> arrayStack = new ArrayStack<>();
        double time1 = testStack(arrayStack,opCount);
        System.out.println("ArrayStack, time: "+ time1 + " s");

        LinkedListStack<Integer> linkedListStack = new LinkedListStack<>();
        double time2 = testStack(linkedListStack,opCount);
        System.out.println("LinkedListStack, time: "+ time2 + " s");
    }
}
```

>   ArrayStack, time: 0.009479 s
>   LinkedListStack, time: 0.0099697 s



能够看出由于栈只对栈顶操作，无论是基于动态数组还是链表实现，push和pop操作时间复杂度都是O(1)，因此时间差距不大
